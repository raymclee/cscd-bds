package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.56

import (
	"context"
	"cscd-bds/graphql/model"
	"cscd-bds/store/ent"
	"cscd-bds/store/ent/area"
	"cscd-bds/store/ent/district"
	"cscd-bds/store/ent/province"
	"cscd-bds/store/ent/schema/xid"
	"cscd-bds/store/ent/tender"
	"cscd-bds/store/ent/user"
	"cscd-bds/store/ent/visitrecord"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"

	"entgo.io/contrib/entgql"
	"golang.org/x/sync/errgroup"
)

// Draft is the resolver for the draft field.
func (r *customerResolver) Draft(ctx context.Context, obj *ent.Customer) (*model.CustomerDraft, error) {
	var out model.CustomerDraft
	if obj.Draft != nil {
		if obj.Draft.Name != nil {
			out.Name = obj.Draft.Name
		}
		if obj.Draft.OwnerType != nil {
			out.OwnerType = obj.Draft.OwnerType
		}
		if obj.Draft.Industry != nil {
			out.Industry = obj.Draft.Industry
		}
		if obj.Draft.Size != nil {
			out.Size = obj.Draft.Size
		}
		if obj.Draft.ContactPerson != nil {
			out.ContactPerson = obj.Draft.ContactPerson
		}
		if obj.Draft.ContactPersonPosition != nil {
			out.ContactPersonPosition = obj.Draft.ContactPersonPosition
		}
		if obj.Draft.ContactPersonPhone != nil {
			out.ContactPersonPhone = obj.Draft.ContactPersonPhone
		}
		if obj.Draft.ContactPersonEmail != nil {
			out.ContactPersonEmail = obj.Draft.ContactPersonEmail
		}
		if obj.Draft.AreaID != nil {
			area, err := r.store.Area.Query().Where(area.ID(xid.ID(*obj.Draft.AreaID))).Only(ctx)
			if err != nil {
				return nil, err
			}
			out.Area = area
		}
		if obj.Draft.SalesID != nil {
			user, err := r.store.User.Query().Where(user.ID(xid.ID(*obj.Draft.SalesID))).Only(ctx)
			if err != nil {
				return nil, err
			}
			out.Sales = user
		}
	}
	return &out, nil
}

// SearchFeishuUser is the resolver for the searchFeishuUser field.
func (r *queryResolver) SearchFeishuUser(ctx context.Context, keyword string) ([]*model.FeishuUser, error) {
	users, err := r.feishu.SearchFeishuUser(ctx, keyword)
	if err != nil {
		return nil, err
	}

	userIds := make([]string, 0, len(*users))
	for _, user := range *users {
		userIds = append(userIds, user.OpenID)

	}

	userInfos, err := r.feishu.GetUserInfos(ctx, userIds)
	if err != nil {
		return nil, err
	}

	var out []*model.FeishuUser
	for _, userInfo := range userInfos {
		for _, user := range *users {
			if userInfo.OpenId != nil && userInfo.Email != nil && *userInfo.OpenId == user.OpenID {
				out = append(out, &model.FeishuUser{
					OpenID:    user.OpenID,
					Name:      user.Name,
					AvatarURL: user.Avatar.AvatarOrigin,
					Email:     *userInfo.Email,
				})
			}
		}
	}

	return out, nil
}

// SearchLocation is the resolver for the searchLocation field.
func (r *queryResolver) SearchLocation(ctx context.Context, keyword string) ([]*model.Location, error) {
	geoResp, err := r.amap.SearchLocation(keyword)
	if err != nil {
		return nil, fmt.Errorf("failed to search location: %w", err)
	}
	var wg errgroup.Group
	var out []*model.Location
	for _, geo := range geoResp.GeoCodes {
		wg.Go(func() error {
			o := &model.Location{
				ID:      xid.MustNew("AL"),
				Address: geo.FormattedAddress,
			}
			ac, err := strconv.Atoi(geo.AdCode)
			if err != nil {
				return fmt.Errorf("failed to convert adcode: %w", err)
			}
			d, err := r.store.District.Query().Where(district.Adcode(ac)).WithCity().WithProvince().Only(ctx)
			if err != nil {
				return nil
			}
			if d != nil {
				o.City = d.Edges.City
				o.Province = d.Edges.Province
				o.District = d
			}
			out = append(out, o)
			return nil
		})
	}
	if err := wg.Wait(); err != nil {
		return nil, err
	}
	return out, nil
}

// Inputtips is the resolver for the inputtips field.
func (r *queryResolver) Inputtips(ctx context.Context, areaID xid.ID, keyword string) ([]*model.Location, error) {
	// https://restapi.amap.com/v3/assistant/inputtips?key={{key}}&keywords=福建省漳州市漳浦县

	geoResp, err := r.amap.LocationTips(keyword)
	if err != nil {
		return nil, err
	}

	var wg errgroup.Group
	var out []*model.Location
	for _, tip := range geoResp.Tips {
		wg.Go(func() error {
			o := &model.Location{
				ID:   xid.MustNew("AL"),
				Name: tip.Name,
			}
			if a, ok := tip.Address.(string); ok {
				o.Address = a
			}
			loc := strings.Split(tip.Location, ",")
			if len(loc) != 2 {
				return fmt.Errorf("invalid location: %s", tip.Location)
			}
			o.Lat, err = strconv.ParseFloat(loc[1], 64)
			if err != nil {
				return fmt.Errorf("failed to convert latitude: %w", err)
			}
			o.Lng, err = strconv.ParseFloat(loc[0], 64)
			if err != nil {
				return fmt.Errorf("failed to convert longitude: %w", err)
			}
			ac, err := strconv.Atoi(tip.Adcode)
			if err != nil {
				return fmt.Errorf("failed to convert adcode: %w", err)
			}
			d, err := r.store.District.Query().
				Where(district.Adcode(ac)).
				Where(district.HasProvinceWith(province.AreaID(areaID))).
				WithCity().
				WithProvince().
				Only(ctx)
			if err != nil {
				return nil
			}
			if d != nil {
				o.City = d.Edges.City
				o.Province = d.Edges.Province
				o.District = d
			}
			out = append(out, o)
			return nil
		})
	}
	if err := wg.Wait(); err != nil {
		return nil, err
	}
	return out, nil
}

// AmapRegeo is the resolver for the amapRegeo field.
func (r *queryResolver) AmapRegeo(ctx context.Context, lng float64, lat float64) ([]*model.Location, error) {
	geoResp, err := r.amap.Regeo(lng, lat)
	if err != nil {
		return nil, err
	}

	placeResp, err := r.amap.Place(geoResp.ReGeocode.FormattedAddress)
	if err != nil {
		return nil, err
	}

	var wg errgroup.Group
	var out []*model.Location
	for _, poi := range placeResp.Pois {
		wg.Go(func() error {
			o := &model.Location{
				ID:      xid.MustNew("AL"),
				Name:    poi.Name,
				Address: poi.Address,
			}
			loc := strings.Split(poi.Location, ",")
			if len(loc) != 2 {
				return fmt.Errorf("invalid location: %s", poi.Location)
			}
			o.Lat, err = strconv.ParseFloat(loc[1], 64)
			if err != nil {
				return fmt.Errorf("failed to convert latitude: %w", err)
			}
			o.Lng, err = strconv.ParseFloat(loc[0], 64)
			if err != nil {
				return fmt.Errorf("failed to convert longitude: %w", err)
			}
			ac, err := strconv.Atoi(poi.AdCode)
			if err != nil {
				return fmt.Errorf("failed to convert adcode: %w", err)
			}
			d, err := r.store.District.Query().Where(district.Adcode(ac)).WithCity().WithProvince().Only(ctx)
			if err != nil {
				return nil
			}
			if d != nil {
				o.City = d.Edges.City
				o.Province = d.Edges.Province
				o.District = d
			}
			out = append(out, o)
			return nil
		})
	}
	if err := wg.Wait(); err != nil {
		return nil, err
	}
	return out, nil
}

// TopCompetitors is the resolver for the topCompetitors field.
func (r *queryResolver) TopCompetitors(ctx context.Context, first *int) ([]*model.TopCompetitor, error) {
	comps, err := r.store.Competitor.Query().
		// Order(competitor.ByWonTendersCount(sql.OrderDesc())).
		WithTenders().
		All(ctx)
	if err != nil {
		return nil, err
	}
	var out []*model.TopCompetitor
	for _, comp := range comps {
		out = append(out, &model.TopCompetitor{
			ID:              xid.ID(fmt.Sprintf("TC-%s", strings.ReplaceAll(string(comp.ID), "CP-", ""))),
			Name:            comp.Name,
			ShortName:       comp.ShortName,
			WonTendersCount: int(len(comp.Edges.Tenders)),
		})
	}
	return out, nil
}

// BiToken is the resolver for the biToken field.
func (r *queryResolver) BiToken(ctx context.Context) (string, error) {
	resp, err := http.Get("https://bi.fefacade.com/webroot/decision/login/cross/domain?fine_username=ray.mclee&fine_password=ray.mclee830&validity=-1")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}
	ss := string(body)[25:348]

	return ss, nil
}

// MyTenders is the resolver for the myTenders field.
func (r *userResolver) MyTenders(ctx context.Context, obj *ent.User, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, orderBy []*ent.TenderOrder, where *ent.TenderWhereInput) (*ent.TenderConnection, error) {
	var q *ent.TenderQuery
	switch {
	case obj.IsAdmin:
		areaIds, err := obj.QueryAreas().IDs(ctx)
		if err != nil {
			return nil, err
		}
		q = r.store.Tender.Query().Where(tender.AreaIDIn(areaIds...))
	case obj.IsCeo || obj.IsSuperAdmin:
		q = r.store.Tender.Query()
	default:
		q = r.store.Tender.Query().
			Where(tender.Or(
				tender.HasFollowingSalesWith(user.ID(obj.ID)),
				tender.HasCreatedByWith(user.ID(obj.ID)),
				tender.HasFinderWith(user.ID(obj.ID)),
			))
	}
	conn, err := q.
		Paginate(ctx, after, first, before, last, ent.WithTenderOrder(orderBy), ent.WithTenderFilter(where.Filter))
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// MyVisitRecords is the resolver for the myVisitRecords field.
func (r *userResolver) MyVisitRecords(ctx context.Context, obj *ent.User, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, orderBy []*ent.VisitRecordOrder, where *ent.VisitRecordWhereInput) (*ent.VisitRecordConnection, error) {
	var q *ent.VisitRecordQuery
	switch {
	case obj.IsAdmin || obj.IsCeo || obj.IsSuperAdmin:
		q = r.store.VisitRecord.Query()
	default:
		q = r.store.VisitRecord.Query().Where(
			visitrecord.And(
				visitrecord.HasFollowUpBysWith(user.ID(obj.ID)),
			),
		)
	}
	conn, err := q.
		Paginate(ctx, after, first, before, last, ent.WithVisitRecordOrder(orderBy), ent.WithVisitRecordFilter(where.Filter))
	if err != nil {
		return nil, err
	}
	return conn, nil
}
