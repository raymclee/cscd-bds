// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"cscd-bds/store/ent"
	"cscd-bds/store/ent/schema/xid"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Customer() CustomerResolver
	Query() QueryResolver
	Tender() TenderResolver
	CreateCustomerInput() CreateCustomerInputResolver
	CreateTenderInput() CreateTenderInputResolver
	CustomerWhereInput() CustomerWhereInputResolver
	TenderWhereInput() TenderWhereInputResolver
	UpdateCustomerInput() UpdateCustomerInputResolver
	UpdateTenderInput() UpdateTenderInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Area struct {
		Code      func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Customers func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Sales     func(childComplexity int) int
		Tenders   func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	AreaConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	AreaEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	City struct {
		Adcode     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		Districts  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		ProvCode   func(childComplexity int) int
		Province   func(childComplexity int) int
		ProvinceID func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	CityConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CityEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Country struct {
		Adcode    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Provinces func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	CountryConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CountryEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Customer struct {
		Area                  func(childComplexity int) int
		AreaID                func(childComplexity int) int
		ContactPerson         func(childComplexity int) int
		ContactPersonEmail    func(childComplexity int) int
		ContactPersonPhone    func(childComplexity int) int
		ContactPersonPosition func(childComplexity int) int
		CreatedAt             func(childComplexity int) int
		CreatedBy             func(childComplexity int) int
		CreatedByUserID       func(childComplexity int) int
		ID                    func(childComplexity int) int
		Industry              func(childComplexity int) int
		Name                  func(childComplexity int) int
		OwnerType             func(childComplexity int) int
		Sales                 func(childComplexity int) int
		SalesID               func(childComplexity int) int
		Size                  func(childComplexity int) int
		Tenders               func(childComplexity int) int
		UpdatedAt             func(childComplexity int) int
	}

	CustomerConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	CustomerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	District struct {
		Adcode     func(childComplexity int) int
		City       func(childComplexity int) int
		CityCode   func(childComplexity int) int
		CityID     func(childComplexity int) int
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		ProvCode   func(childComplexity int) int
		Province   func(childComplexity int) int
		ProvinceID func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	DistrictConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DistrictEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Province struct {
		Adcode    func(childComplexity int) int
		Cities    func(childComplexity int) int
		Country   func(childComplexity int) int
		CountryID func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Districts func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	ProvinceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ProvinceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Query struct {
		Areas     func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.AreaWhereInput) int
		Cities    func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.CityWhereInput) int
		Countries func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.CountryWhereInput) int
		Customers func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.CustomerWhereInput) int
		Districts func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.DistrictWhereInput) int
		Node      func(childComplexity int, id xid.ID) int
		Nodes     func(childComplexity int, ids []*xid.ID) int
		Provinces func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.ProvinceWhereInput) int
		Session   func(childComplexity int) int
		Tenders   func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.TenderWhereInput) int
		Users     func(childComplexity int, after *entgql.Cursor[xid.ID], first *int, before *entgql.Cursor[xid.ID], last *int, where *ent.UserWhereInput) int
	}

	Session struct {
		AvatarURL func(childComplexity int) int
		Email     func(childComplexity int) int
		Name      func(childComplexity int) int
		Username  func(childComplexity int) int
	}

	Tender struct {
		Area                         func(childComplexity int) int
		AreaID                       func(childComplexity int) int
		Attachements                 func(childComplexity int) int
		Code                         func(childComplexity int) int
		CompetitivePartnershipRating func(childComplexity int) int
		CreatedAt                    func(childComplexity int) int
		CreditAndPaymentRating       func(childComplexity int) int
		Customer                     func(childComplexity int) int
		CustomerID                   func(childComplexity int) int
		CustomerRelationshipRating   func(childComplexity int) int
		EstimatedAmount              func(childComplexity int) int
		EstimatedProjectEndDate      func(childComplexity int) int
		EstimatedProjectStartDate    func(childComplexity int) int
		FindDate                     func(childComplexity int) int
		GeoLocation                  func(childComplexity int) int
		ID                           func(childComplexity int) int
		Images                       func(childComplexity int) int
		Name                         func(childComplexity int) int
		PrepareToBid                 func(childComplexity int) int
		ProjectCode                  func(childComplexity int) int
		ProjectDefinition            func(childComplexity int) int
		ProjectType                  func(childComplexity int) int
		Remark                       func(childComplexity int) int
		SizeAndValueRating           func(childComplexity int) int
		Status                       func(childComplexity int) int
		TenderDate                   func(childComplexity int) int
		TimeLimitRating              func(childComplexity int) int
		UpdatedAt                    func(childComplexity int) int
	}

	TenderConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	TenderEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		Areas       func(childComplexity int) int
		AvatarURL   func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Customers   func(childComplexity int) int
		Disabled    func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		Leader      func(childComplexity int) int
		LeaderID    func(childComplexity int) int
		Name        func(childComplexity int) int
		OpenID      func(childComplexity int) int
		TeamMembers func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	UserConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	UserEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Area.code":
		if e.complexity.Area.Code == nil {
			break
		}

		return e.complexity.Area.Code(childComplexity), true

	case "Area.createdAt":
		if e.complexity.Area.CreatedAt == nil {
			break
		}

		return e.complexity.Area.CreatedAt(childComplexity), true

	case "Area.customers":
		if e.complexity.Area.Customers == nil {
			break
		}

		return e.complexity.Area.Customers(childComplexity), true

	case "Area.id":
		if e.complexity.Area.ID == nil {
			break
		}

		return e.complexity.Area.ID(childComplexity), true

	case "Area.name":
		if e.complexity.Area.Name == nil {
			break
		}

		return e.complexity.Area.Name(childComplexity), true

	case "Area.sales":
		if e.complexity.Area.Sales == nil {
			break
		}

		return e.complexity.Area.Sales(childComplexity), true

	case "Area.tenders":
		if e.complexity.Area.Tenders == nil {
			break
		}

		return e.complexity.Area.Tenders(childComplexity), true

	case "Area.updatedAt":
		if e.complexity.Area.UpdatedAt == nil {
			break
		}

		return e.complexity.Area.UpdatedAt(childComplexity), true

	case "AreaConnection.edges":
		if e.complexity.AreaConnection.Edges == nil {
			break
		}

		return e.complexity.AreaConnection.Edges(childComplexity), true

	case "AreaConnection.pageInfo":
		if e.complexity.AreaConnection.PageInfo == nil {
			break
		}

		return e.complexity.AreaConnection.PageInfo(childComplexity), true

	case "AreaConnection.totalCount":
		if e.complexity.AreaConnection.TotalCount == nil {
			break
		}

		return e.complexity.AreaConnection.TotalCount(childComplexity), true

	case "AreaEdge.cursor":
		if e.complexity.AreaEdge.Cursor == nil {
			break
		}

		return e.complexity.AreaEdge.Cursor(childComplexity), true

	case "AreaEdge.node":
		if e.complexity.AreaEdge.Node == nil {
			break
		}

		return e.complexity.AreaEdge.Node(childComplexity), true

	case "City.adcode":
		if e.complexity.City.Adcode == nil {
			break
		}

		return e.complexity.City.Adcode(childComplexity), true

	case "City.createdAt":
		if e.complexity.City.CreatedAt == nil {
			break
		}

		return e.complexity.City.CreatedAt(childComplexity), true

	case "City.districts":
		if e.complexity.City.Districts == nil {
			break
		}

		return e.complexity.City.Districts(childComplexity), true

	case "City.id":
		if e.complexity.City.ID == nil {
			break
		}

		return e.complexity.City.ID(childComplexity), true

	case "City.name":
		if e.complexity.City.Name == nil {
			break
		}

		return e.complexity.City.Name(childComplexity), true

	case "City.provCode":
		if e.complexity.City.ProvCode == nil {
			break
		}

		return e.complexity.City.ProvCode(childComplexity), true

	case "City.province":
		if e.complexity.City.Province == nil {
			break
		}

		return e.complexity.City.Province(childComplexity), true

	case "City.provinceID":
		if e.complexity.City.ProvinceID == nil {
			break
		}

		return e.complexity.City.ProvinceID(childComplexity), true

	case "City.updatedAt":
		if e.complexity.City.UpdatedAt == nil {
			break
		}

		return e.complexity.City.UpdatedAt(childComplexity), true

	case "CityConnection.edges":
		if e.complexity.CityConnection.Edges == nil {
			break
		}

		return e.complexity.CityConnection.Edges(childComplexity), true

	case "CityConnection.pageInfo":
		if e.complexity.CityConnection.PageInfo == nil {
			break
		}

		return e.complexity.CityConnection.PageInfo(childComplexity), true

	case "CityConnection.totalCount":
		if e.complexity.CityConnection.TotalCount == nil {
			break
		}

		return e.complexity.CityConnection.TotalCount(childComplexity), true

	case "CityEdge.cursor":
		if e.complexity.CityEdge.Cursor == nil {
			break
		}

		return e.complexity.CityEdge.Cursor(childComplexity), true

	case "CityEdge.node":
		if e.complexity.CityEdge.Node == nil {
			break
		}

		return e.complexity.CityEdge.Node(childComplexity), true

	case "Country.adcode":
		if e.complexity.Country.Adcode == nil {
			break
		}

		return e.complexity.Country.Adcode(childComplexity), true

	case "Country.createdAt":
		if e.complexity.Country.CreatedAt == nil {
			break
		}

		return e.complexity.Country.CreatedAt(childComplexity), true

	case "Country.id":
		if e.complexity.Country.ID == nil {
			break
		}

		return e.complexity.Country.ID(childComplexity), true

	case "Country.name":
		if e.complexity.Country.Name == nil {
			break
		}

		return e.complexity.Country.Name(childComplexity), true

	case "Country.provinces":
		if e.complexity.Country.Provinces == nil {
			break
		}

		return e.complexity.Country.Provinces(childComplexity), true

	case "Country.updatedAt":
		if e.complexity.Country.UpdatedAt == nil {
			break
		}

		return e.complexity.Country.UpdatedAt(childComplexity), true

	case "CountryConnection.edges":
		if e.complexity.CountryConnection.Edges == nil {
			break
		}

		return e.complexity.CountryConnection.Edges(childComplexity), true

	case "CountryConnection.pageInfo":
		if e.complexity.CountryConnection.PageInfo == nil {
			break
		}

		return e.complexity.CountryConnection.PageInfo(childComplexity), true

	case "CountryConnection.totalCount":
		if e.complexity.CountryConnection.TotalCount == nil {
			break
		}

		return e.complexity.CountryConnection.TotalCount(childComplexity), true

	case "CountryEdge.cursor":
		if e.complexity.CountryEdge.Cursor == nil {
			break
		}

		return e.complexity.CountryEdge.Cursor(childComplexity), true

	case "CountryEdge.node":
		if e.complexity.CountryEdge.Node == nil {
			break
		}

		return e.complexity.CountryEdge.Node(childComplexity), true

	case "Customer.area":
		if e.complexity.Customer.Area == nil {
			break
		}

		return e.complexity.Customer.Area(childComplexity), true

	case "Customer.areaID":
		if e.complexity.Customer.AreaID == nil {
			break
		}

		return e.complexity.Customer.AreaID(childComplexity), true

	case "Customer.contactPerson":
		if e.complexity.Customer.ContactPerson == nil {
			break
		}

		return e.complexity.Customer.ContactPerson(childComplexity), true

	case "Customer.contactPersonEmail":
		if e.complexity.Customer.ContactPersonEmail == nil {
			break
		}

		return e.complexity.Customer.ContactPersonEmail(childComplexity), true

	case "Customer.contactPersonPhone":
		if e.complexity.Customer.ContactPersonPhone == nil {
			break
		}

		return e.complexity.Customer.ContactPersonPhone(childComplexity), true

	case "Customer.contactPersonPosition":
		if e.complexity.Customer.ContactPersonPosition == nil {
			break
		}

		return e.complexity.Customer.ContactPersonPosition(childComplexity), true

	case "Customer.createdAt":
		if e.complexity.Customer.CreatedAt == nil {
			break
		}

		return e.complexity.Customer.CreatedAt(childComplexity), true

	case "Customer.createdBy":
		if e.complexity.Customer.CreatedBy == nil {
			break
		}

		return e.complexity.Customer.CreatedBy(childComplexity), true

	case "Customer.createdByUserID":
		if e.complexity.Customer.CreatedByUserID == nil {
			break
		}

		return e.complexity.Customer.CreatedByUserID(childComplexity), true

	case "Customer.id":
		if e.complexity.Customer.ID == nil {
			break
		}

		return e.complexity.Customer.ID(childComplexity), true

	case "Customer.industry":
		if e.complexity.Customer.Industry == nil {
			break
		}

		return e.complexity.Customer.Industry(childComplexity), true

	case "Customer.name":
		if e.complexity.Customer.Name == nil {
			break
		}

		return e.complexity.Customer.Name(childComplexity), true

	case "Customer.ownerType":
		if e.complexity.Customer.OwnerType == nil {
			break
		}

		return e.complexity.Customer.OwnerType(childComplexity), true

	case "Customer.sales":
		if e.complexity.Customer.Sales == nil {
			break
		}

		return e.complexity.Customer.Sales(childComplexity), true

	case "Customer.salesID":
		if e.complexity.Customer.SalesID == nil {
			break
		}

		return e.complexity.Customer.SalesID(childComplexity), true

	case "Customer.size":
		if e.complexity.Customer.Size == nil {
			break
		}

		return e.complexity.Customer.Size(childComplexity), true

	case "Customer.tenders":
		if e.complexity.Customer.Tenders == nil {
			break
		}

		return e.complexity.Customer.Tenders(childComplexity), true

	case "Customer.updatedAt":
		if e.complexity.Customer.UpdatedAt == nil {
			break
		}

		return e.complexity.Customer.UpdatedAt(childComplexity), true

	case "CustomerConnection.edges":
		if e.complexity.CustomerConnection.Edges == nil {
			break
		}

		return e.complexity.CustomerConnection.Edges(childComplexity), true

	case "CustomerConnection.pageInfo":
		if e.complexity.CustomerConnection.PageInfo == nil {
			break
		}

		return e.complexity.CustomerConnection.PageInfo(childComplexity), true

	case "CustomerConnection.totalCount":
		if e.complexity.CustomerConnection.TotalCount == nil {
			break
		}

		return e.complexity.CustomerConnection.TotalCount(childComplexity), true

	case "CustomerEdge.cursor":
		if e.complexity.CustomerEdge.Cursor == nil {
			break
		}

		return e.complexity.CustomerEdge.Cursor(childComplexity), true

	case "CustomerEdge.node":
		if e.complexity.CustomerEdge.Node == nil {
			break
		}

		return e.complexity.CustomerEdge.Node(childComplexity), true

	case "District.adcode":
		if e.complexity.District.Adcode == nil {
			break
		}

		return e.complexity.District.Adcode(childComplexity), true

	case "District.city":
		if e.complexity.District.City == nil {
			break
		}

		return e.complexity.District.City(childComplexity), true

	case "District.cityCode":
		if e.complexity.District.CityCode == nil {
			break
		}

		return e.complexity.District.CityCode(childComplexity), true

	case "District.cityID":
		if e.complexity.District.CityID == nil {
			break
		}

		return e.complexity.District.CityID(childComplexity), true

	case "District.createdAt":
		if e.complexity.District.CreatedAt == nil {
			break
		}

		return e.complexity.District.CreatedAt(childComplexity), true

	case "District.id":
		if e.complexity.District.ID == nil {
			break
		}

		return e.complexity.District.ID(childComplexity), true

	case "District.name":
		if e.complexity.District.Name == nil {
			break
		}

		return e.complexity.District.Name(childComplexity), true

	case "District.provCode":
		if e.complexity.District.ProvCode == nil {
			break
		}

		return e.complexity.District.ProvCode(childComplexity), true

	case "District.province":
		if e.complexity.District.Province == nil {
			break
		}

		return e.complexity.District.Province(childComplexity), true

	case "District.provinceID":
		if e.complexity.District.ProvinceID == nil {
			break
		}

		return e.complexity.District.ProvinceID(childComplexity), true

	case "District.updatedAt":
		if e.complexity.District.UpdatedAt == nil {
			break
		}

		return e.complexity.District.UpdatedAt(childComplexity), true

	case "DistrictConnection.edges":
		if e.complexity.DistrictConnection.Edges == nil {
			break
		}

		return e.complexity.DistrictConnection.Edges(childComplexity), true

	case "DistrictConnection.pageInfo":
		if e.complexity.DistrictConnection.PageInfo == nil {
			break
		}

		return e.complexity.DistrictConnection.PageInfo(childComplexity), true

	case "DistrictConnection.totalCount":
		if e.complexity.DistrictConnection.TotalCount == nil {
			break
		}

		return e.complexity.DistrictConnection.TotalCount(childComplexity), true

	case "DistrictEdge.cursor":
		if e.complexity.DistrictEdge.Cursor == nil {
			break
		}

		return e.complexity.DistrictEdge.Cursor(childComplexity), true

	case "DistrictEdge.node":
		if e.complexity.DistrictEdge.Node == nil {
			break
		}

		return e.complexity.DistrictEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Province.adcode":
		if e.complexity.Province.Adcode == nil {
			break
		}

		return e.complexity.Province.Adcode(childComplexity), true

	case "Province.cities":
		if e.complexity.Province.Cities == nil {
			break
		}

		return e.complexity.Province.Cities(childComplexity), true

	case "Province.country":
		if e.complexity.Province.Country == nil {
			break
		}

		return e.complexity.Province.Country(childComplexity), true

	case "Province.countryID":
		if e.complexity.Province.CountryID == nil {
			break
		}

		return e.complexity.Province.CountryID(childComplexity), true

	case "Province.createdAt":
		if e.complexity.Province.CreatedAt == nil {
			break
		}

		return e.complexity.Province.CreatedAt(childComplexity), true

	case "Province.districts":
		if e.complexity.Province.Districts == nil {
			break
		}

		return e.complexity.Province.Districts(childComplexity), true

	case "Province.id":
		if e.complexity.Province.ID == nil {
			break
		}

		return e.complexity.Province.ID(childComplexity), true

	case "Province.name":
		if e.complexity.Province.Name == nil {
			break
		}

		return e.complexity.Province.Name(childComplexity), true

	case "Province.updatedAt":
		if e.complexity.Province.UpdatedAt == nil {
			break
		}

		return e.complexity.Province.UpdatedAt(childComplexity), true

	case "ProvinceConnection.edges":
		if e.complexity.ProvinceConnection.Edges == nil {
			break
		}

		return e.complexity.ProvinceConnection.Edges(childComplexity), true

	case "ProvinceConnection.pageInfo":
		if e.complexity.ProvinceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ProvinceConnection.PageInfo(childComplexity), true

	case "ProvinceConnection.totalCount":
		if e.complexity.ProvinceConnection.TotalCount == nil {
			break
		}

		return e.complexity.ProvinceConnection.TotalCount(childComplexity), true

	case "ProvinceEdge.cursor":
		if e.complexity.ProvinceEdge.Cursor == nil {
			break
		}

		return e.complexity.ProvinceEdge.Cursor(childComplexity), true

	case "ProvinceEdge.node":
		if e.complexity.ProvinceEdge.Node == nil {
			break
		}

		return e.complexity.ProvinceEdge.Node(childComplexity), true

	case "Query.areas":
		if e.complexity.Query.Areas == nil {
			break
		}

		args, err := ec.field_Query_areas_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Areas(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.AreaWhereInput)), true

	case "Query.cities":
		if e.complexity.Query.Cities == nil {
			break
		}

		args, err := ec.field_Query_cities_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Cities(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.CityWhereInput)), true

	case "Query.countries":
		if e.complexity.Query.Countries == nil {
			break
		}

		args, err := ec.field_Query_countries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Countries(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.CountryWhereInput)), true

	case "Query.customers":
		if e.complexity.Query.Customers == nil {
			break
		}

		args, err := ec.field_Query_customers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Customers(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.CustomerWhereInput)), true

	case "Query.districts":
		if e.complexity.Query.Districts == nil {
			break
		}

		args, err := ec.field_Query_districts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Districts(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.DistrictWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(xid.ID)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]*xid.ID)), true

	case "Query.provinces":
		if e.complexity.Query.Provinces == nil {
			break
		}

		args, err := ec.field_Query_provinces_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Provinces(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.ProvinceWhereInput)), true

	case "Query.session":
		if e.complexity.Query.Session == nil {
			break
		}

		return e.complexity.Query.Session(childComplexity), true

	case "Query.tenders":
		if e.complexity.Query.Tenders == nil {
			break
		}

		args, err := ec.field_Query_tenders_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tenders(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.TenderWhereInput)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["after"].(*entgql.Cursor[xid.ID]), args["first"].(*int), args["before"].(*entgql.Cursor[xid.ID]), args["last"].(*int), args["where"].(*ent.UserWhereInput)), true

	case "Session.avatarUrl":
		if e.complexity.Session.AvatarURL == nil {
			break
		}

		return e.complexity.Session.AvatarURL(childComplexity), true

	case "Session.email":
		if e.complexity.Session.Email == nil {
			break
		}

		return e.complexity.Session.Email(childComplexity), true

	case "Session.name":
		if e.complexity.Session.Name == nil {
			break
		}

		return e.complexity.Session.Name(childComplexity), true

	case "Session.username":
		if e.complexity.Session.Username == nil {
			break
		}

		return e.complexity.Session.Username(childComplexity), true

	case "Tender.area":
		if e.complexity.Tender.Area == nil {
			break
		}

		return e.complexity.Tender.Area(childComplexity), true

	case "Tender.areaID":
		if e.complexity.Tender.AreaID == nil {
			break
		}

		return e.complexity.Tender.AreaID(childComplexity), true

	case "Tender.attachements":
		if e.complexity.Tender.Attachements == nil {
			break
		}

		return e.complexity.Tender.Attachements(childComplexity), true

	case "Tender.code":
		if e.complexity.Tender.Code == nil {
			break
		}

		return e.complexity.Tender.Code(childComplexity), true

	case "Tender.competitivePartnershipRating":
		if e.complexity.Tender.CompetitivePartnershipRating == nil {
			break
		}

		return e.complexity.Tender.CompetitivePartnershipRating(childComplexity), true

	case "Tender.createdAt":
		if e.complexity.Tender.CreatedAt == nil {
			break
		}

		return e.complexity.Tender.CreatedAt(childComplexity), true

	case "Tender.creditAndPaymentRating":
		if e.complexity.Tender.CreditAndPaymentRating == nil {
			break
		}

		return e.complexity.Tender.CreditAndPaymentRating(childComplexity), true

	case "Tender.customer":
		if e.complexity.Tender.Customer == nil {
			break
		}

		return e.complexity.Tender.Customer(childComplexity), true

	case "Tender.customerID":
		if e.complexity.Tender.CustomerID == nil {
			break
		}

		return e.complexity.Tender.CustomerID(childComplexity), true

	case "Tender.customerRelationshipRating":
		if e.complexity.Tender.CustomerRelationshipRating == nil {
			break
		}

		return e.complexity.Tender.CustomerRelationshipRating(childComplexity), true

	case "Tender.estimatedAmount":
		if e.complexity.Tender.EstimatedAmount == nil {
			break
		}

		return e.complexity.Tender.EstimatedAmount(childComplexity), true

	case "Tender.estimatedProjectEndDate":
		if e.complexity.Tender.EstimatedProjectEndDate == nil {
			break
		}

		return e.complexity.Tender.EstimatedProjectEndDate(childComplexity), true

	case "Tender.estimatedProjectStartDate":
		if e.complexity.Tender.EstimatedProjectStartDate == nil {
			break
		}

		return e.complexity.Tender.EstimatedProjectStartDate(childComplexity), true

	case "Tender.findDate":
		if e.complexity.Tender.FindDate == nil {
			break
		}

		return e.complexity.Tender.FindDate(childComplexity), true

	case "Tender.geoLocation":
		if e.complexity.Tender.GeoLocation == nil {
			break
		}

		return e.complexity.Tender.GeoLocation(childComplexity), true

	case "Tender.id":
		if e.complexity.Tender.ID == nil {
			break
		}

		return e.complexity.Tender.ID(childComplexity), true

	case "Tender.images":
		if e.complexity.Tender.Images == nil {
			break
		}

		return e.complexity.Tender.Images(childComplexity), true

	case "Tender.name":
		if e.complexity.Tender.Name == nil {
			break
		}

		return e.complexity.Tender.Name(childComplexity), true

	case "Tender.prepareToBid":
		if e.complexity.Tender.PrepareToBid == nil {
			break
		}

		return e.complexity.Tender.PrepareToBid(childComplexity), true

	case "Tender.projectCode":
		if e.complexity.Tender.ProjectCode == nil {
			break
		}

		return e.complexity.Tender.ProjectCode(childComplexity), true

	case "Tender.projectDefinition":
		if e.complexity.Tender.ProjectDefinition == nil {
			break
		}

		return e.complexity.Tender.ProjectDefinition(childComplexity), true

	case "Tender.projectType":
		if e.complexity.Tender.ProjectType == nil {
			break
		}

		return e.complexity.Tender.ProjectType(childComplexity), true

	case "Tender.remark":
		if e.complexity.Tender.Remark == nil {
			break
		}

		return e.complexity.Tender.Remark(childComplexity), true

	case "Tender.sizeAndValueRating":
		if e.complexity.Tender.SizeAndValueRating == nil {
			break
		}

		return e.complexity.Tender.SizeAndValueRating(childComplexity), true

	case "Tender.status":
		if e.complexity.Tender.Status == nil {
			break
		}

		return e.complexity.Tender.Status(childComplexity), true

	case "Tender.tenderDate":
		if e.complexity.Tender.TenderDate == nil {
			break
		}

		return e.complexity.Tender.TenderDate(childComplexity), true

	case "Tender.timeLimitRating":
		if e.complexity.Tender.TimeLimitRating == nil {
			break
		}

		return e.complexity.Tender.TimeLimitRating(childComplexity), true

	case "Tender.updatedAt":
		if e.complexity.Tender.UpdatedAt == nil {
			break
		}

		return e.complexity.Tender.UpdatedAt(childComplexity), true

	case "TenderConnection.edges":
		if e.complexity.TenderConnection.Edges == nil {
			break
		}

		return e.complexity.TenderConnection.Edges(childComplexity), true

	case "TenderConnection.pageInfo":
		if e.complexity.TenderConnection.PageInfo == nil {
			break
		}

		return e.complexity.TenderConnection.PageInfo(childComplexity), true

	case "TenderConnection.totalCount":
		if e.complexity.TenderConnection.TotalCount == nil {
			break
		}

		return e.complexity.TenderConnection.TotalCount(childComplexity), true

	case "TenderEdge.cursor":
		if e.complexity.TenderEdge.Cursor == nil {
			break
		}

		return e.complexity.TenderEdge.Cursor(childComplexity), true

	case "TenderEdge.node":
		if e.complexity.TenderEdge.Node == nil {
			break
		}

		return e.complexity.TenderEdge.Node(childComplexity), true

	case "User.areas":
		if e.complexity.User.Areas == nil {
			break
		}

		return e.complexity.User.Areas(childComplexity), true

	case "User.avatarURL":
		if e.complexity.User.AvatarURL == nil {
			break
		}

		return e.complexity.User.AvatarURL(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.customers":
		if e.complexity.User.Customers == nil {
			break
		}

		return e.complexity.User.Customers(childComplexity), true

	case "User.disabled":
		if e.complexity.User.Disabled == nil {
			break
		}

		return e.complexity.User.Disabled(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.leader":
		if e.complexity.User.Leader == nil {
			break
		}

		return e.complexity.User.Leader(childComplexity), true

	case "User.leaderID":
		if e.complexity.User.LeaderID == nil {
			break
		}

		return e.complexity.User.LeaderID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.openID":
		if e.complexity.User.OpenID == nil {
			break
		}

		return e.complexity.User.OpenID(childComplexity), true

	case "User.teamMembers":
		if e.complexity.User.TeamMembers == nil {
			break
		}

		return e.complexity.User.TeamMembers(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserConnection.edges":
		if e.complexity.UserConnection.Edges == nil {
			break
		}

		return e.complexity.UserConnection.Edges(childComplexity), true

	case "UserConnection.pageInfo":
		if e.complexity.UserConnection.PageInfo == nil {
			break
		}

		return e.complexity.UserConnection.PageInfo(childComplexity), true

	case "UserConnection.totalCount":
		if e.complexity.UserConnection.TotalCount == nil {
			break
		}

		return e.complexity.UserConnection.TotalCount(childComplexity), true

	case "UserEdge.cursor":
		if e.complexity.UserEdge.Cursor == nil {
			break
		}

		return e.complexity.UserEdge.Cursor(childComplexity), true

	case "UserEdge.node":
		if e.complexity.UserEdge.Node == nil {
			break
		}

		return e.complexity.UserEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAreaWhereInput,
		ec.unmarshalInputCityWhereInput,
		ec.unmarshalInputCountryWhereInput,
		ec.unmarshalInputCreateAreaInput,
		ec.unmarshalInputCreateCityInput,
		ec.unmarshalInputCreateCountryInput,
		ec.unmarshalInputCreateCustomerInput,
		ec.unmarshalInputCreateDistrictInput,
		ec.unmarshalInputCreateProvinceInput,
		ec.unmarshalInputCreateTenderInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputCustomerWhereInput,
		ec.unmarshalInputDistrictWhereInput,
		ec.unmarshalInputProvinceWhereInput,
		ec.unmarshalInputTenderWhereInput,
		ec.unmarshalInputUpdateAreaInput,
		ec.unmarshalInputUpdateCityInput,
		ec.unmarshalInputUpdateCountryInput,
		ec.unmarshalInputUpdateCustomerInput,
		ec.unmarshalInputUpdateDistrictInput,
		ec.unmarshalInputUpdateProvinceInput,
		ec.unmarshalInputUpdateTenderInput,
		ec.unmarshalInputUpdateUserInput,
		ec.unmarshalInputUserWhereInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type Area implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  code: String!
  customers: [Customer!]
  tenders: [Tender!]
  sales: [User!]
}
"""
A connection to a list of items.
"""
type AreaConnection {
  """
  A list of edges.
  """
  edges: [AreaEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type AreaEdge {
  """
  The item at the end of the edge.
  """
  node: Area
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
AreaWhereInput is used for filtering Area objects.
Input was generated by ent.
"""
input AreaWhereInput {
  not: AreaWhereInput
  and: [AreaWhereInput!]
  or: [AreaWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  code field predicates
  """
  code: String
  codeNEQ: String
  codeIn: [String!]
  codeNotIn: [String!]
  codeGT: String
  codeGTE: String
  codeLT: String
  codeLTE: String
  codeContains: String
  codeHasPrefix: String
  codeHasSuffix: String
  codeEqualFold: String
  codeContainsFold: String
  """
  customers edge predicates
  """
  hasCustomers: Boolean
  hasCustomersWith: [CustomerWhereInput!]
  """
  tenders edge predicates
  """
  hasTenders: Boolean
  hasTendersWith: [TenderWhereInput!]
  """
  sales edge predicates
  """
  hasSales: Boolean
  hasSalesWith: [UserWhereInput!]
}
type City implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  adcode: Int!
  provCode: Int!
  name: String!
  provinceID: ID!
  districts: [District!]
  province: Province!
}
"""
A connection to a list of items.
"""
type CityConnection {
  """
  A list of edges.
  """
  edges: [CityEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type CityEdge {
  """
  The item at the end of the edge.
  """
  node: City
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
CityWhereInput is used for filtering City objects.
Input was generated by ent.
"""
input CityWhereInput {
  not: CityWhereInput
  and: [CityWhereInput!]
  or: [CityWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  adcode field predicates
  """
  adcode: Int
  adcodeNEQ: Int
  adcodeIn: [Int!]
  adcodeNotIn: [Int!]
  adcodeGT: Int
  adcodeGTE: Int
  adcodeLT: Int
  adcodeLTE: Int
  """
  prov_code field predicates
  """
  provCode: Int
  provCodeNEQ: Int
  provCodeIn: [Int!]
  provCodeNotIn: [Int!]
  provCodeGT: Int
  provCodeGTE: Int
  provCodeLT: Int
  provCodeLTE: Int
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  province_id field predicates
  """
  provinceID: ID
  provinceIDNEQ: ID
  provinceIDIn: [ID!]
  provinceIDNotIn: [ID!]
  provinceIDGT: ID
  provinceIDGTE: ID
  provinceIDLT: ID
  provinceIDLTE: ID
  """
  districts edge predicates
  """
  hasDistricts: Boolean
  hasDistrictsWith: [DistrictWhereInput!]
  """
  province edge predicates
  """
  hasProvince: Boolean
  hasProvinceWith: [ProvinceWhereInput!]
}
type Country implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  adcode: Int!
  name: String!
  provinces: [Province!]
}
"""
A connection to a list of items.
"""
type CountryConnection {
  """
  A list of edges.
  """
  edges: [CountryEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type CountryEdge {
  """
  The item at the end of the edge.
  """
  node: Country
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
CountryWhereInput is used for filtering Country objects.
Input was generated by ent.
"""
input CountryWhereInput {
  not: CountryWhereInput
  and: [CountryWhereInput!]
  or: [CountryWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  adcode field predicates
  """
  adcode: Int
  adcodeNEQ: Int
  adcodeIn: [Int!]
  adcodeNotIn: [Int!]
  adcodeGT: Int
  adcodeGTE: Int
  adcodeLT: Int
  adcodeLTE: Int
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  provinces edge predicates
  """
  hasProvinces: Boolean
  hasProvincesWith: [ProvinceWhereInput!]
}
"""
CreateAreaInput is used for create Area object.
Input was generated by ent.
"""
input CreateAreaInput {
  createdAt: Time
  updatedAt: Time
  name: String!
  code: String!
  customerIDs: [ID!]
  tenderIDs: [ID!]
  saleIDs: [ID!]
}
"""
CreateCityInput is used for create City object.
Input was generated by ent.
"""
input CreateCityInput {
  createdAt: Time
  updatedAt: Time
  adcode: Int!
  provCode: Int!
  name: String!
  districtIDs: [ID!]
  provinceID: ID!
}
"""
CreateCountryInput is used for create Country object.
Input was generated by ent.
"""
input CreateCountryInput {
  createdAt: Time
  updatedAt: Time
  adcode: Int!
  name: String!
  provinceIDs: [ID!]
}
"""
CreateCustomerInput is used for create Customer object.
Input was generated by ent.
"""
input CreateCustomerInput {
  createdAt: Time
  updatedAt: Time
  name: String!
  ownerType: Int
  industry: Int!
  size: Int
  contactPerson: String
  contactPersonPosition: String
  contactPersonPhone: String
  contactPersonEmail: String
  areaID: ID!
  tenderIDs: [ID!]
  salesID: ID
  createdByID: ID!
}
"""
CreateDistrictInput is used for create District object.
Input was generated by ent.
"""
input CreateDistrictInput {
  createdAt: Time
  updatedAt: Time
  adcode: Int!
  provCode: Int!
  cityCode: Int!
  name: String!
  provinceID: ID!
  cityID: ID
}
"""
CreateProvinceInput is used for create Province object.
Input was generated by ent.
"""
input CreateProvinceInput {
  createdAt: Time
  updatedAt: Time
  adcode: Int!
  name: String!
  districtIDs: [ID!]
  cityIDs: [ID!]
  countryID: ID!
}
"""
CreateTenderInput is used for create Tender object.
Input was generated by ent.
"""
input CreateTenderInput {
  createdAt: Time
  updatedAt: Time
  code: String!
  status: Int
  name: String!
  estimatedAmount: Float
  tenderDate: Time
  findDate: Time!
  sizeAndValueRating: Int
  creditAndPaymentRating: Int
  timeLimitRating: Int
  customerRelationshipRating: Int
  competitivePartnershipRating: Int
  prepareToBid: Boolean
  projectCode: String
  projectDefinition: String
  estimatedProjectStartDate: Time
  estimatedProjectEndDate: Time
  projectType: String
  attachements: [String!]
  geoLocation: String
  remark: String
  images: [String!]
  areaID: ID!
  customerID: ID!
}
"""
CreateUserInput is used for create User object.
Input was generated by ent.
"""
input CreateUserInput {
  createdAt: Time
  updatedAt: Time
  name: String!
  email: String!
  username: String!
  openID: String!
  avatarURL: String!
  disabled: Boolean
  areaIDs: [ID!]
  customerIDs: [ID!]
  leaderID: ID
  teamMemberIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Customer implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  ownerType: Int
  industry: Int!
  size: Int
  contactPerson: String
  contactPersonPosition: String
  contactPersonPhone: String
  contactPersonEmail: String
  areaID: ID!
  salesID: ID
  createdByUserID: ID!
  area: Area!
  tenders: [Tender!]
  sales: User
  createdBy: User!
}
"""
A connection to a list of items.
"""
type CustomerConnection {
  """
  A list of edges.
  """
  edges: [CustomerEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type CustomerEdge {
  """
  The item at the end of the edge.
  """
  node: Customer
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
CustomerWhereInput is used for filtering Customer objects.
Input was generated by ent.
"""
input CustomerWhereInput {
  not: CustomerWhereInput
  and: [CustomerWhereInput!]
  or: [CustomerWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  owner_type field predicates
  """
  ownerType: Int
  ownerTypeNEQ: Int
  ownerTypeIn: [Int!]
  ownerTypeNotIn: [Int!]
  ownerTypeGT: Int
  ownerTypeGTE: Int
  ownerTypeLT: Int
  ownerTypeLTE: Int
  ownerTypeIsNil: Boolean
  ownerTypeNotNil: Boolean
  """
  industry field predicates
  """
  industry: Int
  industryNEQ: Int
  industryIn: [Int!]
  industryNotIn: [Int!]
  industryGT: Int
  industryGTE: Int
  industryLT: Int
  industryLTE: Int
  """
  size field predicates
  """
  size: Int
  sizeNEQ: Int
  sizeIn: [Int!]
  sizeNotIn: [Int!]
  sizeGT: Int
  sizeGTE: Int
  sizeLT: Int
  sizeLTE: Int
  sizeIsNil: Boolean
  sizeNotNil: Boolean
  """
  contact_person field predicates
  """
  contactPerson: String
  contactPersonNEQ: String
  contactPersonIn: [String!]
  contactPersonNotIn: [String!]
  contactPersonGT: String
  contactPersonGTE: String
  contactPersonLT: String
  contactPersonLTE: String
  contactPersonContains: String
  contactPersonHasPrefix: String
  contactPersonHasSuffix: String
  contactPersonIsNil: Boolean
  contactPersonNotNil: Boolean
  contactPersonEqualFold: String
  contactPersonContainsFold: String
  """
  contact_person_position field predicates
  """
  contactPersonPosition: String
  contactPersonPositionNEQ: String
  contactPersonPositionIn: [String!]
  contactPersonPositionNotIn: [String!]
  contactPersonPositionGT: String
  contactPersonPositionGTE: String
  contactPersonPositionLT: String
  contactPersonPositionLTE: String
  contactPersonPositionContains: String
  contactPersonPositionHasPrefix: String
  contactPersonPositionHasSuffix: String
  contactPersonPositionIsNil: Boolean
  contactPersonPositionNotNil: Boolean
  contactPersonPositionEqualFold: String
  contactPersonPositionContainsFold: String
  """
  contact_person_phone field predicates
  """
  contactPersonPhone: String
  contactPersonPhoneNEQ: String
  contactPersonPhoneIn: [String!]
  contactPersonPhoneNotIn: [String!]
  contactPersonPhoneGT: String
  contactPersonPhoneGTE: String
  contactPersonPhoneLT: String
  contactPersonPhoneLTE: String
  contactPersonPhoneContains: String
  contactPersonPhoneHasPrefix: String
  contactPersonPhoneHasSuffix: String
  contactPersonPhoneIsNil: Boolean
  contactPersonPhoneNotNil: Boolean
  contactPersonPhoneEqualFold: String
  contactPersonPhoneContainsFold: String
  """
  contact_person_email field predicates
  """
  contactPersonEmail: String
  contactPersonEmailNEQ: String
  contactPersonEmailIn: [String!]
  contactPersonEmailNotIn: [String!]
  contactPersonEmailGT: String
  contactPersonEmailGTE: String
  contactPersonEmailLT: String
  contactPersonEmailLTE: String
  contactPersonEmailContains: String
  contactPersonEmailHasPrefix: String
  contactPersonEmailHasSuffix: String
  contactPersonEmailIsNil: Boolean
  contactPersonEmailNotNil: Boolean
  contactPersonEmailEqualFold: String
  contactPersonEmailContainsFold: String
  """
  area_id field predicates
  """
  areaID: ID
  areaIDNEQ: ID
  areaIDIn: [ID!]
  areaIDNotIn: [ID!]
  areaIDGT: ID
  areaIDGTE: ID
  areaIDLT: ID
  areaIDLTE: ID
  """
  sales_id field predicates
  """
  salesID: ID
  salesIDNEQ: ID
  salesIDIn: [ID!]
  salesIDNotIn: [ID!]
  salesIDGT: ID
  salesIDGTE: ID
  salesIDLT: ID
  salesIDLTE: ID
  salesIDIsNil: Boolean
  salesIDNotNil: Boolean
  """
  created_by_user_id field predicates
  """
  createdByUserID: ID
  createdByUserIDNEQ: ID
  createdByUserIDIn: [ID!]
  createdByUserIDNotIn: [ID!]
  createdByUserIDGT: ID
  createdByUserIDGTE: ID
  createdByUserIDLT: ID
  createdByUserIDLTE: ID
  """
  area edge predicates
  """
  hasArea: Boolean
  hasAreaWith: [AreaWhereInput!]
  """
  tenders edge predicates
  """
  hasTenders: Boolean
  hasTendersWith: [TenderWhereInput!]
  """
  sales edge predicates
  """
  hasSales: Boolean
  hasSalesWith: [UserWhereInput!]
  """
  created_by edge predicates
  """
  hasCreatedBy: Boolean
  hasCreatedByWith: [UserWhereInput!]
}
type District implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  adcode: Int!
  provCode: Int!
  cityCode: Int!
  name: String!
  provinceID: ID!
  cityID: ID
  province: Province!
  city: City
}
"""
A connection to a list of items.
"""
type DistrictConnection {
  """
  A list of edges.
  """
  edges: [DistrictEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type DistrictEdge {
  """
  The item at the end of the edge.
  """
  node: District
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
DistrictWhereInput is used for filtering District objects.
Input was generated by ent.
"""
input DistrictWhereInput {
  not: DistrictWhereInput
  and: [DistrictWhereInput!]
  or: [DistrictWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  adcode field predicates
  """
  adcode: Int
  adcodeNEQ: Int
  adcodeIn: [Int!]
  adcodeNotIn: [Int!]
  adcodeGT: Int
  adcodeGTE: Int
  adcodeLT: Int
  adcodeLTE: Int
  """
  prov_code field predicates
  """
  provCode: Int
  provCodeNEQ: Int
  provCodeIn: [Int!]
  provCodeNotIn: [Int!]
  provCodeGT: Int
  provCodeGTE: Int
  provCodeLT: Int
  provCodeLTE: Int
  """
  city_code field predicates
  """
  cityCode: Int
  cityCodeNEQ: Int
  cityCodeIn: [Int!]
  cityCodeNotIn: [Int!]
  cityCodeGT: Int
  cityCodeGTE: Int
  cityCodeLT: Int
  cityCodeLTE: Int
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  province_id field predicates
  """
  provinceID: ID
  provinceIDNEQ: ID
  provinceIDIn: [ID!]
  provinceIDNotIn: [ID!]
  provinceIDGT: ID
  provinceIDGTE: ID
  provinceIDLT: ID
  provinceIDLTE: ID
  """
  city_id field predicates
  """
  cityID: ID
  cityIDNEQ: ID
  cityIDIn: [ID!]
  cityIDNotIn: [ID!]
  cityIDGT: ID
  cityIDGTE: ID
  cityIDLT: ID
  cityIDLTE: ID
  cityIDIsNil: Boolean
  cityIDNotNil: Boolean
  """
  province edge predicates
  """
  hasProvince: Boolean
  hasProvinceWith: [ProvinceWhereInput!]
  """
  city edge predicates
  """
  hasCity: Boolean
  hasCityWith: [CityWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "cscd-bds/store/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Province implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  adcode: Int!
  name: String!
  countryID: ID!
  districts: [District!]
  cities: [City!]
  country: Country!
}
"""
A connection to a list of items.
"""
type ProvinceConnection {
  """
  A list of edges.
  """
  edges: [ProvinceEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ProvinceEdge {
  """
  The item at the end of the edge.
  """
  node: Province
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
ProvinceWhereInput is used for filtering Province objects.
Input was generated by ent.
"""
input ProvinceWhereInput {
  not: ProvinceWhereInput
  and: [ProvinceWhereInput!]
  or: [ProvinceWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  adcode field predicates
  """
  adcode: Int
  adcodeNEQ: Int
  adcodeIn: [Int!]
  adcodeNotIn: [Int!]
  adcodeGT: Int
  adcodeGTE: Int
  adcodeLT: Int
  adcodeLTE: Int
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  country_id field predicates
  """
  countryID: ID
  countryIDNEQ: ID
  countryIDIn: [ID!]
  countryIDNotIn: [ID!]
  countryIDGT: ID
  countryIDGTE: ID
  countryIDLT: ID
  countryIDLTE: ID
  """
  districts edge predicates
  """
  hasDistricts: Boolean
  hasDistrictsWith: [DistrictWhereInput!]
  """
  cities edge predicates
  """
  hasCities: Boolean
  hasCitiesWith: [CityWhereInput!]
  """
  country edge predicates
  """
  hasCountry: Boolean
  hasCountryWith: [CountryWhereInput!]
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  areas(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Areas returned from the connection.
    """
    where: AreaWhereInput
  ): AreaConnection!
  cities(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Cities returned from the connection.
    """
    where: CityWhereInput
  ): CityConnection!
  countries(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Countries returned from the connection.
    """
    where: CountryWhereInput
  ): CountryConnection!
  customers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Customers returned from the connection.
    """
    where: CustomerWhereInput
  ): CustomerConnection!
  districts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Districts returned from the connection.
    """
    where: DistrictWhereInput
  ): DistrictConnection!
  provinces(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Provinces returned from the connection.
    """
    where: ProvinceWhereInput
  ): ProvinceConnection!
  tenders(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Tenders returned from the connection.
    """
    where: TenderWhereInput
  ): TenderConnection!
  users(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for Users returned from the connection.
    """
    where: UserWhereInput
  ): UserConnection!
}
type Tender implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  code: String!
  status: Int!
  name: String!
  estimatedAmount: Float
  tenderDate: Time
  findDate: Time!
  sizeAndValueRating: Int
  creditAndPaymentRating: Int
  timeLimitRating: Int
  customerRelationshipRating: Int
  competitivePartnershipRating: Int
  prepareToBid: Boolean!
  projectCode: String
  projectDefinition: String
  estimatedProjectStartDate: Time
  estimatedProjectEndDate: Time
  projectType: String
  attachements: [String!]
  geoLocation: String
  remark: String
  images: [String!]
  areaID: ID!
  customerID: ID!
  area: Area!
  customer: Customer!
}
"""
A connection to a list of items.
"""
type TenderConnection {
  """
  A list of edges.
  """
  edges: [TenderEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type TenderEdge {
  """
  The item at the end of the edge.
  """
  node: Tender
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
TenderWhereInput is used for filtering Tender objects.
Input was generated by ent.
"""
input TenderWhereInput {
  not: TenderWhereInput
  and: [TenderWhereInput!]
  or: [TenderWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  code field predicates
  """
  code: String
  codeNEQ: String
  codeIn: [String!]
  codeNotIn: [String!]
  codeGT: String
  codeGTE: String
  codeLT: String
  codeLTE: String
  codeContains: String
  codeHasPrefix: String
  codeHasSuffix: String
  codeEqualFold: String
  codeContainsFold: String
  """
  status field predicates
  """
  status: Int
  statusNEQ: Int
  statusIn: [Int!]
  statusNotIn: [Int!]
  statusGT: Int
  statusGTE: Int
  statusLT: Int
  statusLTE: Int
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  estimated_amount field predicates
  """
  estimatedAmount: Float
  estimatedAmountNEQ: Float
  estimatedAmountIn: [Float!]
  estimatedAmountNotIn: [Float!]
  estimatedAmountGT: Float
  estimatedAmountGTE: Float
  estimatedAmountLT: Float
  estimatedAmountLTE: Float
  estimatedAmountIsNil: Boolean
  estimatedAmountNotNil: Boolean
  """
  tender_date field predicates
  """
  tenderDate: Time
  tenderDateNEQ: Time
  tenderDateIn: [Time!]
  tenderDateNotIn: [Time!]
  tenderDateGT: Time
  tenderDateGTE: Time
  tenderDateLT: Time
  tenderDateLTE: Time
  tenderDateIsNil: Boolean
  tenderDateNotNil: Boolean
  """
  find_date field predicates
  """
  findDate: Time
  findDateNEQ: Time
  findDateIn: [Time!]
  findDateNotIn: [Time!]
  findDateGT: Time
  findDateGTE: Time
  findDateLT: Time
  findDateLTE: Time
  """
  size_and_value_rating field predicates
  """
  sizeAndValueRating: Int
  sizeAndValueRatingNEQ: Int
  sizeAndValueRatingIn: [Int!]
  sizeAndValueRatingNotIn: [Int!]
  sizeAndValueRatingGT: Int
  sizeAndValueRatingGTE: Int
  sizeAndValueRatingLT: Int
  sizeAndValueRatingLTE: Int
  sizeAndValueRatingIsNil: Boolean
  sizeAndValueRatingNotNil: Boolean
  """
  credit_and_payment_rating field predicates
  """
  creditAndPaymentRating: Int
  creditAndPaymentRatingNEQ: Int
  creditAndPaymentRatingIn: [Int!]
  creditAndPaymentRatingNotIn: [Int!]
  creditAndPaymentRatingGT: Int
  creditAndPaymentRatingGTE: Int
  creditAndPaymentRatingLT: Int
  creditAndPaymentRatingLTE: Int
  creditAndPaymentRatingIsNil: Boolean
  creditAndPaymentRatingNotNil: Boolean
  """
  time_limit_rating field predicates
  """
  timeLimitRating: Int
  timeLimitRatingNEQ: Int
  timeLimitRatingIn: [Int!]
  timeLimitRatingNotIn: [Int!]
  timeLimitRatingGT: Int
  timeLimitRatingGTE: Int
  timeLimitRatingLT: Int
  timeLimitRatingLTE: Int
  timeLimitRatingIsNil: Boolean
  timeLimitRatingNotNil: Boolean
  """
  customer_relationship_rating field predicates
  """
  customerRelationshipRating: Int
  customerRelationshipRatingNEQ: Int
  customerRelationshipRatingIn: [Int!]
  customerRelationshipRatingNotIn: [Int!]
  customerRelationshipRatingGT: Int
  customerRelationshipRatingGTE: Int
  customerRelationshipRatingLT: Int
  customerRelationshipRatingLTE: Int
  customerRelationshipRatingIsNil: Boolean
  customerRelationshipRatingNotNil: Boolean
  """
  competitive_partnership_rating field predicates
  """
  competitivePartnershipRating: Int
  competitivePartnershipRatingNEQ: Int
  competitivePartnershipRatingIn: [Int!]
  competitivePartnershipRatingNotIn: [Int!]
  competitivePartnershipRatingGT: Int
  competitivePartnershipRatingGTE: Int
  competitivePartnershipRatingLT: Int
  competitivePartnershipRatingLTE: Int
  competitivePartnershipRatingIsNil: Boolean
  competitivePartnershipRatingNotNil: Boolean
  """
  prepare_to_bid field predicates
  """
  prepareToBid: Boolean
  prepareToBidNEQ: Boolean
  """
  project_code field predicates
  """
  projectCode: String
  projectCodeNEQ: String
  projectCodeIn: [String!]
  projectCodeNotIn: [String!]
  projectCodeGT: String
  projectCodeGTE: String
  projectCodeLT: String
  projectCodeLTE: String
  projectCodeContains: String
  projectCodeHasPrefix: String
  projectCodeHasSuffix: String
  projectCodeIsNil: Boolean
  projectCodeNotNil: Boolean
  projectCodeEqualFold: String
  projectCodeContainsFold: String
  """
  project_definition field predicates
  """
  projectDefinition: String
  projectDefinitionNEQ: String
  projectDefinitionIn: [String!]
  projectDefinitionNotIn: [String!]
  projectDefinitionGT: String
  projectDefinitionGTE: String
  projectDefinitionLT: String
  projectDefinitionLTE: String
  projectDefinitionContains: String
  projectDefinitionHasPrefix: String
  projectDefinitionHasSuffix: String
  projectDefinitionIsNil: Boolean
  projectDefinitionNotNil: Boolean
  projectDefinitionEqualFold: String
  projectDefinitionContainsFold: String
  """
  estimated_project_start_date field predicates
  """
  estimatedProjectStartDate: Time
  estimatedProjectStartDateNEQ: Time
  estimatedProjectStartDateIn: [Time!]
  estimatedProjectStartDateNotIn: [Time!]
  estimatedProjectStartDateGT: Time
  estimatedProjectStartDateGTE: Time
  estimatedProjectStartDateLT: Time
  estimatedProjectStartDateLTE: Time
  estimatedProjectStartDateIsNil: Boolean
  estimatedProjectStartDateNotNil: Boolean
  """
  estimated_project_end_date field predicates
  """
  estimatedProjectEndDate: Time
  estimatedProjectEndDateNEQ: Time
  estimatedProjectEndDateIn: [Time!]
  estimatedProjectEndDateNotIn: [Time!]
  estimatedProjectEndDateGT: Time
  estimatedProjectEndDateGTE: Time
  estimatedProjectEndDateLT: Time
  estimatedProjectEndDateLTE: Time
  estimatedProjectEndDateIsNil: Boolean
  estimatedProjectEndDateNotNil: Boolean
  """
  project_type field predicates
  """
  projectType: String
  projectTypeNEQ: String
  projectTypeIn: [String!]
  projectTypeNotIn: [String!]
  projectTypeGT: String
  projectTypeGTE: String
  projectTypeLT: String
  projectTypeLTE: String
  projectTypeContains: String
  projectTypeHasPrefix: String
  projectTypeHasSuffix: String
  projectTypeIsNil: Boolean
  projectTypeNotNil: Boolean
  projectTypeEqualFold: String
  projectTypeContainsFold: String
  """
  geo_location field predicates
  """
  geoLocation: String
  geoLocationNEQ: String
  geoLocationIn: [String!]
  geoLocationNotIn: [String!]
  geoLocationGT: String
  geoLocationGTE: String
  geoLocationLT: String
  geoLocationLTE: String
  geoLocationContains: String
  geoLocationHasPrefix: String
  geoLocationHasSuffix: String
  geoLocationIsNil: Boolean
  geoLocationNotNil: Boolean
  geoLocationEqualFold: String
  geoLocationContainsFold: String
  """
  remark field predicates
  """
  remark: String
  remarkNEQ: String
  remarkIn: [String!]
  remarkNotIn: [String!]
  remarkGT: String
  remarkGTE: String
  remarkLT: String
  remarkLTE: String
  remarkContains: String
  remarkHasPrefix: String
  remarkHasSuffix: String
  remarkIsNil: Boolean
  remarkNotNil: Boolean
  remarkEqualFold: String
  remarkContainsFold: String
  """
  area_id field predicates
  """
  areaID: ID
  areaIDNEQ: ID
  areaIDIn: [ID!]
  areaIDNotIn: [ID!]
  areaIDGT: ID
  areaIDGTE: ID
  areaIDLT: ID
  areaIDLTE: ID
  """
  customer_id field predicates
  """
  customerID: ID
  customerIDNEQ: ID
  customerIDIn: [ID!]
  customerIDNotIn: [ID!]
  customerIDGT: ID
  customerIDGTE: ID
  customerIDLT: ID
  customerIDLTE: ID
  """
  area edge predicates
  """
  hasArea: Boolean
  hasAreaWith: [AreaWhereInput!]
  """
  customer edge predicates
  """
  hasCustomer: Boolean
  hasCustomerWith: [CustomerWhereInput!]
}
"""
UpdateAreaInput is used for update Area object.
Input was generated by ent.
"""
input UpdateAreaInput {
  updatedAt: Time
  name: String
  code: String
  addCustomerIDs: [ID!]
  removeCustomerIDs: [ID!]
  clearCustomers: Boolean
  addTenderIDs: [ID!]
  removeTenderIDs: [ID!]
  clearTenders: Boolean
  addSaleIDs: [ID!]
  removeSaleIDs: [ID!]
  clearSales: Boolean
}
"""
UpdateCityInput is used for update City object.
Input was generated by ent.
"""
input UpdateCityInput {
  updatedAt: Time
  adcode: Int
  provCode: Int
  name: String
  addDistrictIDs: [ID!]
  removeDistrictIDs: [ID!]
  clearDistricts: Boolean
  provinceID: ID
}
"""
UpdateCountryInput is used for update Country object.
Input was generated by ent.
"""
input UpdateCountryInput {
  updatedAt: Time
  adcode: Int
  name: String
  addProvinceIDs: [ID!]
  removeProvinceIDs: [ID!]
  clearProvinces: Boolean
}
"""
UpdateCustomerInput is used for update Customer object.
Input was generated by ent.
"""
input UpdateCustomerInput {
  updatedAt: Time
  name: String
  ownerType: Int
  clearOwnerType: Boolean
  industry: Int
  size: Int
  clearSize: Boolean
  contactPerson: String
  clearContactPerson: Boolean
  contactPersonPosition: String
  clearContactPersonPosition: Boolean
  contactPersonPhone: String
  clearContactPersonPhone: Boolean
  contactPersonEmail: String
  clearContactPersonEmail: Boolean
  areaID: ID
  addTenderIDs: [ID!]
  removeTenderIDs: [ID!]
  clearTenders: Boolean
  salesID: ID
  clearSales: Boolean
  createdByID: ID
}
"""
UpdateDistrictInput is used for update District object.
Input was generated by ent.
"""
input UpdateDistrictInput {
  updatedAt: Time
  adcode: Int
  provCode: Int
  cityCode: Int
  name: String
  provinceID: ID
  cityID: ID
  clearCity: Boolean
}
"""
UpdateProvinceInput is used for update Province object.
Input was generated by ent.
"""
input UpdateProvinceInput {
  updatedAt: Time
  adcode: Int
  name: String
  addDistrictIDs: [ID!]
  removeDistrictIDs: [ID!]
  clearDistricts: Boolean
  addCityIDs: [ID!]
  removeCityIDs: [ID!]
  clearCities: Boolean
  countryID: ID
}
"""
UpdateTenderInput is used for update Tender object.
Input was generated by ent.
"""
input UpdateTenderInput {
  updatedAt: Time
  code: String
  status: Int
  name: String
  estimatedAmount: Float
  clearEstimatedAmount: Boolean
  tenderDate: Time
  clearTenderDate: Boolean
  findDate: Time
  sizeAndValueRating: Int
  clearSizeAndValueRating: Boolean
  creditAndPaymentRating: Int
  clearCreditAndPaymentRating: Boolean
  timeLimitRating: Int
  clearTimeLimitRating: Boolean
  customerRelationshipRating: Int
  clearCustomerRelationshipRating: Boolean
  competitivePartnershipRating: Int
  clearCompetitivePartnershipRating: Boolean
  prepareToBid: Boolean
  projectCode: String
  clearProjectCode: Boolean
  projectDefinition: String
  clearProjectDefinition: Boolean
  estimatedProjectStartDate: Time
  clearEstimatedProjectStartDate: Boolean
  estimatedProjectEndDate: Time
  clearEstimatedProjectEndDate: Boolean
  projectType: String
  clearProjectType: Boolean
  attachements: [String!]
  appendAttachements: [String!]
  clearAttachements: Boolean
  geoLocation: String
  clearGeoLocation: Boolean
  remark: String
  clearRemark: Boolean
  images: [String!]
  appendImages: [String!]
  clearImages: Boolean
  areaID: ID
  customerID: ID
}
"""
UpdateUserInput is used for update User object.
Input was generated by ent.
"""
input UpdateUserInput {
  updatedAt: Time
  name: String
  email: String
  username: String
  openID: String
  avatarURL: String
  disabled: Boolean
  addAreaIDs: [ID!]
  removeAreaIDs: [ID!]
  clearAreas: Boolean
  addCustomerIDs: [ID!]
  removeCustomerIDs: [ID!]
  clearCustomers: Boolean
  leaderID: ID
  clearLeader: Boolean
  addTeamMemberIDs: [ID!]
  removeTeamMemberIDs: [ID!]
  clearTeamMembers: Boolean
}
type User implements Node {
  id: ID!
  createdAt: Time!
  updatedAt: Time!
  name: String!
  email: String!
  username: String!
  openID: String!
  avatarURL: String!
  disabled: Boolean!
  leaderID: ID
  areas: [Area!]
  customers: [Customer!]
  leader: User
  teamMembers: [User!]
}
"""
A connection to a list of items.
"""
type UserConnection {
  """
  A list of edges.
  """
  edges: [UserEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type UserEdge {
  """
  The item at the end of the edge.
  """
  node: User
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
UserWhereInput is used for filtering User objects.
Input was generated by ent.
"""
input UserWhereInput {
  not: UserWhereInput
  and: [UserWhereInput!]
  or: [UserWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  email field predicates
  """
  email: String
  emailNEQ: String
  emailIn: [String!]
  emailNotIn: [String!]
  emailGT: String
  emailGTE: String
  emailLT: String
  emailLTE: String
  emailContains: String
  emailHasPrefix: String
  emailHasSuffix: String
  emailEqualFold: String
  emailContainsFold: String
  """
  username field predicates
  """
  username: String
  usernameNEQ: String
  usernameIn: [String!]
  usernameNotIn: [String!]
  usernameGT: String
  usernameGTE: String
  usernameLT: String
  usernameLTE: String
  usernameContains: String
  usernameHasPrefix: String
  usernameHasSuffix: String
  usernameEqualFold: String
  usernameContainsFold: String
  """
  open_id field predicates
  """
  openID: String
  openIDNEQ: String
  openIDIn: [String!]
  openIDNotIn: [String!]
  openIDGT: String
  openIDGTE: String
  openIDLT: String
  openIDLTE: String
  openIDContains: String
  openIDHasPrefix: String
  openIDHasSuffix: String
  openIDEqualFold: String
  openIDContainsFold: String
  """
  avatar_url field predicates
  """
  avatarURL: String
  avatarURLNEQ: String
  avatarURLIn: [String!]
  avatarURLNotIn: [String!]
  avatarURLGT: String
  avatarURLGTE: String
  avatarURLLT: String
  avatarURLLTE: String
  avatarURLContains: String
  avatarURLHasPrefix: String
  avatarURLHasSuffix: String
  avatarURLEqualFold: String
  avatarURLContainsFold: String
  """
  disabled field predicates
  """
  disabled: Boolean
  disabledNEQ: Boolean
  """
  leader_id field predicates
  """
  leaderID: ID
  leaderIDNEQ: ID
  leaderIDIn: [ID!]
  leaderIDNotIn: [ID!]
  leaderIDGT: ID
  leaderIDGTE: ID
  leaderIDLT: ID
  leaderIDLTE: ID
  leaderIDIsNil: Boolean
  leaderIDNotNil: Boolean
  """
  areas edge predicates
  """
  hasAreas: Boolean
  hasAreasWith: [AreaWhereInput!]
  """
  customers edge predicates
  """
  hasCustomers: Boolean
  hasCustomersWith: [CustomerWhereInput!]
  """
  leader edge predicates
  """
  hasLeader: Boolean
  hasLeaderWith: [UserWhereInput!]
  """
  team_members edge predicates
  """
  hasTeamMembers: Boolean
  hasTeamMembersWith: [UserWhereInput!]
}
`, BuiltIn: false},
	{Name: "../scalar.graphql", Input: `scalar Time
`, BuiltIn: false},
	{Name: "../session.graphql", Input: `type Session {
  name: String!
  username: String!
  email: String!
  avatarUrl: String!
}

extend type Query {
  session: Session!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
