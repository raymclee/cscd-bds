// Code generated by ent, DO NOT EDIT.

package ent

import (
	"cscd-bds/store/ent/project"
	"cscd-bds/store/ent/schema/xid"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Project is the model entity for the Project schema.
type Project struct {
	config `json:"-"`
	// ID of the ent.
	ID xid.ID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Code holds the value of the "code" field.
	Code string `json:"code,omitempty"`
	// 地盤經理
	Manager *string `json:"manager,omitempty"`
	// Name holds the value of the "name" field.
	Name *string `json:"name,omitempty"`
	// 客戶
	Owner *string `json:"owner,omitempty"`
	// 建築師
	Jzs *string `json:"jzs,omitempty"`
	// 總承包商
	Mcn *string `json:"mcn,omitempty"`
	// 幕墻顧問
	Consultant *string `json:"consultant,omitempty"`
	// 工程規模
	Areas *string `json:"areas,omitempty"`
	// 開工日期
	StartDate *time.Time `json:"start_date,omitempty"`
	// 封頂日期
	FsDate *time.Time `json:"fs_date,omitempty"`
	// 開始安裝日期
	OpDate *time.Time `json:"op_date,omitempty"`
	// 竣工日期
	EndDate *time.Time `json:"end_date,omitempty"`
	// 維修保養期
	Mntyr *string `json:"mntyr,omitempty"`
	// 中標形式
	ConType *string `json:"con_type,omitempty"`
	// 是否完成
	IsFinished bool `json:"is_finished,omitempty"`
	// 成交额
	Cje *float64 `json:"cje,omitempty"`
	// 营业额
	Yye *float64 `json:"yye,omitempty"`
	// 现金流
	Xjl *float64 `json:"xjl,omitempty"`
	// 项目管理费预算
	XmglfYs *float64 `json:"xmglf_ys,omitempty"`
	// 项目管理费累计
	XmglfLj *float64 `json:"xmglf_lj,omitempty"`
	// 项目设计费
	Xmsjf *float64 `json:"xmsjf,omitempty"`
	// 项目负责人
	Xmfzr *string `json:"xmfzr,omitempty"`
	// 业主申请总额
	OwnerApplyAmount *float64 `json:"owner_apply_amount,omitempty"`
	// 业主申请数量
	OwnerApplyCount *int `json:"owner_apply_count,omitempty"`
	// 业主批复总额
	OwnerApproveAmount *float64 `json:"owner_approve_amount,omitempty"`
	// 业主批复数量
	OwnerApproveCount *int `json:"owner_approve_count,omitempty"`
	// 总包申请总额
	ContractorApplyAmount *float64 `json:"contractor_apply_amount,omitempty"`
	// 总包申请数量
	ContractorApplyCount *int `json:"contractor_apply_count,omitempty"`
	// 总包批复总额
	ContractorApproveAmount *float64 `json:"contractor_approve_amount,omitempty"`
	// 总包批复数量
	ContractorApproveCount *int `json:"contractor_approve_count,omitempty"`
	// 安装进度
	InstallProgress *float64 `json:"install_progress,omitempty"`
	// 有效合同金额
	EffectiveContractAmount *float64 `json:"effective_contract_amount,omitempty"`
	// 分判VA申请总额
	VaApplyAmount *float64 `json:"va_apply_amount,omitempty"`
	// 分判VA批复总额
	VaApproveAmount *float64 `json:"va_approve_amount,omitempty"`
	// 累计法定扣款
	AccumulatedStatutoryDeductions *float64 `json:"accumulated_statutory_deductions,omitempty"`
	// 累计非法定扣款
	AccumulatedNonStatutoryDeductions *float64 `json:"accumulated_non_statutory_deductions,omitempty"`
	// 本期法定扣款
	AccumulatedStatutoryDeductionsPeriod *float64 `json:"accumulated_statutory_deductions_period,omitempty"`
	// 本期非法定扣款
	AccumulatedNonStatutoryDeductionsPeriod *float64 `json:"accumulated_non_statutory_deductions_period,omitempty"`
	// 合約总额
	TotalContractAmount *float64 `json:"total_contract_amount,omitempty"`
	// 鋁板預算百分比
	AluminumPlateBudgetPercentage *float64 `json:"aluminum_plate_budget_percentage,omitempty"`
	// 鋁型材預算百分比
	AluminumBudgetPercentage *float64 `json:"aluminum_budget_percentage,omitempty"`
	// 玻璃預算百分比
	GlassBudgetPercentage *float64 `json:"glass_budget_percentage,omitempty"`
	// 鐵型材預算百分比
	IronBudgetPercentage *float64 `json:"iron_budget_percentage,omitempty"`
	// 里程碑計劃年份
	MilestonePlanYear *int `json:"milestone_plan_year,omitempty"`
	// 里程碑計劃月份
	MilestonePlanMonth *int `json:"milestone_plan_month,omitempty"`
	// 里程碑完成年份
	MilestoneDoneYear *int `json:"milestone_done_year,omitempty"`
	// 里程碑完成月份
	MilestoneDoneMonth *int `json:"milestone_done_month,omitempty"`
	// 生产管理面积
	PmArea *float64 `json:"pm_area,omitempty"`
	// 生产管理當年累計生產
	PmYearTarget *float64 `json:"pm_year_target,omitempty"`
	// 生产管理當月累計生產
	PmMonthTarget *float64 `json:"pm_month_target,omitempty"`
	// 生产管理當年實際生產
	PmYearActual *float64 `json:"pm_year_actual,omitempty"`
	// 生产管理當月實際生產
	PmMonthActual *float64 `json:"pm_month_actual,omitempty"`
	// 生产管理累計生產
	PmTotal *float64 `json:"pm_total,omitempty"`
	// 生产管理昨日生產
	PmYesterday *float64 `json:"pm_yesterday,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ProjectQuery when eager-loading is set.
	Edges        ProjectEdges `json:"edges"`
	selectValues sql.SelectValues
}

// ProjectEdges holds the relations/edges for other nodes in the graph.
type ProjectEdges struct {
	// Vos holds the value of the vos edge.
	Vos []*ProjectVO `json:"vos,omitempty"`
	// ProjectStaffs holds the value of the project_staffs edge.
	ProjectStaffs []*ProjectStaff `json:"project_staffs,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
	// totalCount holds the count of the edges above.
	totalCount [2]map[string]int

	namedVos           map[string][]*ProjectVO
	namedProjectStaffs map[string][]*ProjectStaff
}

// VosOrErr returns the Vos value or an error if the edge
// was not loaded in eager-loading.
func (e ProjectEdges) VosOrErr() ([]*ProjectVO, error) {
	if e.loadedTypes[0] {
		return e.Vos, nil
	}
	return nil, &NotLoadedError{edge: "vos"}
}

// ProjectStaffsOrErr returns the ProjectStaffs value or an error if the edge
// was not loaded in eager-loading.
func (e ProjectEdges) ProjectStaffsOrErr() ([]*ProjectStaff, error) {
	if e.loadedTypes[1] {
		return e.ProjectStaffs, nil
	}
	return nil, &NotLoadedError{edge: "project_staffs"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Project) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case project.FieldIsFinished:
			values[i] = new(sql.NullBool)
		case project.FieldCje, project.FieldYye, project.FieldXjl, project.FieldXmglfYs, project.FieldXmglfLj, project.FieldXmsjf, project.FieldOwnerApplyAmount, project.FieldOwnerApproveAmount, project.FieldContractorApplyAmount, project.FieldContractorApproveAmount, project.FieldInstallProgress, project.FieldEffectiveContractAmount, project.FieldVaApplyAmount, project.FieldVaApproveAmount, project.FieldAccumulatedStatutoryDeductions, project.FieldAccumulatedNonStatutoryDeductions, project.FieldAccumulatedStatutoryDeductionsPeriod, project.FieldAccumulatedNonStatutoryDeductionsPeriod, project.FieldTotalContractAmount, project.FieldAluminumPlateBudgetPercentage, project.FieldAluminumBudgetPercentage, project.FieldGlassBudgetPercentage, project.FieldIronBudgetPercentage, project.FieldPmArea, project.FieldPmYearTarget, project.FieldPmMonthTarget, project.FieldPmYearActual, project.FieldPmMonthActual, project.FieldPmTotal, project.FieldPmYesterday:
			values[i] = new(sql.NullFloat64)
		case project.FieldOwnerApplyCount, project.FieldOwnerApproveCount, project.FieldContractorApplyCount, project.FieldContractorApproveCount, project.FieldMilestonePlanYear, project.FieldMilestonePlanMonth, project.FieldMilestoneDoneYear, project.FieldMilestoneDoneMonth:
			values[i] = new(sql.NullInt64)
		case project.FieldCode, project.FieldManager, project.FieldName, project.FieldOwner, project.FieldJzs, project.FieldMcn, project.FieldConsultant, project.FieldAreas, project.FieldMntyr, project.FieldConType, project.FieldXmfzr:
			values[i] = new(sql.NullString)
		case project.FieldCreatedAt, project.FieldUpdatedAt, project.FieldStartDate, project.FieldFsDate, project.FieldOpDate, project.FieldEndDate:
			values[i] = new(sql.NullTime)
		case project.FieldID:
			values[i] = new(xid.ID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Project fields.
func (pr *Project) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case project.FieldID:
			if value, ok := values[i].(*xid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				pr.ID = *value
			}
		case project.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				pr.CreatedAt = value.Time
			}
		case project.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				pr.UpdatedAt = value.Time
			}
		case project.FieldCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code", values[i])
			} else if value.Valid {
				pr.Code = value.String
			}
		case project.FieldManager:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field manager", values[i])
			} else if value.Valid {
				pr.Manager = new(string)
				*pr.Manager = value.String
			}
		case project.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				pr.Name = new(string)
				*pr.Name = value.String
			}
		case project.FieldOwner:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field owner", values[i])
			} else if value.Valid {
				pr.Owner = new(string)
				*pr.Owner = value.String
			}
		case project.FieldJzs:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field jzs", values[i])
			} else if value.Valid {
				pr.Jzs = new(string)
				*pr.Jzs = value.String
			}
		case project.FieldMcn:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mcn", values[i])
			} else if value.Valid {
				pr.Mcn = new(string)
				*pr.Mcn = value.String
			}
		case project.FieldConsultant:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field consultant", values[i])
			} else if value.Valid {
				pr.Consultant = new(string)
				*pr.Consultant = value.String
			}
		case project.FieldAreas:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field areas", values[i])
			} else if value.Valid {
				pr.Areas = new(string)
				*pr.Areas = value.String
			}
		case project.FieldStartDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field start_date", values[i])
			} else if value.Valid {
				pr.StartDate = new(time.Time)
				*pr.StartDate = value.Time
			}
		case project.FieldFsDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field fs_date", values[i])
			} else if value.Valid {
				pr.FsDate = new(time.Time)
				*pr.FsDate = value.Time
			}
		case project.FieldOpDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field op_date", values[i])
			} else if value.Valid {
				pr.OpDate = new(time.Time)
				*pr.OpDate = value.Time
			}
		case project.FieldEndDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field end_date", values[i])
			} else if value.Valid {
				pr.EndDate = new(time.Time)
				*pr.EndDate = value.Time
			}
		case project.FieldMntyr:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mntyr", values[i])
			} else if value.Valid {
				pr.Mntyr = new(string)
				*pr.Mntyr = value.String
			}
		case project.FieldConType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field con_type", values[i])
			} else if value.Valid {
				pr.ConType = new(string)
				*pr.ConType = value.String
			}
		case project.FieldIsFinished:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_finished", values[i])
			} else if value.Valid {
				pr.IsFinished = value.Bool
			}
		case project.FieldCje:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field cje", values[i])
			} else if value.Valid {
				pr.Cje = new(float64)
				*pr.Cje = value.Float64
			}
		case project.FieldYye:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field yye", values[i])
			} else if value.Valid {
				pr.Yye = new(float64)
				*pr.Yye = value.Float64
			}
		case project.FieldXjl:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field xjl", values[i])
			} else if value.Valid {
				pr.Xjl = new(float64)
				*pr.Xjl = value.Float64
			}
		case project.FieldXmglfYs:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field xmglf_ys", values[i])
			} else if value.Valid {
				pr.XmglfYs = new(float64)
				*pr.XmglfYs = value.Float64
			}
		case project.FieldXmglfLj:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field xmglf_lj", values[i])
			} else if value.Valid {
				pr.XmglfLj = new(float64)
				*pr.XmglfLj = value.Float64
			}
		case project.FieldXmsjf:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field xmsjf", values[i])
			} else if value.Valid {
				pr.Xmsjf = new(float64)
				*pr.Xmsjf = value.Float64
			}
		case project.FieldXmfzr:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field xmfzr", values[i])
			} else if value.Valid {
				pr.Xmfzr = new(string)
				*pr.Xmfzr = value.String
			}
		case project.FieldOwnerApplyAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field owner_apply_amount", values[i])
			} else if value.Valid {
				pr.OwnerApplyAmount = new(float64)
				*pr.OwnerApplyAmount = value.Float64
			}
		case project.FieldOwnerApplyCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field owner_apply_count", values[i])
			} else if value.Valid {
				pr.OwnerApplyCount = new(int)
				*pr.OwnerApplyCount = int(value.Int64)
			}
		case project.FieldOwnerApproveAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field owner_approve_amount", values[i])
			} else if value.Valid {
				pr.OwnerApproveAmount = new(float64)
				*pr.OwnerApproveAmount = value.Float64
			}
		case project.FieldOwnerApproveCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field owner_approve_count", values[i])
			} else if value.Valid {
				pr.OwnerApproveCount = new(int)
				*pr.OwnerApproveCount = int(value.Int64)
			}
		case project.FieldContractorApplyAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field contractor_apply_amount", values[i])
			} else if value.Valid {
				pr.ContractorApplyAmount = new(float64)
				*pr.ContractorApplyAmount = value.Float64
			}
		case project.FieldContractorApplyCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field contractor_apply_count", values[i])
			} else if value.Valid {
				pr.ContractorApplyCount = new(int)
				*pr.ContractorApplyCount = int(value.Int64)
			}
		case project.FieldContractorApproveAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field contractor_approve_amount", values[i])
			} else if value.Valid {
				pr.ContractorApproveAmount = new(float64)
				*pr.ContractorApproveAmount = value.Float64
			}
		case project.FieldContractorApproveCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field contractor_approve_count", values[i])
			} else if value.Valid {
				pr.ContractorApproveCount = new(int)
				*pr.ContractorApproveCount = int(value.Int64)
			}
		case project.FieldInstallProgress:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field install_progress", values[i])
			} else if value.Valid {
				pr.InstallProgress = new(float64)
				*pr.InstallProgress = value.Float64
			}
		case project.FieldEffectiveContractAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field effective_contract_amount", values[i])
			} else if value.Valid {
				pr.EffectiveContractAmount = new(float64)
				*pr.EffectiveContractAmount = value.Float64
			}
		case project.FieldVaApplyAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field va_apply_amount", values[i])
			} else if value.Valid {
				pr.VaApplyAmount = new(float64)
				*pr.VaApplyAmount = value.Float64
			}
		case project.FieldVaApproveAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field va_approve_amount", values[i])
			} else if value.Valid {
				pr.VaApproveAmount = new(float64)
				*pr.VaApproveAmount = value.Float64
			}
		case project.FieldAccumulatedStatutoryDeductions:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field accumulated_statutory_deductions", values[i])
			} else if value.Valid {
				pr.AccumulatedStatutoryDeductions = new(float64)
				*pr.AccumulatedStatutoryDeductions = value.Float64
			}
		case project.FieldAccumulatedNonStatutoryDeductions:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field accumulated_non_statutory_deductions", values[i])
			} else if value.Valid {
				pr.AccumulatedNonStatutoryDeductions = new(float64)
				*pr.AccumulatedNonStatutoryDeductions = value.Float64
			}
		case project.FieldAccumulatedStatutoryDeductionsPeriod:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field accumulated_statutory_deductions_period", values[i])
			} else if value.Valid {
				pr.AccumulatedStatutoryDeductionsPeriod = new(float64)
				*pr.AccumulatedStatutoryDeductionsPeriod = value.Float64
			}
		case project.FieldAccumulatedNonStatutoryDeductionsPeriod:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field accumulated_non_statutory_deductions_period", values[i])
			} else if value.Valid {
				pr.AccumulatedNonStatutoryDeductionsPeriod = new(float64)
				*pr.AccumulatedNonStatutoryDeductionsPeriod = value.Float64
			}
		case project.FieldTotalContractAmount:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field total_contract_amount", values[i])
			} else if value.Valid {
				pr.TotalContractAmount = new(float64)
				*pr.TotalContractAmount = value.Float64
			}
		case project.FieldAluminumPlateBudgetPercentage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field aluminum_plate_budget_percentage", values[i])
			} else if value.Valid {
				pr.AluminumPlateBudgetPercentage = new(float64)
				*pr.AluminumPlateBudgetPercentage = value.Float64
			}
		case project.FieldAluminumBudgetPercentage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field aluminum_budget_percentage", values[i])
			} else if value.Valid {
				pr.AluminumBudgetPercentage = new(float64)
				*pr.AluminumBudgetPercentage = value.Float64
			}
		case project.FieldGlassBudgetPercentage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field glass_budget_percentage", values[i])
			} else if value.Valid {
				pr.GlassBudgetPercentage = new(float64)
				*pr.GlassBudgetPercentage = value.Float64
			}
		case project.FieldIronBudgetPercentage:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field iron_budget_percentage", values[i])
			} else if value.Valid {
				pr.IronBudgetPercentage = new(float64)
				*pr.IronBudgetPercentage = value.Float64
			}
		case project.FieldMilestonePlanYear:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field milestone_plan_year", values[i])
			} else if value.Valid {
				pr.MilestonePlanYear = new(int)
				*pr.MilestonePlanYear = int(value.Int64)
			}
		case project.FieldMilestonePlanMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field milestone_plan_month", values[i])
			} else if value.Valid {
				pr.MilestonePlanMonth = new(int)
				*pr.MilestonePlanMonth = int(value.Int64)
			}
		case project.FieldMilestoneDoneYear:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field milestone_done_year", values[i])
			} else if value.Valid {
				pr.MilestoneDoneYear = new(int)
				*pr.MilestoneDoneYear = int(value.Int64)
			}
		case project.FieldMilestoneDoneMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field milestone_done_month", values[i])
			} else if value.Valid {
				pr.MilestoneDoneMonth = new(int)
				*pr.MilestoneDoneMonth = int(value.Int64)
			}
		case project.FieldPmArea:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_area", values[i])
			} else if value.Valid {
				pr.PmArea = new(float64)
				*pr.PmArea = value.Float64
			}
		case project.FieldPmYearTarget:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_year_target", values[i])
			} else if value.Valid {
				pr.PmYearTarget = new(float64)
				*pr.PmYearTarget = value.Float64
			}
		case project.FieldPmMonthTarget:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_month_target", values[i])
			} else if value.Valid {
				pr.PmMonthTarget = new(float64)
				*pr.PmMonthTarget = value.Float64
			}
		case project.FieldPmYearActual:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_year_actual", values[i])
			} else if value.Valid {
				pr.PmYearActual = new(float64)
				*pr.PmYearActual = value.Float64
			}
		case project.FieldPmMonthActual:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_month_actual", values[i])
			} else if value.Valid {
				pr.PmMonthActual = new(float64)
				*pr.PmMonthActual = value.Float64
			}
		case project.FieldPmTotal:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_total", values[i])
			} else if value.Valid {
				pr.PmTotal = new(float64)
				*pr.PmTotal = value.Float64
			}
		case project.FieldPmYesterday:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pm_yesterday", values[i])
			} else if value.Valid {
				pr.PmYesterday = new(float64)
				*pr.PmYesterday = value.Float64
			}
		default:
			pr.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Project.
// This includes values selected through modifiers, order, etc.
func (pr *Project) Value(name string) (ent.Value, error) {
	return pr.selectValues.Get(name)
}

// QueryVos queries the "vos" edge of the Project entity.
func (pr *Project) QueryVos() *ProjectVOQuery {
	return NewProjectClient(pr.config).QueryVos(pr)
}

// QueryProjectStaffs queries the "project_staffs" edge of the Project entity.
func (pr *Project) QueryProjectStaffs() *ProjectStaffQuery {
	return NewProjectClient(pr.config).QueryProjectStaffs(pr)
}

// Update returns a builder for updating this Project.
// Note that you need to call Project.Unwrap() before calling this method if this Project
// was returned from a transaction, and the transaction was committed or rolled back.
func (pr *Project) Update() *ProjectUpdateOne {
	return NewProjectClient(pr.config).UpdateOne(pr)
}

// Unwrap unwraps the Project entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pr *Project) Unwrap() *Project {
	_tx, ok := pr.config.driver.(*txDriver)
	if !ok {
		panic("ent: Project is not a transactional entity")
	}
	pr.config.driver = _tx.drv
	return pr
}

// String implements the fmt.Stringer.
func (pr *Project) String() string {
	var builder strings.Builder
	builder.WriteString("Project(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pr.ID))
	builder.WriteString("created_at=")
	builder.WriteString(pr.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(pr.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("code=")
	builder.WriteString(pr.Code)
	builder.WriteString(", ")
	if v := pr.Manager; v != nil {
		builder.WriteString("manager=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Name; v != nil {
		builder.WriteString("name=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Owner; v != nil {
		builder.WriteString("owner=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Jzs; v != nil {
		builder.WriteString("jzs=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Mcn; v != nil {
		builder.WriteString("mcn=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Consultant; v != nil {
		builder.WriteString("consultant=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.Areas; v != nil {
		builder.WriteString("areas=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.StartDate; v != nil {
		builder.WriteString("start_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pr.FsDate; v != nil {
		builder.WriteString("fs_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pr.OpDate; v != nil {
		builder.WriteString("op_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pr.EndDate; v != nil {
		builder.WriteString("end_date=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := pr.Mntyr; v != nil {
		builder.WriteString("mntyr=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.ConType; v != nil {
		builder.WriteString("con_type=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("is_finished=")
	builder.WriteString(fmt.Sprintf("%v", pr.IsFinished))
	builder.WriteString(", ")
	if v := pr.Cje; v != nil {
		builder.WriteString("cje=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.Yye; v != nil {
		builder.WriteString("yye=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.Xjl; v != nil {
		builder.WriteString("xjl=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.XmglfYs; v != nil {
		builder.WriteString("xmglf_ys=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.XmglfLj; v != nil {
		builder.WriteString("xmglf_lj=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.Xmsjf; v != nil {
		builder.WriteString("xmsjf=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.Xmfzr; v != nil {
		builder.WriteString("xmfzr=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := pr.OwnerApplyAmount; v != nil {
		builder.WriteString("owner_apply_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.OwnerApplyCount; v != nil {
		builder.WriteString("owner_apply_count=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.OwnerApproveAmount; v != nil {
		builder.WriteString("owner_approve_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.OwnerApproveCount; v != nil {
		builder.WriteString("owner_approve_count=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.ContractorApplyAmount; v != nil {
		builder.WriteString("contractor_apply_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.ContractorApplyCount; v != nil {
		builder.WriteString("contractor_apply_count=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.ContractorApproveAmount; v != nil {
		builder.WriteString("contractor_approve_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.ContractorApproveCount; v != nil {
		builder.WriteString("contractor_approve_count=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.InstallProgress; v != nil {
		builder.WriteString("install_progress=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.EffectiveContractAmount; v != nil {
		builder.WriteString("effective_contract_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.VaApplyAmount; v != nil {
		builder.WriteString("va_apply_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.VaApproveAmount; v != nil {
		builder.WriteString("va_approve_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AccumulatedStatutoryDeductions; v != nil {
		builder.WriteString("accumulated_statutory_deductions=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AccumulatedNonStatutoryDeductions; v != nil {
		builder.WriteString("accumulated_non_statutory_deductions=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AccumulatedStatutoryDeductionsPeriod; v != nil {
		builder.WriteString("accumulated_statutory_deductions_period=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AccumulatedNonStatutoryDeductionsPeriod; v != nil {
		builder.WriteString("accumulated_non_statutory_deductions_period=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.TotalContractAmount; v != nil {
		builder.WriteString("total_contract_amount=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AluminumPlateBudgetPercentage; v != nil {
		builder.WriteString("aluminum_plate_budget_percentage=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.AluminumBudgetPercentage; v != nil {
		builder.WriteString("aluminum_budget_percentage=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.GlassBudgetPercentage; v != nil {
		builder.WriteString("glass_budget_percentage=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.IronBudgetPercentage; v != nil {
		builder.WriteString("iron_budget_percentage=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.MilestonePlanYear; v != nil {
		builder.WriteString("milestone_plan_year=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.MilestonePlanMonth; v != nil {
		builder.WriteString("milestone_plan_month=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.MilestoneDoneYear; v != nil {
		builder.WriteString("milestone_done_year=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.MilestoneDoneMonth; v != nil {
		builder.WriteString("milestone_done_month=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmArea; v != nil {
		builder.WriteString("pm_area=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmYearTarget; v != nil {
		builder.WriteString("pm_year_target=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmMonthTarget; v != nil {
		builder.WriteString("pm_month_target=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmYearActual; v != nil {
		builder.WriteString("pm_year_actual=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmMonthActual; v != nil {
		builder.WriteString("pm_month_actual=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmTotal; v != nil {
		builder.WriteString("pm_total=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := pr.PmYesterday; v != nil {
		builder.WriteString("pm_yesterday=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteByte(')')
	return builder.String()
}

// NamedVos returns the Vos named value or an error if the edge was not
// loaded in eager-loading with this name.
func (pr *Project) NamedVos(name string) ([]*ProjectVO, error) {
	if pr.Edges.namedVos == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := pr.Edges.namedVos[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (pr *Project) appendNamedVos(name string, edges ...*ProjectVO) {
	if pr.Edges.namedVos == nil {
		pr.Edges.namedVos = make(map[string][]*ProjectVO)
	}
	if len(edges) == 0 {
		pr.Edges.namedVos[name] = []*ProjectVO{}
	} else {
		pr.Edges.namedVos[name] = append(pr.Edges.namedVos[name], edges...)
	}
}

// NamedProjectStaffs returns the ProjectStaffs named value or an error if the edge was not
// loaded in eager-loading with this name.
func (pr *Project) NamedProjectStaffs(name string) ([]*ProjectStaff, error) {
	if pr.Edges.namedProjectStaffs == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := pr.Edges.namedProjectStaffs[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (pr *Project) appendNamedProjectStaffs(name string, edges ...*ProjectStaff) {
	if pr.Edges.namedProjectStaffs == nil {
		pr.Edges.namedProjectStaffs = make(map[string][]*ProjectStaff)
	}
	if len(edges) == 0 {
		pr.Edges.namedProjectStaffs[name] = []*ProjectStaff{}
	} else {
		pr.Edges.namedProjectStaffs[name] = append(pr.Edges.namedProjectStaffs[name], edges...)
	}
}

// Projects is a parsable slice of Project.
type Projects []*Project
