// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"cscd-bds/store/ent/migrate"
	"cscd-bds/store/ent/schema/xid"

	"cscd-bds/store/ent/area"
	"cscd-bds/store/ent/city"
	"cscd-bds/store/ent/competitor"
	"cscd-bds/store/ent/country"
	"cscd-bds/store/ent/customer"
	"cscd-bds/store/ent/customerprofile"
	"cscd-bds/store/ent/district"
	"cscd-bds/store/ent/operation"
	"cscd-bds/store/ent/plot"
	"cscd-bds/store/ent/potentialtender"
	"cscd-bds/store/ent/project"
	"cscd-bds/store/ent/province"
	"cscd-bds/store/ent/tender"
	"cscd-bds/store/ent/tendercompetitor"
	"cscd-bds/store/ent/tenderprofile"
	"cscd-bds/store/ent/user"
	"cscd-bds/store/ent/visitrecord"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Area is the client for interacting with the Area builders.
	Area *AreaClient
	// City is the client for interacting with the City builders.
	City *CityClient
	// Competitor is the client for interacting with the Competitor builders.
	Competitor *CompetitorClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Customer is the client for interacting with the Customer builders.
	Customer *CustomerClient
	// CustomerProfile is the client for interacting with the CustomerProfile builders.
	CustomerProfile *CustomerProfileClient
	// District is the client for interacting with the District builders.
	District *DistrictClient
	// Operation is the client for interacting with the Operation builders.
	Operation *OperationClient
	// Plot is the client for interacting with the Plot builders.
	Plot *PlotClient
	// PotentialTender is the client for interacting with the PotentialTender builders.
	PotentialTender *PotentialTenderClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// Province is the client for interacting with the Province builders.
	Province *ProvinceClient
	// Tender is the client for interacting with the Tender builders.
	Tender *TenderClient
	// TenderCompetitor is the client for interacting with the TenderCompetitor builders.
	TenderCompetitor *TenderCompetitorClient
	// TenderProfile is the client for interacting with the TenderProfile builders.
	TenderProfile *TenderProfileClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// VisitRecord is the client for interacting with the VisitRecord builders.
	VisitRecord *VisitRecordClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Area = NewAreaClient(c.config)
	c.City = NewCityClient(c.config)
	c.Competitor = NewCompetitorClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Customer = NewCustomerClient(c.config)
	c.CustomerProfile = NewCustomerProfileClient(c.config)
	c.District = NewDistrictClient(c.config)
	c.Operation = NewOperationClient(c.config)
	c.Plot = NewPlotClient(c.config)
	c.PotentialTender = NewPotentialTenderClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.Province = NewProvinceClient(c.config)
	c.Tender = NewTenderClient(c.config)
	c.TenderCompetitor = NewTenderCompetitorClient(c.config)
	c.TenderProfile = NewTenderProfileClient(c.config)
	c.User = NewUserClient(c.config)
	c.VisitRecord = NewVisitRecordClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Area:             NewAreaClient(cfg),
		City:             NewCityClient(cfg),
		Competitor:       NewCompetitorClient(cfg),
		Country:          NewCountryClient(cfg),
		Customer:         NewCustomerClient(cfg),
		CustomerProfile:  NewCustomerProfileClient(cfg),
		District:         NewDistrictClient(cfg),
		Operation:        NewOperationClient(cfg),
		Plot:             NewPlotClient(cfg),
		PotentialTender:  NewPotentialTenderClient(cfg),
		Project:          NewProjectClient(cfg),
		Province:         NewProvinceClient(cfg),
		Tender:           NewTenderClient(cfg),
		TenderCompetitor: NewTenderCompetitorClient(cfg),
		TenderProfile:    NewTenderProfileClient(cfg),
		User:             NewUserClient(cfg),
		VisitRecord:      NewVisitRecordClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Area:             NewAreaClient(cfg),
		City:             NewCityClient(cfg),
		Competitor:       NewCompetitorClient(cfg),
		Country:          NewCountryClient(cfg),
		Customer:         NewCustomerClient(cfg),
		CustomerProfile:  NewCustomerProfileClient(cfg),
		District:         NewDistrictClient(cfg),
		Operation:        NewOperationClient(cfg),
		Plot:             NewPlotClient(cfg),
		PotentialTender:  NewPotentialTenderClient(cfg),
		Project:          NewProjectClient(cfg),
		Province:         NewProvinceClient(cfg),
		Tender:           NewTenderClient(cfg),
		TenderCompetitor: NewTenderCompetitorClient(cfg),
		TenderProfile:    NewTenderProfileClient(cfg),
		User:             NewUserClient(cfg),
		VisitRecord:      NewVisitRecordClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Area.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Area, c.City, c.Competitor, c.Country, c.Customer, c.CustomerProfile,
		c.District, c.Operation, c.Plot, c.PotentialTender, c.Project, c.Province,
		c.Tender, c.TenderCompetitor, c.TenderProfile, c.User, c.VisitRecord,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Area, c.City, c.Competitor, c.Country, c.Customer, c.CustomerProfile,
		c.District, c.Operation, c.Plot, c.PotentialTender, c.Project, c.Province,
		c.Tender, c.TenderCompetitor, c.TenderProfile, c.User, c.VisitRecord,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AreaMutation:
		return c.Area.mutate(ctx, m)
	case *CityMutation:
		return c.City.mutate(ctx, m)
	case *CompetitorMutation:
		return c.Competitor.mutate(ctx, m)
	case *CountryMutation:
		return c.Country.mutate(ctx, m)
	case *CustomerMutation:
		return c.Customer.mutate(ctx, m)
	case *CustomerProfileMutation:
		return c.CustomerProfile.mutate(ctx, m)
	case *DistrictMutation:
		return c.District.mutate(ctx, m)
	case *OperationMutation:
		return c.Operation.mutate(ctx, m)
	case *PlotMutation:
		return c.Plot.mutate(ctx, m)
	case *PotentialTenderMutation:
		return c.PotentialTender.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProvinceMutation:
		return c.Province.mutate(ctx, m)
	case *TenderMutation:
		return c.Tender.mutate(ctx, m)
	case *TenderCompetitorMutation:
		return c.TenderCompetitor.mutate(ctx, m)
	case *TenderProfileMutation:
		return c.TenderProfile.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *VisitRecordMutation:
		return c.VisitRecord.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AreaClient is a client for the Area schema.
type AreaClient struct {
	config
}

// NewAreaClient returns a client for the Area from the given config.
func NewAreaClient(c config) *AreaClient {
	return &AreaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `area.Hooks(f(g(h())))`.
func (c *AreaClient) Use(hooks ...Hook) {
	c.hooks.Area = append(c.hooks.Area, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `area.Intercept(f(g(h())))`.
func (c *AreaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Area = append(c.inters.Area, interceptors...)
}

// Create returns a builder for creating a Area entity.
func (c *AreaClient) Create() *AreaCreate {
	mutation := newAreaMutation(c.config, OpCreate)
	return &AreaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Area entities.
func (c *AreaClient) CreateBulk(builders ...*AreaCreate) *AreaCreateBulk {
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AreaClient) MapCreateBulk(slice any, setFunc func(*AreaCreate, int)) *AreaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AreaCreateBulk{err: fmt.Errorf("calling to AreaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AreaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AreaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Area.
func (c *AreaClient) Update() *AreaUpdate {
	mutation := newAreaMutation(c.config, OpUpdate)
	return &AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AreaClient) UpdateOne(a *Area) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withArea(a))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AreaClient) UpdateOneID(id xid.ID) *AreaUpdateOne {
	mutation := newAreaMutation(c.config, OpUpdateOne, withAreaID(id))
	return &AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Area.
func (c *AreaClient) Delete() *AreaDelete {
	mutation := newAreaMutation(c.config, OpDelete)
	return &AreaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AreaClient) DeleteOne(a *Area) *AreaDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AreaClient) DeleteOneID(id xid.ID) *AreaDeleteOne {
	builder := c.Delete().Where(area.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AreaDeleteOne{builder}
}

// Query returns a query builder for Area.
func (c *AreaClient) Query() *AreaQuery {
	return &AreaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeArea},
		inters: c.Interceptors(),
	}
}

// Get returns a Area entity by its id.
func (c *AreaClient) Get(ctx context.Context, id xid.ID) (*Area, error) {
	return c.Query().Where(area.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AreaClient) GetX(ctx context.Context, id xid.ID) *Area {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomers queries the customers edge of a Area.
func (c *AreaClient) QueryCustomers(a *Area) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, area.CustomersTable, area.CustomersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a Area.
func (c *AreaClient) QueryTenders(a *Area) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, area.TendersTable, area.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Area.
func (c *AreaClient) QueryUsers(a *Area) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, area.UsersTable, area.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvinces queries the provinces edge of a Area.
func (c *AreaClient) QueryProvinces(a *Area) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(area.Table, area.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, area.ProvincesTable, area.ProvincesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AreaClient) Hooks() []Hook {
	return c.hooks.Area
}

// Interceptors returns the client interceptors.
func (c *AreaClient) Interceptors() []Interceptor {
	return c.inters.Area
}

func (c *AreaClient) mutate(ctx context.Context, m *AreaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AreaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AreaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AreaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AreaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Area mutation op: %q", m.Op())
	}
}

// CityClient is a client for the City schema.
type CityClient struct {
	config
}

// NewCityClient returns a client for the City from the given config.
func NewCityClient(c config) *CityClient {
	return &CityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `city.Hooks(f(g(h())))`.
func (c *CityClient) Use(hooks ...Hook) {
	c.hooks.City = append(c.hooks.City, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `city.Intercept(f(g(h())))`.
func (c *CityClient) Intercept(interceptors ...Interceptor) {
	c.inters.City = append(c.inters.City, interceptors...)
}

// Create returns a builder for creating a City entity.
func (c *CityClient) Create() *CityCreate {
	mutation := newCityMutation(c.config, OpCreate)
	return &CityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of City entities.
func (c *CityClient) CreateBulk(builders ...*CityCreate) *CityCreateBulk {
	return &CityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CityClient) MapCreateBulk(slice any, setFunc func(*CityCreate, int)) *CityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CityCreateBulk{err: fmt.Errorf("calling to CityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for City.
func (c *CityClient) Update() *CityUpdate {
	mutation := newCityMutation(c.config, OpUpdate)
	return &CityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CityClient) UpdateOne(ci *City) *CityUpdateOne {
	mutation := newCityMutation(c.config, OpUpdateOne, withCity(ci))
	return &CityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CityClient) UpdateOneID(id xid.ID) *CityUpdateOne {
	mutation := newCityMutation(c.config, OpUpdateOne, withCityID(id))
	return &CityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for City.
func (c *CityClient) Delete() *CityDelete {
	mutation := newCityMutation(c.config, OpDelete)
	return &CityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CityClient) DeleteOne(ci *City) *CityDeleteOne {
	return c.DeleteOneID(ci.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CityClient) DeleteOneID(id xid.ID) *CityDeleteOne {
	builder := c.Delete().Where(city.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CityDeleteOne{builder}
}

// Query returns a query builder for City.
func (c *CityClient) Query() *CityQuery {
	return &CityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCity},
		inters: c.Interceptors(),
	}
}

// Get returns a City entity by its id.
func (c *CityClient) Get(ctx context.Context, id xid.ID) (*City, error) {
	return c.Query().Where(city.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CityClient) GetX(ctx context.Context, id xid.ID) *City {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDistricts queries the districts edge of a City.
func (c *CityClient) QueryDistricts(ci *City) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(city.Table, city.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, city.DistrictsTable, city.DistrictsColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvince queries the province edge of a City.
func (c *CityClient) QueryProvince(ci *City) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(city.Table, city.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, city.ProvinceTable, city.ProvinceColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a City.
func (c *CityClient) QueryTenders(ci *City) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ci.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(city.Table, city.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, city.TendersTable, city.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(ci.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CityClient) Hooks() []Hook {
	return c.hooks.City
}

// Interceptors returns the client interceptors.
func (c *CityClient) Interceptors() []Interceptor {
	return c.inters.City
}

func (c *CityClient) mutate(ctx context.Context, m *CityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown City mutation op: %q", m.Op())
	}
}

// CompetitorClient is a client for the Competitor schema.
type CompetitorClient struct {
	config
}

// NewCompetitorClient returns a client for the Competitor from the given config.
func NewCompetitorClient(c config) *CompetitorClient {
	return &CompetitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `competitor.Hooks(f(g(h())))`.
func (c *CompetitorClient) Use(hooks ...Hook) {
	c.hooks.Competitor = append(c.hooks.Competitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `competitor.Intercept(f(g(h())))`.
func (c *CompetitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.Competitor = append(c.inters.Competitor, interceptors...)
}

// Create returns a builder for creating a Competitor entity.
func (c *CompetitorClient) Create() *CompetitorCreate {
	mutation := newCompetitorMutation(c.config, OpCreate)
	return &CompetitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Competitor entities.
func (c *CompetitorClient) CreateBulk(builders ...*CompetitorCreate) *CompetitorCreateBulk {
	return &CompetitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompetitorClient) MapCreateBulk(slice any, setFunc func(*CompetitorCreate, int)) *CompetitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompetitorCreateBulk{err: fmt.Errorf("calling to CompetitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompetitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompetitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Competitor.
func (c *CompetitorClient) Update() *CompetitorUpdate {
	mutation := newCompetitorMutation(c.config, OpUpdate)
	return &CompetitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompetitorClient) UpdateOne(co *Competitor) *CompetitorUpdateOne {
	mutation := newCompetitorMutation(c.config, OpUpdateOne, withCompetitor(co))
	return &CompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompetitorClient) UpdateOneID(id xid.ID) *CompetitorUpdateOne {
	mutation := newCompetitorMutation(c.config, OpUpdateOne, withCompetitorID(id))
	return &CompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Competitor.
func (c *CompetitorClient) Delete() *CompetitorDelete {
	mutation := newCompetitorMutation(c.config, OpDelete)
	return &CompetitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompetitorClient) DeleteOne(co *Competitor) *CompetitorDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompetitorClient) DeleteOneID(id xid.ID) *CompetitorDeleteOne {
	builder := c.Delete().Where(competitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompetitorDeleteOne{builder}
}

// Query returns a query builder for Competitor.
func (c *CompetitorClient) Query() *CompetitorQuery {
	return &CompetitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompetitor},
		inters: c.Interceptors(),
	}
}

// Get returns a Competitor entity by its id.
func (c *CompetitorClient) Get(ctx context.Context, id xid.ID) (*Competitor, error) {
	return c.Query().Where(competitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompetitorClient) GetX(ctx context.Context, id xid.ID) *Competitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTenders queries the tenders edge of a Competitor.
func (c *CompetitorClient) QueryTenders(co *Competitor) *TenderCompetitorQuery {
	query := (&TenderCompetitorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competitor.Table, competitor.FieldID, id),
			sqlgraph.To(tendercompetitor.Table, tendercompetitor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, competitor.TendersTable, competitor.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompetitorClient) Hooks() []Hook {
	return c.hooks.Competitor
}

// Interceptors returns the client interceptors.
func (c *CompetitorClient) Interceptors() []Interceptor {
	return c.inters.Competitor
}

func (c *CompetitorClient) mutate(ctx context.Context, m *CompetitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompetitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompetitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompetitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Competitor mutation op: %q", m.Op())
	}
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `country.Intercept(f(g(h())))`.
func (c *CountryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Country = append(c.inters.Country, interceptors...)
}

// Create returns a builder for creating a Country entity.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Country entities.
func (c *CountryClient) CreateBulk(builders ...*CountryCreate) *CountryCreateBulk {
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CountryClient) MapCreateBulk(slice any, setFunc func(*CountryCreate, int)) *CountryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CountryCreateBulk{err: fmt.Errorf("calling to CountryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CountryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id xid.ID) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryClient) DeleteOneID(id xid.ID) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Query returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountry},
		inters: c.Interceptors(),
	}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id xid.ID) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id xid.ID) *Country {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvinces queries the provinces edge of a Country.
func (c *CountryClient) QueryProvinces(co *Country) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ProvincesTable, country.ProvincesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	return c.hooks.Country
}

// Interceptors returns the client interceptors.
func (c *CountryClient) Interceptors() []Interceptor {
	return c.inters.Country
}

func (c *CountryClient) mutate(ctx context.Context, m *CountryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Country mutation op: %q", m.Op())
	}
}

// CustomerClient is a client for the Customer schema.
type CustomerClient struct {
	config
}

// NewCustomerClient returns a client for the Customer from the given config.
func NewCustomerClient(c config) *CustomerClient {
	return &CustomerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customer.Hooks(f(g(h())))`.
func (c *CustomerClient) Use(hooks ...Hook) {
	c.hooks.Customer = append(c.hooks.Customer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customer.Intercept(f(g(h())))`.
func (c *CustomerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Customer = append(c.inters.Customer, interceptors...)
}

// Create returns a builder for creating a Customer entity.
func (c *CustomerClient) Create() *CustomerCreate {
	mutation := newCustomerMutation(c.config, OpCreate)
	return &CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Customer entities.
func (c *CustomerClient) CreateBulk(builders ...*CustomerCreate) *CustomerCreateBulk {
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerClient) MapCreateBulk(slice any, setFunc func(*CustomerCreate, int)) *CustomerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerCreateBulk{err: fmt.Errorf("calling to CustomerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Customer.
func (c *CustomerClient) Update() *CustomerUpdate {
	mutation := newCustomerMutation(c.config, OpUpdate)
	return &CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerClient) UpdateOne(cu *Customer) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomer(cu))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerClient) UpdateOneID(id xid.ID) *CustomerUpdateOne {
	mutation := newCustomerMutation(c.config, OpUpdateOne, withCustomerID(id))
	return &CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Customer.
func (c *CustomerClient) Delete() *CustomerDelete {
	mutation := newCustomerMutation(c.config, OpDelete)
	return &CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerClient) DeleteOne(cu *Customer) *CustomerDeleteOne {
	return c.DeleteOneID(cu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerClient) DeleteOneID(id xid.ID) *CustomerDeleteOne {
	builder := c.Delete().Where(customer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerDeleteOne{builder}
}

// Query returns a query builder for Customer.
func (c *CustomerClient) Query() *CustomerQuery {
	return &CustomerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomer},
		inters: c.Interceptors(),
	}
}

// Get returns a Customer entity by its id.
func (c *CustomerClient) Get(ctx context.Context, id xid.ID) (*Customer, error) {
	return c.Query().Where(customer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerClient) GetX(ctx context.Context, id xid.ID) *Customer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArea queries the area edge of a Customer.
func (c *CustomerClient) QueryArea(cu *Customer) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.AreaTable, customer.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a Customer.
func (c *CustomerClient) QueryTenders(cu *Customer) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.TendersTable, customer.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a Customer.
func (c *CustomerClient) QuerySales(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customer.SalesTable, customer.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Customer.
func (c *CustomerClient) QueryCreatedBy(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customer.CreatedByTable, customer.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUpdatedBy queries the updated_by edge of a Customer.
func (c *CustomerClient) QueryUpdatedBy(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customer.UpdatedByTable, customer.UpdatedByColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a Customer.
func (c *CustomerClient) QueryApprover(cu *Customer) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customer.ApproverTable, customer.ApproverColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisitRecords queries the visit_records edge of a Customer.
func (c *CustomerClient) QueryVisitRecords(cu *Customer) *VisitRecordQuery {
	query := (&VisitRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(visitrecord.Table, visitrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.VisitRecordsTable, customer.VisitRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfiles queries the profiles edge of a Customer.
func (c *CustomerClient) QueryProfiles(cu *Customer) *CustomerProfileQuery {
	query := (&CustomerProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customerprofile.Table, customerprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, customer.ProfilesTable, customer.ProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiveProfile queries the active_profile edge of a Customer.
func (c *CustomerClient) QueryActiveProfile(cu *Customer) *CustomerProfileQuery {
	query := (&CustomerProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customerprofile.Table, customerprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customer.ActiveProfileTable, customer.ActiveProfileColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPendingProfile queries the pending_profile edge of a Customer.
func (c *CustomerClient) QueryPendingProfile(cu *Customer) *CustomerProfileQuery {
	query := (&CustomerProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customer.Table, customer.FieldID, id),
			sqlgraph.To(customerprofile.Table, customerprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customer.PendingProfileTable, customer.PendingProfileColumn),
		)
		fromV = sqlgraph.Neighbors(cu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerClient) Hooks() []Hook {
	return c.hooks.Customer
}

// Interceptors returns the client interceptors.
func (c *CustomerClient) Interceptors() []Interceptor {
	return c.inters.Customer
}

func (c *CustomerClient) mutate(ctx context.Context, m *CustomerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Customer mutation op: %q", m.Op())
	}
}

// CustomerProfileClient is a client for the CustomerProfile schema.
type CustomerProfileClient struct {
	config
}

// NewCustomerProfileClient returns a client for the CustomerProfile from the given config.
func NewCustomerProfileClient(c config) *CustomerProfileClient {
	return &CustomerProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `customerprofile.Hooks(f(g(h())))`.
func (c *CustomerProfileClient) Use(hooks ...Hook) {
	c.hooks.CustomerProfile = append(c.hooks.CustomerProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `customerprofile.Intercept(f(g(h())))`.
func (c *CustomerProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.CustomerProfile = append(c.inters.CustomerProfile, interceptors...)
}

// Create returns a builder for creating a CustomerProfile entity.
func (c *CustomerProfileClient) Create() *CustomerProfileCreate {
	mutation := newCustomerProfileMutation(c.config, OpCreate)
	return &CustomerProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CustomerProfile entities.
func (c *CustomerProfileClient) CreateBulk(builders ...*CustomerProfileCreate) *CustomerProfileCreateBulk {
	return &CustomerProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CustomerProfileClient) MapCreateBulk(slice any, setFunc func(*CustomerProfileCreate, int)) *CustomerProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CustomerProfileCreateBulk{err: fmt.Errorf("calling to CustomerProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CustomerProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CustomerProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CustomerProfile.
func (c *CustomerProfileClient) Update() *CustomerProfileUpdate {
	mutation := newCustomerProfileMutation(c.config, OpUpdate)
	return &CustomerProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CustomerProfileClient) UpdateOne(cp *CustomerProfile) *CustomerProfileUpdateOne {
	mutation := newCustomerProfileMutation(c.config, OpUpdateOne, withCustomerProfile(cp))
	return &CustomerProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CustomerProfileClient) UpdateOneID(id xid.ID) *CustomerProfileUpdateOne {
	mutation := newCustomerProfileMutation(c.config, OpUpdateOne, withCustomerProfileID(id))
	return &CustomerProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CustomerProfile.
func (c *CustomerProfileClient) Delete() *CustomerProfileDelete {
	mutation := newCustomerProfileMutation(c.config, OpDelete)
	return &CustomerProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CustomerProfileClient) DeleteOne(cp *CustomerProfile) *CustomerProfileDeleteOne {
	return c.DeleteOneID(cp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CustomerProfileClient) DeleteOneID(id xid.ID) *CustomerProfileDeleteOne {
	builder := c.Delete().Where(customerprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CustomerProfileDeleteOne{builder}
}

// Query returns a query builder for CustomerProfile.
func (c *CustomerProfileClient) Query() *CustomerProfileQuery {
	return &CustomerProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCustomerProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a CustomerProfile entity by its id.
func (c *CustomerProfileClient) Get(ctx context.Context, id xid.ID) (*CustomerProfile, error) {
	return c.Query().Where(customerprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CustomerProfileClient) GetX(ctx context.Context, id xid.ID) *CustomerProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCustomer queries the customer edge of a CustomerProfile.
func (c *CustomerProfileClient) QueryCustomer(cp *CustomerProfile) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customerprofile.Table, customerprofile.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, customerprofile.CustomerTable, customerprofile.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a CustomerProfile.
func (c *CustomerProfileClient) QueryCreatedBy(cp *CustomerProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customerprofile.Table, customerprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customerprofile.CreatedByTable, customerprofile.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a CustomerProfile.
func (c *CustomerProfileClient) QueryApprover(cp *CustomerProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customerprofile.Table, customerprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customerprofile.ApproverTable, customerprofile.ApproverColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySales queries the sales edge of a CustomerProfile.
func (c *CustomerProfileClient) QuerySales(cp *CustomerProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(customerprofile.Table, customerprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, customerprofile.SalesTable, customerprofile.SalesColumn),
		)
		fromV = sqlgraph.Neighbors(cp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CustomerProfileClient) Hooks() []Hook {
	return c.hooks.CustomerProfile
}

// Interceptors returns the client interceptors.
func (c *CustomerProfileClient) Interceptors() []Interceptor {
	return c.inters.CustomerProfile
}

func (c *CustomerProfileClient) mutate(ctx context.Context, m *CustomerProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CustomerProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CustomerProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CustomerProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CustomerProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CustomerProfile mutation op: %q", m.Op())
	}
}

// DistrictClient is a client for the District schema.
type DistrictClient struct {
	config
}

// NewDistrictClient returns a client for the District from the given config.
func NewDistrictClient(c config) *DistrictClient {
	return &DistrictClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `district.Hooks(f(g(h())))`.
func (c *DistrictClient) Use(hooks ...Hook) {
	c.hooks.District = append(c.hooks.District, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `district.Intercept(f(g(h())))`.
func (c *DistrictClient) Intercept(interceptors ...Interceptor) {
	c.inters.District = append(c.inters.District, interceptors...)
}

// Create returns a builder for creating a District entity.
func (c *DistrictClient) Create() *DistrictCreate {
	mutation := newDistrictMutation(c.config, OpCreate)
	return &DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of District entities.
func (c *DistrictClient) CreateBulk(builders ...*DistrictCreate) *DistrictCreateBulk {
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DistrictClient) MapCreateBulk(slice any, setFunc func(*DistrictCreate, int)) *DistrictCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DistrictCreateBulk{err: fmt.Errorf("calling to DistrictClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DistrictCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for District.
func (c *DistrictClient) Update() *DistrictUpdate {
	mutation := newDistrictMutation(c.config, OpUpdate)
	return &DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DistrictClient) UpdateOne(d *District) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrict(d))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DistrictClient) UpdateOneID(id xid.ID) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrictID(id))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for District.
func (c *DistrictClient) Delete() *DistrictDelete {
	mutation := newDistrictMutation(c.config, OpDelete)
	return &DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DistrictClient) DeleteOne(d *District) *DistrictDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DistrictClient) DeleteOneID(id xid.ID) *DistrictDeleteOne {
	builder := c.Delete().Where(district.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DistrictDeleteOne{builder}
}

// Query returns a query builder for District.
func (c *DistrictClient) Query() *DistrictQuery {
	return &DistrictQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDistrict},
		inters: c.Interceptors(),
	}
}

// Get returns a District entity by its id.
func (c *DistrictClient) Get(ctx context.Context, id xid.ID) (*District, error) {
	return c.Query().Where(district.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DistrictClient) GetX(ctx context.Context, id xid.ID) *District {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvince queries the province edge of a District.
func (c *DistrictClient) QueryProvince(d *District) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, district.ProvinceTable, district.ProvinceColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCity queries the city edge of a District.
func (c *DistrictClient) QueryCity(d *District) *CityQuery {
	query := (&CityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(city.Table, city.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, district.CityTable, district.CityColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a District.
func (c *DistrictClient) QueryTenders(d *District) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.TendersTable, district.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlots queries the plots edge of a District.
func (c *DistrictClient) QueryPlots(d *District) *PlotQuery {
	query := (&PlotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(plot.Table, plot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.PlotsTable, district.PlotsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DistrictClient) Hooks() []Hook {
	return c.hooks.District
}

// Interceptors returns the client interceptors.
func (c *DistrictClient) Interceptors() []Interceptor {
	return c.inters.District
}

func (c *DistrictClient) mutate(ctx context.Context, m *DistrictMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown District mutation op: %q", m.Op())
	}
}

// OperationClient is a client for the Operation schema.
type OperationClient struct {
	config
}

// NewOperationClient returns a client for the Operation from the given config.
func NewOperationClient(c config) *OperationClient {
	return &OperationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `operation.Hooks(f(g(h())))`.
func (c *OperationClient) Use(hooks ...Hook) {
	c.hooks.Operation = append(c.hooks.Operation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `operation.Intercept(f(g(h())))`.
func (c *OperationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Operation = append(c.inters.Operation, interceptors...)
}

// Create returns a builder for creating a Operation entity.
func (c *OperationClient) Create() *OperationCreate {
	mutation := newOperationMutation(c.config, OpCreate)
	return &OperationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Operation entities.
func (c *OperationClient) CreateBulk(builders ...*OperationCreate) *OperationCreateBulk {
	return &OperationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OperationClient) MapCreateBulk(slice any, setFunc func(*OperationCreate, int)) *OperationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OperationCreateBulk{err: fmt.Errorf("calling to OperationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OperationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OperationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Operation.
func (c *OperationClient) Update() *OperationUpdate {
	mutation := newOperationMutation(c.config, OpUpdate)
	return &OperationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OperationClient) UpdateOne(o *Operation) *OperationUpdateOne {
	mutation := newOperationMutation(c.config, OpUpdateOne, withOperation(o))
	return &OperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OperationClient) UpdateOneID(id xid.ID) *OperationUpdateOne {
	mutation := newOperationMutation(c.config, OpUpdateOne, withOperationID(id))
	return &OperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Operation.
func (c *OperationClient) Delete() *OperationDelete {
	mutation := newOperationMutation(c.config, OpDelete)
	return &OperationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OperationClient) DeleteOne(o *Operation) *OperationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OperationClient) DeleteOneID(id xid.ID) *OperationDeleteOne {
	builder := c.Delete().Where(operation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OperationDeleteOne{builder}
}

// Query returns a query builder for Operation.
func (c *OperationClient) Query() *OperationQuery {
	return &OperationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOperation},
		inters: c.Interceptors(),
	}
}

// Get returns a Operation entity by its id.
func (c *OperationClient) Get(ctx context.Context, id xid.ID) (*Operation, error) {
	return c.Query().Where(operation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OperationClient) GetX(ctx context.Context, id xid.ID) *Operation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OperationClient) Hooks() []Hook {
	return c.hooks.Operation
}

// Interceptors returns the client interceptors.
func (c *OperationClient) Interceptors() []Interceptor {
	return c.inters.Operation
}

func (c *OperationClient) mutate(ctx context.Context, m *OperationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OperationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OperationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OperationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OperationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Operation mutation op: %q", m.Op())
	}
}

// PlotClient is a client for the Plot schema.
type PlotClient struct {
	config
}

// NewPlotClient returns a client for the Plot from the given config.
func NewPlotClient(c config) *PlotClient {
	return &PlotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plot.Hooks(f(g(h())))`.
func (c *PlotClient) Use(hooks ...Hook) {
	c.hooks.Plot = append(c.hooks.Plot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plot.Intercept(f(g(h())))`.
func (c *PlotClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plot = append(c.inters.Plot, interceptors...)
}

// Create returns a builder for creating a Plot entity.
func (c *PlotClient) Create() *PlotCreate {
	mutation := newPlotMutation(c.config, OpCreate)
	return &PlotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plot entities.
func (c *PlotClient) CreateBulk(builders ...*PlotCreate) *PlotCreateBulk {
	return &PlotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlotClient) MapCreateBulk(slice any, setFunc func(*PlotCreate, int)) *PlotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlotCreateBulk{err: fmt.Errorf("calling to PlotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plot.
func (c *PlotClient) Update() *PlotUpdate {
	mutation := newPlotMutation(c.config, OpUpdate)
	return &PlotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlotClient) UpdateOne(pl *Plot) *PlotUpdateOne {
	mutation := newPlotMutation(c.config, OpUpdateOne, withPlot(pl))
	return &PlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlotClient) UpdateOneID(id xid.ID) *PlotUpdateOne {
	mutation := newPlotMutation(c.config, OpUpdateOne, withPlotID(id))
	return &PlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plot.
func (c *PlotClient) Delete() *PlotDelete {
	mutation := newPlotMutation(c.config, OpDelete)
	return &PlotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlotClient) DeleteOne(pl *Plot) *PlotDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlotClient) DeleteOneID(id xid.ID) *PlotDeleteOne {
	builder := c.Delete().Where(plot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlotDeleteOne{builder}
}

// Query returns a query builder for Plot.
func (c *PlotClient) Query() *PlotQuery {
	return &PlotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlot},
		inters: c.Interceptors(),
	}
}

// Get returns a Plot entity by its id.
func (c *PlotClient) Get(ctx context.Context, id xid.ID) (*Plot, error) {
	return c.Query().Where(plot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlotClient) GetX(ctx context.Context, id xid.ID) *Plot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDistrict queries the district edge of a Plot.
func (c *PlotClient) QueryDistrict(pl *Plot) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plot.Table, plot.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, plot.DistrictTable, plot.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlotClient) Hooks() []Hook {
	return c.hooks.Plot
}

// Interceptors returns the client interceptors.
func (c *PlotClient) Interceptors() []Interceptor {
	return c.inters.Plot
}

func (c *PlotClient) mutate(ctx context.Context, m *PlotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plot mutation op: %q", m.Op())
	}
}

// PotentialTenderClient is a client for the PotentialTender schema.
type PotentialTenderClient struct {
	config
}

// NewPotentialTenderClient returns a client for the PotentialTender from the given config.
func NewPotentialTenderClient(c config) *PotentialTenderClient {
	return &PotentialTenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `potentialtender.Hooks(f(g(h())))`.
func (c *PotentialTenderClient) Use(hooks ...Hook) {
	c.hooks.PotentialTender = append(c.hooks.PotentialTender, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `potentialtender.Intercept(f(g(h())))`.
func (c *PotentialTenderClient) Intercept(interceptors ...Interceptor) {
	c.inters.PotentialTender = append(c.inters.PotentialTender, interceptors...)
}

// Create returns a builder for creating a PotentialTender entity.
func (c *PotentialTenderClient) Create() *PotentialTenderCreate {
	mutation := newPotentialTenderMutation(c.config, OpCreate)
	return &PotentialTenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PotentialTender entities.
func (c *PotentialTenderClient) CreateBulk(builders ...*PotentialTenderCreate) *PotentialTenderCreateBulk {
	return &PotentialTenderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PotentialTenderClient) MapCreateBulk(slice any, setFunc func(*PotentialTenderCreate, int)) *PotentialTenderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PotentialTenderCreateBulk{err: fmt.Errorf("calling to PotentialTenderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PotentialTenderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PotentialTenderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PotentialTender.
func (c *PotentialTenderClient) Update() *PotentialTenderUpdate {
	mutation := newPotentialTenderMutation(c.config, OpUpdate)
	return &PotentialTenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PotentialTenderClient) UpdateOne(pt *PotentialTender) *PotentialTenderUpdateOne {
	mutation := newPotentialTenderMutation(c.config, OpUpdateOne, withPotentialTender(pt))
	return &PotentialTenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PotentialTenderClient) UpdateOneID(id xid.ID) *PotentialTenderUpdateOne {
	mutation := newPotentialTenderMutation(c.config, OpUpdateOne, withPotentialTenderID(id))
	return &PotentialTenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PotentialTender.
func (c *PotentialTenderClient) Delete() *PotentialTenderDelete {
	mutation := newPotentialTenderMutation(c.config, OpDelete)
	return &PotentialTenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PotentialTenderClient) DeleteOne(pt *PotentialTender) *PotentialTenderDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PotentialTenderClient) DeleteOneID(id xid.ID) *PotentialTenderDeleteOne {
	builder := c.Delete().Where(potentialtender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PotentialTenderDeleteOne{builder}
}

// Query returns a query builder for PotentialTender.
func (c *PotentialTenderClient) Query() *PotentialTenderQuery {
	return &PotentialTenderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePotentialTender},
		inters: c.Interceptors(),
	}
}

// Get returns a PotentialTender entity by its id.
func (c *PotentialTenderClient) Get(ctx context.Context, id xid.ID) (*PotentialTender, error) {
	return c.Query().Where(potentialtender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PotentialTenderClient) GetX(ctx context.Context, id xid.ID) *PotentialTender {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PotentialTenderClient) Hooks() []Hook {
	return c.hooks.PotentialTender
}

// Interceptors returns the client interceptors.
func (c *PotentialTenderClient) Interceptors() []Interceptor {
	return c.inters.PotentialTender
}

func (c *PotentialTenderClient) mutate(ctx context.Context, m *PotentialTenderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PotentialTenderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PotentialTenderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PotentialTenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PotentialTenderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PotentialTender mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProjectClient) MapCreateBulk(slice any, setFunc func(*ProjectCreate, int)) *ProjectCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProjectCreateBulk{err: fmt.Errorf("calling to ProjectClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProjectCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id xid.ID) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id xid.ID) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id xid.ID) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id xid.ID) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Project.
func (c *ProjectClient) QueryUsers(pr *Project) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(project.Table, project.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, project.UsersTable, project.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// ProvinceClient is a client for the Province schema.
type ProvinceClient struct {
	config
}

// NewProvinceClient returns a client for the Province from the given config.
func NewProvinceClient(c config) *ProvinceClient {
	return &ProvinceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `province.Hooks(f(g(h())))`.
func (c *ProvinceClient) Use(hooks ...Hook) {
	c.hooks.Province = append(c.hooks.Province, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `province.Intercept(f(g(h())))`.
func (c *ProvinceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Province = append(c.inters.Province, interceptors...)
}

// Create returns a builder for creating a Province entity.
func (c *ProvinceClient) Create() *ProvinceCreate {
	mutation := newProvinceMutation(c.config, OpCreate)
	return &ProvinceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Province entities.
func (c *ProvinceClient) CreateBulk(builders ...*ProvinceCreate) *ProvinceCreateBulk {
	return &ProvinceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvinceClient) MapCreateBulk(slice any, setFunc func(*ProvinceCreate, int)) *ProvinceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvinceCreateBulk{err: fmt.Errorf("calling to ProvinceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvinceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvinceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Province.
func (c *ProvinceClient) Update() *ProvinceUpdate {
	mutation := newProvinceMutation(c.config, OpUpdate)
	return &ProvinceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvinceClient) UpdateOne(pr *Province) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvince(pr))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvinceClient) UpdateOneID(id xid.ID) *ProvinceUpdateOne {
	mutation := newProvinceMutation(c.config, OpUpdateOne, withProvinceID(id))
	return &ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Province.
func (c *ProvinceClient) Delete() *ProvinceDelete {
	mutation := newProvinceMutation(c.config, OpDelete)
	return &ProvinceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvinceClient) DeleteOne(pr *Province) *ProvinceDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvinceClient) DeleteOneID(id xid.ID) *ProvinceDeleteOne {
	builder := c.Delete().Where(province.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvinceDeleteOne{builder}
}

// Query returns a query builder for Province.
func (c *ProvinceClient) Query() *ProvinceQuery {
	return &ProvinceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvince},
		inters: c.Interceptors(),
	}
}

// Get returns a Province entity by its id.
func (c *ProvinceClient) Get(ctx context.Context, id xid.ID) (*Province, error) {
	return c.Query().Where(province.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvinceClient) GetX(ctx context.Context, id xid.ID) *Province {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDistricts queries the districts edge of a Province.
func (c *ProvinceClient) QueryDistricts(pr *Province) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.DistrictsTable, province.DistrictsColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCities queries the cities edge of a Province.
func (c *ProvinceClient) QueryCities(pr *Province) *CityQuery {
	query := (&CityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(city.Table, city.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.CitiesTable, province.CitiesColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCountry queries the country edge of a Province.
func (c *ProvinceClient) QueryCountry(pr *Province) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, province.CountryTable, province.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a Province.
func (c *ProvinceClient) QueryTenders(pr *Province) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, province.TendersTable, province.TendersColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryArea queries the area edge of a Province.
func (c *ProvinceClient) QueryArea(pr *Province) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(province.Table, province.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, province.AreaTable, province.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(pr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvinceClient) Hooks() []Hook {
	return c.hooks.Province
}

// Interceptors returns the client interceptors.
func (c *ProvinceClient) Interceptors() []Interceptor {
	return c.inters.Province
}

func (c *ProvinceClient) mutate(ctx context.Context, m *ProvinceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvinceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvinceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvinceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvinceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Province mutation op: %q", m.Op())
	}
}

// TenderClient is a client for the Tender schema.
type TenderClient struct {
	config
}

// NewTenderClient returns a client for the Tender from the given config.
func NewTenderClient(c config) *TenderClient {
	return &TenderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tender.Hooks(f(g(h())))`.
func (c *TenderClient) Use(hooks ...Hook) {
	c.hooks.Tender = append(c.hooks.Tender, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tender.Intercept(f(g(h())))`.
func (c *TenderClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tender = append(c.inters.Tender, interceptors...)
}

// Create returns a builder for creating a Tender entity.
func (c *TenderClient) Create() *TenderCreate {
	mutation := newTenderMutation(c.config, OpCreate)
	return &TenderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tender entities.
func (c *TenderClient) CreateBulk(builders ...*TenderCreate) *TenderCreateBulk {
	return &TenderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenderClient) MapCreateBulk(slice any, setFunc func(*TenderCreate, int)) *TenderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenderCreateBulk{err: fmt.Errorf("calling to TenderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tender.
func (c *TenderClient) Update() *TenderUpdate {
	mutation := newTenderMutation(c.config, OpUpdate)
	return &TenderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenderClient) UpdateOne(t *Tender) *TenderUpdateOne {
	mutation := newTenderMutation(c.config, OpUpdateOne, withTender(t))
	return &TenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenderClient) UpdateOneID(id xid.ID) *TenderUpdateOne {
	mutation := newTenderMutation(c.config, OpUpdateOne, withTenderID(id))
	return &TenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tender.
func (c *TenderClient) Delete() *TenderDelete {
	mutation := newTenderMutation(c.config, OpDelete)
	return &TenderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenderClient) DeleteOne(t *Tender) *TenderDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenderClient) DeleteOneID(id xid.ID) *TenderDeleteOne {
	builder := c.Delete().Where(tender.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenderDeleteOne{builder}
}

// Query returns a query builder for Tender.
func (c *TenderClient) Query() *TenderQuery {
	return &TenderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTender},
		inters: c.Interceptors(),
	}
}

// Get returns a Tender entity by its id.
func (c *TenderClient) Get(ctx context.Context, id xid.ID) (*Tender, error) {
	return c.Query().Where(tender.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenderClient) GetX(ctx context.Context, id xid.ID) *Tender {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryArea queries the area edge of a Tender.
func (c *TenderClient) QueryArea(t *Tender) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tender.AreaTable, tender.AreaColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfiles queries the profiles edge of a Tender.
func (c *TenderClient) QueryProfiles(t *Tender) *TenderProfileQuery {
	query := (&TenderProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(tenderprofile.Table, tenderprofile.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tender.ProfilesTable, tender.ProfilesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitors queries the competitors edge of a Tender.
func (c *TenderClient) QueryCompetitors(t *Tender) *TenderCompetitorQuery {
	query := (&TenderCompetitorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(tendercompetitor.Table, tendercompetitor.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tender.CompetitorsTable, tender.CompetitorsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a Tender.
func (c *TenderClient) QueryCustomer(t *Tender) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tender.CustomerTable, tender.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFinder queries the finder edge of a Tender.
func (c *TenderClient) QueryFinder(t *Tender) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tender.FinderTable, tender.FinderColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a Tender.
func (c *TenderClient) QueryCreatedBy(t *Tender) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tender.CreatedByTable, tender.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowingSales queries the following_sales edge of a Tender.
func (c *TenderClient) QueryFollowingSales(t *Tender) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, tender.FollowingSalesTable, tender.FollowingSalesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvince queries the province edge of a Tender.
func (c *TenderClient) QueryProvince(t *Tender) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tender.ProvinceTable, tender.ProvinceColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCity queries the city edge of a Tender.
func (c *TenderClient) QueryCity(t *Tender) *CityQuery {
	query := (&CityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(city.Table, city.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tender.CityTable, tender.CityColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Tender.
func (c *TenderClient) QueryDistrict(t *Tender) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tender.DistrictTable, tender.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisitRecords queries the visit_records edge of a Tender.
func (c *TenderClient) QueryVisitRecords(t *Tender) *VisitRecordQuery {
	query := (&VisitRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(visitrecord.Table, visitrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tender.VisitRecordsTable, tender.VisitRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a Tender.
func (c *TenderClient) QueryApprover(t *Tender) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tender.ApproverTable, tender.ApproverColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryActiveProfile queries the active_profile edge of a Tender.
func (c *TenderClient) QueryActiveProfile(t *Tender) *TenderProfileQuery {
	query := (&TenderProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(tenderprofile.Table, tenderprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tender.ActiveProfileTable, tender.ActiveProfileColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPendingProfile queries the pending_profile edge of a Tender.
func (c *TenderClient) QueryPendingProfile(t *Tender) *TenderProfileQuery {
	query := (&TenderProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tender.Table, tender.FieldID, id),
			sqlgraph.To(tenderprofile.Table, tenderprofile.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tender.PendingProfileTable, tender.PendingProfileColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenderClient) Hooks() []Hook {
	return c.hooks.Tender
}

// Interceptors returns the client interceptors.
func (c *TenderClient) Interceptors() []Interceptor {
	return c.inters.Tender
}

func (c *TenderClient) mutate(ctx context.Context, m *TenderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tender mutation op: %q", m.Op())
	}
}

// TenderCompetitorClient is a client for the TenderCompetitor schema.
type TenderCompetitorClient struct {
	config
}

// NewTenderCompetitorClient returns a client for the TenderCompetitor from the given config.
func NewTenderCompetitorClient(c config) *TenderCompetitorClient {
	return &TenderCompetitorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tendercompetitor.Hooks(f(g(h())))`.
func (c *TenderCompetitorClient) Use(hooks ...Hook) {
	c.hooks.TenderCompetitor = append(c.hooks.TenderCompetitor, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tendercompetitor.Intercept(f(g(h())))`.
func (c *TenderCompetitorClient) Intercept(interceptors ...Interceptor) {
	c.inters.TenderCompetitor = append(c.inters.TenderCompetitor, interceptors...)
}

// Create returns a builder for creating a TenderCompetitor entity.
func (c *TenderCompetitorClient) Create() *TenderCompetitorCreate {
	mutation := newTenderCompetitorMutation(c.config, OpCreate)
	return &TenderCompetitorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TenderCompetitor entities.
func (c *TenderCompetitorClient) CreateBulk(builders ...*TenderCompetitorCreate) *TenderCompetitorCreateBulk {
	return &TenderCompetitorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenderCompetitorClient) MapCreateBulk(slice any, setFunc func(*TenderCompetitorCreate, int)) *TenderCompetitorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenderCompetitorCreateBulk{err: fmt.Errorf("calling to TenderCompetitorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenderCompetitorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenderCompetitorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TenderCompetitor.
func (c *TenderCompetitorClient) Update() *TenderCompetitorUpdate {
	mutation := newTenderCompetitorMutation(c.config, OpUpdate)
	return &TenderCompetitorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenderCompetitorClient) UpdateOne(tc *TenderCompetitor) *TenderCompetitorUpdateOne {
	mutation := newTenderCompetitorMutation(c.config, OpUpdateOne, withTenderCompetitor(tc))
	return &TenderCompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenderCompetitorClient) UpdateOneID(id xid.ID) *TenderCompetitorUpdateOne {
	mutation := newTenderCompetitorMutation(c.config, OpUpdateOne, withTenderCompetitorID(id))
	return &TenderCompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TenderCompetitor.
func (c *TenderCompetitorClient) Delete() *TenderCompetitorDelete {
	mutation := newTenderCompetitorMutation(c.config, OpDelete)
	return &TenderCompetitorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenderCompetitorClient) DeleteOne(tc *TenderCompetitor) *TenderCompetitorDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenderCompetitorClient) DeleteOneID(id xid.ID) *TenderCompetitorDeleteOne {
	builder := c.Delete().Where(tendercompetitor.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenderCompetitorDeleteOne{builder}
}

// Query returns a query builder for TenderCompetitor.
func (c *TenderCompetitorClient) Query() *TenderCompetitorQuery {
	return &TenderCompetitorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenderCompetitor},
		inters: c.Interceptors(),
	}
}

// Get returns a TenderCompetitor entity by its id.
func (c *TenderCompetitorClient) Get(ctx context.Context, id xid.ID) (*TenderCompetitor, error) {
	return c.Query().Where(tendercompetitor.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenderCompetitorClient) GetX(ctx context.Context, id xid.ID) *TenderCompetitor {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTender queries the tender edge of a TenderCompetitor.
func (c *TenderCompetitorClient) QueryTender(tc *TenderCompetitor) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tendercompetitor.Table, tendercompetitor.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tendercompetitor.TenderTable, tendercompetitor.TenderColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitor queries the competitor edge of a TenderCompetitor.
func (c *TenderCompetitorClient) QueryCompetitor(tc *TenderCompetitor) *CompetitorQuery {
	query := (&CompetitorClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tendercompetitor.Table, tendercompetitor.FieldID, id),
			sqlgraph.To(competitor.Table, competitor.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tendercompetitor.CompetitorTable, tendercompetitor.CompetitorColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenderCompetitorClient) Hooks() []Hook {
	return c.hooks.TenderCompetitor
}

// Interceptors returns the client interceptors.
func (c *TenderCompetitorClient) Interceptors() []Interceptor {
	return c.inters.TenderCompetitor
}

func (c *TenderCompetitorClient) mutate(ctx context.Context, m *TenderCompetitorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenderCompetitorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenderCompetitorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenderCompetitorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenderCompetitorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TenderCompetitor mutation op: %q", m.Op())
	}
}

// TenderProfileClient is a client for the TenderProfile schema.
type TenderProfileClient struct {
	config
}

// NewTenderProfileClient returns a client for the TenderProfile from the given config.
func NewTenderProfileClient(c config) *TenderProfileClient {
	return &TenderProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tenderprofile.Hooks(f(g(h())))`.
func (c *TenderProfileClient) Use(hooks ...Hook) {
	c.hooks.TenderProfile = append(c.hooks.TenderProfile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tenderprofile.Intercept(f(g(h())))`.
func (c *TenderProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.TenderProfile = append(c.inters.TenderProfile, interceptors...)
}

// Create returns a builder for creating a TenderProfile entity.
func (c *TenderProfileClient) Create() *TenderProfileCreate {
	mutation := newTenderProfileMutation(c.config, OpCreate)
	return &TenderProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TenderProfile entities.
func (c *TenderProfileClient) CreateBulk(builders ...*TenderProfileCreate) *TenderProfileCreateBulk {
	return &TenderProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TenderProfileClient) MapCreateBulk(slice any, setFunc func(*TenderProfileCreate, int)) *TenderProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TenderProfileCreateBulk{err: fmt.Errorf("calling to TenderProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TenderProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TenderProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TenderProfile.
func (c *TenderProfileClient) Update() *TenderProfileUpdate {
	mutation := newTenderProfileMutation(c.config, OpUpdate)
	return &TenderProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TenderProfileClient) UpdateOne(tp *TenderProfile) *TenderProfileUpdateOne {
	mutation := newTenderProfileMutation(c.config, OpUpdateOne, withTenderProfile(tp))
	return &TenderProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TenderProfileClient) UpdateOneID(id xid.ID) *TenderProfileUpdateOne {
	mutation := newTenderProfileMutation(c.config, OpUpdateOne, withTenderProfileID(id))
	return &TenderProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TenderProfile.
func (c *TenderProfileClient) Delete() *TenderProfileDelete {
	mutation := newTenderProfileMutation(c.config, OpDelete)
	return &TenderProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TenderProfileClient) DeleteOne(tp *TenderProfile) *TenderProfileDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TenderProfileClient) DeleteOneID(id xid.ID) *TenderProfileDeleteOne {
	builder := c.Delete().Where(tenderprofile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TenderProfileDeleteOne{builder}
}

// Query returns a query builder for TenderProfile.
func (c *TenderProfileClient) Query() *TenderProfileQuery {
	return &TenderProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTenderProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a TenderProfile entity by its id.
func (c *TenderProfileClient) Get(ctx context.Context, id xid.ID) (*TenderProfile, error) {
	return c.Query().Where(tenderprofile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TenderProfileClient) GetX(ctx context.Context, id xid.ID) *TenderProfile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTender queries the tender edge of a TenderProfile.
func (c *TenderProfileClient) QueryTender(tp *TenderProfile) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tenderprofile.TenderTable, tenderprofile.TenderColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a TenderProfile.
func (c *TenderProfileClient) QueryCustomer(tp *TenderProfile) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.CustomerTable, tenderprofile.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFinder queries the finder edge of a TenderProfile.
func (c *TenderProfileClient) QueryFinder(tp *TenderProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.FinderTable, tenderprofile.FinderColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedBy queries the created_by edge of a TenderProfile.
func (c *TenderProfileClient) QueryCreatedBy(tp *TenderProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.CreatedByTable, tenderprofile.CreatedByColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvince queries the province edge of a TenderProfile.
func (c *TenderProfileClient) QueryProvince(tp *TenderProfile) *ProvinceQuery {
	query := (&ProvinceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(province.Table, province.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.ProvinceTable, tenderprofile.ProvinceColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCity queries the city edge of a TenderProfile.
func (c *TenderProfileClient) QueryCity(tp *TenderProfile) *CityQuery {
	query := (&CityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(city.Table, city.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.CityTable, tenderprofile.CityColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a TenderProfile.
func (c *TenderProfileClient) QueryDistrict(tp *TenderProfile) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.DistrictTable, tenderprofile.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApprover queries the approver edge of a TenderProfile.
func (c *TenderProfileClient) QueryApprover(tp *TenderProfile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tenderprofile.Table, tenderprofile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, tenderprofile.ApproverTable, tenderprofile.ApproverColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TenderProfileClient) Hooks() []Hook {
	return c.hooks.TenderProfile
}

// Interceptors returns the client interceptors.
func (c *TenderProfileClient) Interceptors() []Interceptor {
	return c.inters.TenderProfile
}

func (c *TenderProfileClient) mutate(ctx context.Context, m *TenderProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TenderProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TenderProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TenderProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TenderProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TenderProfile mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id xid.ID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id xid.ID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id xid.ID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id xid.ID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAreas queries the areas edge of a User.
func (c *UserClient) QueryAreas(u *User) *AreaQuery {
	query := (&AreaClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(area.Table, area.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.AreasTable, user.AreasPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomers queries the customers edge of a User.
func (c *UserClient) QueryCustomers(u *User) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CustomersTable, user.CustomersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeader queries the leader edge of a User.
func (c *UserClient) QueryLeader(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.LeaderTable, user.LeaderColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamMembers queries the team_members edge of a User.
func (c *UserClient) QueryTeamMembers(u *User) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TeamMembersTable, user.TeamMembersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTenders queries the tenders edge of a User.
func (c *UserClient) QueryTenders(u *User) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.TendersTable, user.TendersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVisitRecords queries the visit_records edge of a User.
func (c *UserClient) QueryVisitRecords(u *User) *VisitRecordQuery {
	query := (&VisitRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(visitrecord.Table, visitrecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.VisitRecordsTable, user.VisitRecordsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProjects queries the projects edge of a User.
func (c *UserClient) QueryProjects(u *User) *ProjectQuery {
	query := (&ProjectClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(project.Table, project.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.ProjectsTable, user.ProjectsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// VisitRecordClient is a client for the VisitRecord schema.
type VisitRecordClient struct {
	config
}

// NewVisitRecordClient returns a client for the VisitRecord from the given config.
func NewVisitRecordClient(c config) *VisitRecordClient {
	return &VisitRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `visitrecord.Hooks(f(g(h())))`.
func (c *VisitRecordClient) Use(hooks ...Hook) {
	c.hooks.VisitRecord = append(c.hooks.VisitRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `visitrecord.Intercept(f(g(h())))`.
func (c *VisitRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.VisitRecord = append(c.inters.VisitRecord, interceptors...)
}

// Create returns a builder for creating a VisitRecord entity.
func (c *VisitRecordClient) Create() *VisitRecordCreate {
	mutation := newVisitRecordMutation(c.config, OpCreate)
	return &VisitRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VisitRecord entities.
func (c *VisitRecordClient) CreateBulk(builders ...*VisitRecordCreate) *VisitRecordCreateBulk {
	return &VisitRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VisitRecordClient) MapCreateBulk(slice any, setFunc func(*VisitRecordCreate, int)) *VisitRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VisitRecordCreateBulk{err: fmt.Errorf("calling to VisitRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VisitRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VisitRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VisitRecord.
func (c *VisitRecordClient) Update() *VisitRecordUpdate {
	mutation := newVisitRecordMutation(c.config, OpUpdate)
	return &VisitRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VisitRecordClient) UpdateOne(vr *VisitRecord) *VisitRecordUpdateOne {
	mutation := newVisitRecordMutation(c.config, OpUpdateOne, withVisitRecord(vr))
	return &VisitRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VisitRecordClient) UpdateOneID(id xid.ID) *VisitRecordUpdateOne {
	mutation := newVisitRecordMutation(c.config, OpUpdateOne, withVisitRecordID(id))
	return &VisitRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VisitRecord.
func (c *VisitRecordClient) Delete() *VisitRecordDelete {
	mutation := newVisitRecordMutation(c.config, OpDelete)
	return &VisitRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VisitRecordClient) DeleteOne(vr *VisitRecord) *VisitRecordDeleteOne {
	return c.DeleteOneID(vr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VisitRecordClient) DeleteOneID(id xid.ID) *VisitRecordDeleteOne {
	builder := c.Delete().Where(visitrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VisitRecordDeleteOne{builder}
}

// Query returns a query builder for VisitRecord.
func (c *VisitRecordClient) Query() *VisitRecordQuery {
	return &VisitRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVisitRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a VisitRecord entity by its id.
func (c *VisitRecordClient) Get(ctx context.Context, id xid.ID) (*VisitRecord, error) {
	return c.Query().Where(visitrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VisitRecordClient) GetX(ctx context.Context, id xid.ID) *VisitRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTender queries the tender edge of a VisitRecord.
func (c *VisitRecordClient) QueryTender(vr *VisitRecord) *TenderQuery {
	query := (&TenderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(visitrecord.Table, visitrecord.FieldID, id),
			sqlgraph.To(tender.Table, tender.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, visitrecord.TenderTable, visitrecord.TenderColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCustomer queries the customer edge of a VisitRecord.
func (c *VisitRecordClient) QueryCustomer(vr *VisitRecord) *CustomerQuery {
	query := (&CustomerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(visitrecord.Table, visitrecord.FieldID, id),
			sqlgraph.To(customer.Table, customer.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, visitrecord.CustomerTable, visitrecord.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFollowUpBys queries the followUpBys edge of a VisitRecord.
func (c *VisitRecordClient) QueryFollowUpBys(vr *VisitRecord) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(visitrecord.Table, visitrecord.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, visitrecord.FollowUpBysTable, visitrecord.FollowUpBysPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VisitRecordClient) Hooks() []Hook {
	return c.hooks.VisitRecord
}

// Interceptors returns the client interceptors.
func (c *VisitRecordClient) Interceptors() []Interceptor {
	return c.inters.VisitRecord
}

func (c *VisitRecordClient) mutate(ctx context.Context, m *VisitRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VisitRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VisitRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VisitRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VisitRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VisitRecord mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Area, City, Competitor, Country, Customer, CustomerProfile, District, Operation,
		Plot, PotentialTender, Project, Province, Tender, TenderCompetitor,
		TenderProfile, User, VisitRecord []ent.Hook
	}
	inters struct {
		Area, City, Competitor, Country, Customer, CustomerProfile, District, Operation,
		Plot, PotentialTender, Project, Province, Tender, TenderCompetitor,
		TenderProfile, User, VisitRecord []ent.Interceptor
	}
)
