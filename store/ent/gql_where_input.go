// Code generated by ent, DO NOT EDIT.

package ent

import (
	"cscd-bds/store/ent/area"
	"cscd-bds/store/ent/city"
	"cscd-bds/store/ent/country"
	"cscd-bds/store/ent/customer"
	"cscd-bds/store/ent/district"
	"cscd-bds/store/ent/plot"
	"cscd-bds/store/ent/predicate"
	"cscd-bds/store/ent/province"
	"cscd-bds/store/ent/schema/xid"
	"cscd-bds/store/ent/tender"
	"cscd-bds/store/ent/user"
	"cscd-bds/store/ent/visitrecord"
	"errors"
	"fmt"
	"time"
)

// AreaWhereInput represents a where input for filtering Area queries.
type AreaWhereInput struct {
	Predicates []predicate.Area  `json:"-"`
	Not        *AreaWhereInput   `json:"not,omitempty"`
	Or         []*AreaWhereInput `json:"or,omitempty"`
	And        []*AreaWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "customers" edge predicates.
	HasCustomers     *bool                 `json:"hasCustomers,omitempty"`
	HasCustomersWith []*CustomerWhereInput `json:"hasCustomersWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "provinces" edge predicates.
	HasProvinces     *bool                 `json:"hasProvinces,omitempty"`
	HasProvincesWith []*ProvinceWhereInput `json:"hasProvincesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AreaWhereInput) AddPredicates(predicates ...predicate.Area) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AreaWhereInput filter on the AreaQuery builder.
func (i *AreaWhereInput) Filter(q *AreaQuery) (*AreaQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAreaWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAreaWhereInput is returned in case the AreaWhereInput is empty.
var ErrEmptyAreaWhereInput = errors.New("ent: empty predicate AreaWhereInput")

// P returns a predicate for filtering areas.
// An error is returned if the input is empty or invalid.
func (i *AreaWhereInput) P() (predicate.Area, error) {
	var predicates []predicate.Area
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, area.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Area, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, area.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Area, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, area.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, area.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, area.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, area.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, area.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, area.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, area.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, area.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, area.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, area.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, area.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, area.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, area.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, area.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, area.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, area.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, area.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, area.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, area.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, area.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, area.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, area.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, area.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, area.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, area.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, area.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, area.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, area.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, area.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, area.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, area.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, area.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, area.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, area.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, area.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, area.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, area.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, area.NameContainsFold(*i.NameContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, area.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, area.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, area.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, area.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, area.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, area.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, area.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, area.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, area.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, area.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, area.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, area.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, area.CodeContainsFold(*i.CodeContainsFold))
	}

	if i.HasCustomers != nil {
		p := area.HasCustomers()
		if !*i.HasCustomers {
			p = area.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomersWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomersWith))
		for _, w := range i.HasCustomersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, area.HasCustomersWith(with...))
	}
	if i.HasTenders != nil {
		p := area.HasTenders()
		if !*i.HasTenders {
			p = area.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, area.HasTendersWith(with...))
	}
	if i.HasUsers != nil {
		p := area.HasUsers()
		if !*i.HasUsers {
			p = area.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, area.HasUsersWith(with...))
	}
	if i.HasProvinces != nil {
		p := area.HasProvinces()
		if !*i.HasProvinces {
			p = area.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProvincesWith) > 0 {
		with := make([]predicate.Province, 0, len(i.HasProvincesWith))
		for _, w := range i.HasProvincesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProvincesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, area.HasProvincesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAreaWhereInput
	case 1:
		return predicates[0], nil
	default:
		return area.And(predicates...), nil
	}
}

// CityWhereInput represents a where input for filtering City queries.
type CityWhereInput struct {
	Predicates []predicate.City  `json:"-"`
	Not        *CityWhereInput   `json:"not,omitempty"`
	Or         []*CityWhereInput `json:"or,omitempty"`
	And        []*CityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "adcode" field predicates.
	Adcode      *int  `json:"adcode,omitempty"`
	AdcodeNEQ   *int  `json:"adcodeNEQ,omitempty"`
	AdcodeIn    []int `json:"adcodeIn,omitempty"`
	AdcodeNotIn []int `json:"adcodeNotIn,omitempty"`
	AdcodeGT    *int  `json:"adcodeGT,omitempty"`
	AdcodeGTE   *int  `json:"adcodeGTE,omitempty"`
	AdcodeLT    *int  `json:"adcodeLT,omitempty"`
	AdcodeLTE   *int  `json:"adcodeLTE,omitempty"`

	// "prov_code" field predicates.
	ProvCode      *int  `json:"provCode,omitempty"`
	ProvCodeNEQ   *int  `json:"provCodeNEQ,omitempty"`
	ProvCodeIn    []int `json:"provCodeIn,omitempty"`
	ProvCodeNotIn []int `json:"provCodeNotIn,omitempty"`
	ProvCodeGT    *int  `json:"provCodeGT,omitempty"`
	ProvCodeGTE   *int  `json:"provCodeGTE,omitempty"`
	ProvCodeLT    *int  `json:"provCodeLT,omitempty"`
	ProvCodeLTE   *int  `json:"provCodeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "province_id" field predicates.
	ProvinceID             *xid.ID  `json:"provinceID,omitempty"`
	ProvinceIDNEQ          *xid.ID  `json:"provinceIDNEQ,omitempty"`
	ProvinceIDIn           []xid.ID `json:"provinceIDIn,omitempty"`
	ProvinceIDNotIn        []xid.ID `json:"provinceIDNotIn,omitempty"`
	ProvinceIDGT           *xid.ID  `json:"provinceIDGT,omitempty"`
	ProvinceIDGTE          *xid.ID  `json:"provinceIDGTE,omitempty"`
	ProvinceIDLT           *xid.ID  `json:"provinceIDLT,omitempty"`
	ProvinceIDLTE          *xid.ID  `json:"provinceIDLTE,omitempty"`
	ProvinceIDContains     *xid.ID  `json:"provinceIDContains,omitempty"`
	ProvinceIDHasPrefix    *xid.ID  `json:"provinceIDHasPrefix,omitempty"`
	ProvinceIDHasSuffix    *xid.ID  `json:"provinceIDHasSuffix,omitempty"`
	ProvinceIDEqualFold    *xid.ID  `json:"provinceIDEqualFold,omitempty"`
	ProvinceIDContainsFold *xid.ID  `json:"provinceIDContainsFold,omitempty"`

	// "districts" edge predicates.
	HasDistricts     *bool                 `json:"hasDistricts,omitempty"`
	HasDistrictsWith []*DistrictWhereInput `json:"hasDistrictsWith,omitempty"`

	// "province" edge predicates.
	HasProvince     *bool                 `json:"hasProvince,omitempty"`
	HasProvinceWith []*ProvinceWhereInput `json:"hasProvinceWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CityWhereInput) AddPredicates(predicates ...predicate.City) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CityWhereInput filter on the CityQuery builder.
func (i *CityWhereInput) Filter(q *CityQuery) (*CityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCityWhereInput is returned in case the CityWhereInput is empty.
var ErrEmptyCityWhereInput = errors.New("ent: empty predicate CityWhereInput")

// P returns a predicate for filtering cities.
// An error is returned if the input is empty or invalid.
func (i *CityWhereInput) P() (predicate.City, error) {
	var predicates []predicate.City
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, city.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.City, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, city.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.City, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, city.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, city.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, city.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, city.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, city.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, city.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, city.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, city.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, city.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, city.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, city.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, city.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, city.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, city.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, city.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, city.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, city.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, city.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, city.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, city.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, city.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, city.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, city.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, city.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, city.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Adcode != nil {
		predicates = append(predicates, city.AdcodeEQ(*i.Adcode))
	}
	if i.AdcodeNEQ != nil {
		predicates = append(predicates, city.AdcodeNEQ(*i.AdcodeNEQ))
	}
	if len(i.AdcodeIn) > 0 {
		predicates = append(predicates, city.AdcodeIn(i.AdcodeIn...))
	}
	if len(i.AdcodeNotIn) > 0 {
		predicates = append(predicates, city.AdcodeNotIn(i.AdcodeNotIn...))
	}
	if i.AdcodeGT != nil {
		predicates = append(predicates, city.AdcodeGT(*i.AdcodeGT))
	}
	if i.AdcodeGTE != nil {
		predicates = append(predicates, city.AdcodeGTE(*i.AdcodeGTE))
	}
	if i.AdcodeLT != nil {
		predicates = append(predicates, city.AdcodeLT(*i.AdcodeLT))
	}
	if i.AdcodeLTE != nil {
		predicates = append(predicates, city.AdcodeLTE(*i.AdcodeLTE))
	}
	if i.ProvCode != nil {
		predicates = append(predicates, city.ProvCodeEQ(*i.ProvCode))
	}
	if i.ProvCodeNEQ != nil {
		predicates = append(predicates, city.ProvCodeNEQ(*i.ProvCodeNEQ))
	}
	if len(i.ProvCodeIn) > 0 {
		predicates = append(predicates, city.ProvCodeIn(i.ProvCodeIn...))
	}
	if len(i.ProvCodeNotIn) > 0 {
		predicates = append(predicates, city.ProvCodeNotIn(i.ProvCodeNotIn...))
	}
	if i.ProvCodeGT != nil {
		predicates = append(predicates, city.ProvCodeGT(*i.ProvCodeGT))
	}
	if i.ProvCodeGTE != nil {
		predicates = append(predicates, city.ProvCodeGTE(*i.ProvCodeGTE))
	}
	if i.ProvCodeLT != nil {
		predicates = append(predicates, city.ProvCodeLT(*i.ProvCodeLT))
	}
	if i.ProvCodeLTE != nil {
		predicates = append(predicates, city.ProvCodeLTE(*i.ProvCodeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, city.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, city.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, city.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, city.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, city.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, city.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, city.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, city.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, city.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, city.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, city.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, city.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, city.NameContainsFold(*i.NameContainsFold))
	}
	if i.ProvinceID != nil {
		predicates = append(predicates, city.ProvinceIDEQ(*i.ProvinceID))
	}
	if i.ProvinceIDNEQ != nil {
		predicates = append(predicates, city.ProvinceIDNEQ(*i.ProvinceIDNEQ))
	}
	if len(i.ProvinceIDIn) > 0 {
		predicates = append(predicates, city.ProvinceIDIn(i.ProvinceIDIn...))
	}
	if len(i.ProvinceIDNotIn) > 0 {
		predicates = append(predicates, city.ProvinceIDNotIn(i.ProvinceIDNotIn...))
	}
	if i.ProvinceIDGT != nil {
		predicates = append(predicates, city.ProvinceIDGT(*i.ProvinceIDGT))
	}
	if i.ProvinceIDGTE != nil {
		predicates = append(predicates, city.ProvinceIDGTE(*i.ProvinceIDGTE))
	}
	if i.ProvinceIDLT != nil {
		predicates = append(predicates, city.ProvinceIDLT(*i.ProvinceIDLT))
	}
	if i.ProvinceIDLTE != nil {
		predicates = append(predicates, city.ProvinceIDLTE(*i.ProvinceIDLTE))
	}
	if i.ProvinceIDContains != nil {
		predicates = append(predicates, city.ProvinceIDContains(*i.ProvinceIDContains))
	}
	if i.ProvinceIDHasPrefix != nil {
		predicates = append(predicates, city.ProvinceIDHasPrefix(*i.ProvinceIDHasPrefix))
	}
	if i.ProvinceIDHasSuffix != nil {
		predicates = append(predicates, city.ProvinceIDHasSuffix(*i.ProvinceIDHasSuffix))
	}
	if i.ProvinceIDEqualFold != nil {
		predicates = append(predicates, city.ProvinceIDEqualFold(*i.ProvinceIDEqualFold))
	}
	if i.ProvinceIDContainsFold != nil {
		predicates = append(predicates, city.ProvinceIDContainsFold(*i.ProvinceIDContainsFold))
	}

	if i.HasDistricts != nil {
		p := city.HasDistricts()
		if !*i.HasDistricts {
			p = city.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictsWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictsWith))
		for _, w := range i.HasDistrictsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, city.HasDistrictsWith(with...))
	}
	if i.HasProvince != nil {
		p := city.HasProvince()
		if !*i.HasProvince {
			p = city.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProvinceWith) > 0 {
		with := make([]predicate.Province, 0, len(i.HasProvinceWith))
		for _, w := range i.HasProvinceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProvinceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, city.HasProvinceWith(with...))
	}
	if i.HasTenders != nil {
		p := city.HasTenders()
		if !*i.HasTenders {
			p = city.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, city.HasTendersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return city.And(predicates...), nil
	}
}

// CountryWhereInput represents a where input for filtering Country queries.
type CountryWhereInput struct {
	Predicates []predicate.Country  `json:"-"`
	Not        *CountryWhereInput   `json:"not,omitempty"`
	Or         []*CountryWhereInput `json:"or,omitempty"`
	And        []*CountryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "adcode" field predicates.
	Adcode      *int  `json:"adcode,omitempty"`
	AdcodeNEQ   *int  `json:"adcodeNEQ,omitempty"`
	AdcodeIn    []int `json:"adcodeIn,omitempty"`
	AdcodeNotIn []int `json:"adcodeNotIn,omitempty"`
	AdcodeGT    *int  `json:"adcodeGT,omitempty"`
	AdcodeGTE   *int  `json:"adcodeGTE,omitempty"`
	AdcodeLT    *int  `json:"adcodeLT,omitempty"`
	AdcodeLTE   *int  `json:"adcodeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "provinces" edge predicates.
	HasProvinces     *bool                 `json:"hasProvinces,omitempty"`
	HasProvincesWith []*ProvinceWhereInput `json:"hasProvincesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryWhereInput) AddPredicates(predicates ...predicate.Country) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryWhereInput filter on the CountryQuery builder.
func (i *CountryWhereInput) Filter(q *CountryQuery) (*CountryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryWhereInput is returned in case the CountryWhereInput is empty.
var ErrEmptyCountryWhereInput = errors.New("ent: empty predicate CountryWhereInput")

// P returns a predicate for filtering countries.
// An error is returned if the input is empty or invalid.
func (i *CountryWhereInput) P() (predicate.Country, error) {
	var predicates []predicate.Country
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, country.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Country, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, country.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Country, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, country.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, country.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, country.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, country.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, country.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, country.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, country.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, country.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, country.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, country.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, country.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, country.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, country.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, country.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, country.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, country.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, country.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, country.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, country.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, country.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, country.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, country.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, country.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, country.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, country.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Adcode != nil {
		predicates = append(predicates, country.AdcodeEQ(*i.Adcode))
	}
	if i.AdcodeNEQ != nil {
		predicates = append(predicates, country.AdcodeNEQ(*i.AdcodeNEQ))
	}
	if len(i.AdcodeIn) > 0 {
		predicates = append(predicates, country.AdcodeIn(i.AdcodeIn...))
	}
	if len(i.AdcodeNotIn) > 0 {
		predicates = append(predicates, country.AdcodeNotIn(i.AdcodeNotIn...))
	}
	if i.AdcodeGT != nil {
		predicates = append(predicates, country.AdcodeGT(*i.AdcodeGT))
	}
	if i.AdcodeGTE != nil {
		predicates = append(predicates, country.AdcodeGTE(*i.AdcodeGTE))
	}
	if i.AdcodeLT != nil {
		predicates = append(predicates, country.AdcodeLT(*i.AdcodeLT))
	}
	if i.AdcodeLTE != nil {
		predicates = append(predicates, country.AdcodeLTE(*i.AdcodeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, country.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, country.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, country.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, country.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, country.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, country.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, country.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, country.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, country.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, country.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, country.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, country.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, country.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasProvinces != nil {
		p := country.HasProvinces()
		if !*i.HasProvinces {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProvincesWith) > 0 {
		with := make([]predicate.Province, 0, len(i.HasProvincesWith))
		for _, w := range i.HasProvincesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProvincesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasProvincesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return country.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "owner_type" field predicates.
	OwnerType       *int  `json:"ownerType,omitempty"`
	OwnerTypeNEQ    *int  `json:"ownerTypeNEQ,omitempty"`
	OwnerTypeIn     []int `json:"ownerTypeIn,omitempty"`
	OwnerTypeNotIn  []int `json:"ownerTypeNotIn,omitempty"`
	OwnerTypeGT     *int  `json:"ownerTypeGT,omitempty"`
	OwnerTypeGTE    *int  `json:"ownerTypeGTE,omitempty"`
	OwnerTypeLT     *int  `json:"ownerTypeLT,omitempty"`
	OwnerTypeLTE    *int  `json:"ownerTypeLTE,omitempty"`
	OwnerTypeIsNil  bool  `json:"ownerTypeIsNil,omitempty"`
	OwnerTypeNotNil bool  `json:"ownerTypeNotNil,omitempty"`

	// "industry" field predicates.
	Industry       *int  `json:"industry,omitempty"`
	IndustryNEQ    *int  `json:"industryNEQ,omitempty"`
	IndustryIn     []int `json:"industryIn,omitempty"`
	IndustryNotIn  []int `json:"industryNotIn,omitempty"`
	IndustryGT     *int  `json:"industryGT,omitempty"`
	IndustryGTE    *int  `json:"industryGTE,omitempty"`
	IndustryLT     *int  `json:"industryLT,omitempty"`
	IndustryLTE    *int  `json:"industryLTE,omitempty"`
	IndustryIsNil  bool  `json:"industryIsNil,omitempty"`
	IndustryNotNil bool  `json:"industryNotNil,omitempty"`

	// "size" field predicates.
	Size       *int  `json:"size,omitempty"`
	SizeNEQ    *int  `json:"sizeNEQ,omitempty"`
	SizeIn     []int `json:"sizeIn,omitempty"`
	SizeNotIn  []int `json:"sizeNotIn,omitempty"`
	SizeGT     *int  `json:"sizeGT,omitempty"`
	SizeGTE    *int  `json:"sizeGTE,omitempty"`
	SizeLT     *int  `json:"sizeLT,omitempty"`
	SizeLTE    *int  `json:"sizeLTE,omitempty"`
	SizeIsNil  bool  `json:"sizeIsNil,omitempty"`
	SizeNotNil bool  `json:"sizeNotNil,omitempty"`

	// "contact_person" field predicates.
	ContactPerson             *string  `json:"contactPerson,omitempty"`
	ContactPersonNEQ          *string  `json:"contactPersonNEQ,omitempty"`
	ContactPersonIn           []string `json:"contactPersonIn,omitempty"`
	ContactPersonNotIn        []string `json:"contactPersonNotIn,omitempty"`
	ContactPersonGT           *string  `json:"contactPersonGT,omitempty"`
	ContactPersonGTE          *string  `json:"contactPersonGTE,omitempty"`
	ContactPersonLT           *string  `json:"contactPersonLT,omitempty"`
	ContactPersonLTE          *string  `json:"contactPersonLTE,omitempty"`
	ContactPersonContains     *string  `json:"contactPersonContains,omitempty"`
	ContactPersonHasPrefix    *string  `json:"contactPersonHasPrefix,omitempty"`
	ContactPersonHasSuffix    *string  `json:"contactPersonHasSuffix,omitempty"`
	ContactPersonIsNil        bool     `json:"contactPersonIsNil,omitempty"`
	ContactPersonNotNil       bool     `json:"contactPersonNotNil,omitempty"`
	ContactPersonEqualFold    *string  `json:"contactPersonEqualFold,omitempty"`
	ContactPersonContainsFold *string  `json:"contactPersonContainsFold,omitempty"`

	// "contact_person_position" field predicates.
	ContactPersonPosition             *string  `json:"contactPersonPosition,omitempty"`
	ContactPersonPositionNEQ          *string  `json:"contactPersonPositionNEQ,omitempty"`
	ContactPersonPositionIn           []string `json:"contactPersonPositionIn,omitempty"`
	ContactPersonPositionNotIn        []string `json:"contactPersonPositionNotIn,omitempty"`
	ContactPersonPositionGT           *string  `json:"contactPersonPositionGT,omitempty"`
	ContactPersonPositionGTE          *string  `json:"contactPersonPositionGTE,omitempty"`
	ContactPersonPositionLT           *string  `json:"contactPersonPositionLT,omitempty"`
	ContactPersonPositionLTE          *string  `json:"contactPersonPositionLTE,omitempty"`
	ContactPersonPositionContains     *string  `json:"contactPersonPositionContains,omitempty"`
	ContactPersonPositionHasPrefix    *string  `json:"contactPersonPositionHasPrefix,omitempty"`
	ContactPersonPositionHasSuffix    *string  `json:"contactPersonPositionHasSuffix,omitempty"`
	ContactPersonPositionIsNil        bool     `json:"contactPersonPositionIsNil,omitempty"`
	ContactPersonPositionNotNil       bool     `json:"contactPersonPositionNotNil,omitempty"`
	ContactPersonPositionEqualFold    *string  `json:"contactPersonPositionEqualFold,omitempty"`
	ContactPersonPositionContainsFold *string  `json:"contactPersonPositionContainsFold,omitempty"`

	// "contact_person_phone" field predicates.
	ContactPersonPhone             *string  `json:"contactPersonPhone,omitempty"`
	ContactPersonPhoneNEQ          *string  `json:"contactPersonPhoneNEQ,omitempty"`
	ContactPersonPhoneIn           []string `json:"contactPersonPhoneIn,omitempty"`
	ContactPersonPhoneNotIn        []string `json:"contactPersonPhoneNotIn,omitempty"`
	ContactPersonPhoneGT           *string  `json:"contactPersonPhoneGT,omitempty"`
	ContactPersonPhoneGTE          *string  `json:"contactPersonPhoneGTE,omitempty"`
	ContactPersonPhoneLT           *string  `json:"contactPersonPhoneLT,omitempty"`
	ContactPersonPhoneLTE          *string  `json:"contactPersonPhoneLTE,omitempty"`
	ContactPersonPhoneContains     *string  `json:"contactPersonPhoneContains,omitempty"`
	ContactPersonPhoneHasPrefix    *string  `json:"contactPersonPhoneHasPrefix,omitempty"`
	ContactPersonPhoneHasSuffix    *string  `json:"contactPersonPhoneHasSuffix,omitempty"`
	ContactPersonPhoneIsNil        bool     `json:"contactPersonPhoneIsNil,omitempty"`
	ContactPersonPhoneNotNil       bool     `json:"contactPersonPhoneNotNil,omitempty"`
	ContactPersonPhoneEqualFold    *string  `json:"contactPersonPhoneEqualFold,omitempty"`
	ContactPersonPhoneContainsFold *string  `json:"contactPersonPhoneContainsFold,omitempty"`

	// "contact_person_email" field predicates.
	ContactPersonEmail             *string  `json:"contactPersonEmail,omitempty"`
	ContactPersonEmailNEQ          *string  `json:"contactPersonEmailNEQ,omitempty"`
	ContactPersonEmailIn           []string `json:"contactPersonEmailIn,omitempty"`
	ContactPersonEmailNotIn        []string `json:"contactPersonEmailNotIn,omitempty"`
	ContactPersonEmailGT           *string  `json:"contactPersonEmailGT,omitempty"`
	ContactPersonEmailGTE          *string  `json:"contactPersonEmailGTE,omitempty"`
	ContactPersonEmailLT           *string  `json:"contactPersonEmailLT,omitempty"`
	ContactPersonEmailLTE          *string  `json:"contactPersonEmailLTE,omitempty"`
	ContactPersonEmailContains     *string  `json:"contactPersonEmailContains,omitempty"`
	ContactPersonEmailHasPrefix    *string  `json:"contactPersonEmailHasPrefix,omitempty"`
	ContactPersonEmailHasSuffix    *string  `json:"contactPersonEmailHasSuffix,omitempty"`
	ContactPersonEmailIsNil        bool     `json:"contactPersonEmailIsNil,omitempty"`
	ContactPersonEmailNotNil       bool     `json:"contactPersonEmailNotNil,omitempty"`
	ContactPersonEmailEqualFold    *string  `json:"contactPersonEmailEqualFold,omitempty"`
	ContactPersonEmailContainsFold *string  `json:"contactPersonEmailContainsFold,omitempty"`

	// "area_id" field predicates.
	AreaID             *xid.ID  `json:"areaID,omitempty"`
	AreaIDNEQ          *xid.ID  `json:"areaIDNEQ,omitempty"`
	AreaIDIn           []xid.ID `json:"areaIDIn,omitempty"`
	AreaIDNotIn        []xid.ID `json:"areaIDNotIn,omitempty"`
	AreaIDGT           *xid.ID  `json:"areaIDGT,omitempty"`
	AreaIDGTE          *xid.ID  `json:"areaIDGTE,omitempty"`
	AreaIDLT           *xid.ID  `json:"areaIDLT,omitempty"`
	AreaIDLTE          *xid.ID  `json:"areaIDLTE,omitempty"`
	AreaIDContains     *xid.ID  `json:"areaIDContains,omitempty"`
	AreaIDHasPrefix    *xid.ID  `json:"areaIDHasPrefix,omitempty"`
	AreaIDHasSuffix    *xid.ID  `json:"areaIDHasSuffix,omitempty"`
	AreaIDEqualFold    *xid.ID  `json:"areaIDEqualFold,omitempty"`
	AreaIDContainsFold *xid.ID  `json:"areaIDContainsFold,omitempty"`

	// "sales_id" field predicates.
	SalesID             *xid.ID  `json:"salesID,omitempty"`
	SalesIDNEQ          *xid.ID  `json:"salesIDNEQ,omitempty"`
	SalesIDIn           []xid.ID `json:"salesIDIn,omitempty"`
	SalesIDNotIn        []xid.ID `json:"salesIDNotIn,omitempty"`
	SalesIDGT           *xid.ID  `json:"salesIDGT,omitempty"`
	SalesIDGTE          *xid.ID  `json:"salesIDGTE,omitempty"`
	SalesIDLT           *xid.ID  `json:"salesIDLT,omitempty"`
	SalesIDLTE          *xid.ID  `json:"salesIDLTE,omitempty"`
	SalesIDContains     *xid.ID  `json:"salesIDContains,omitempty"`
	SalesIDHasPrefix    *xid.ID  `json:"salesIDHasPrefix,omitempty"`
	SalesIDHasSuffix    *xid.ID  `json:"salesIDHasSuffix,omitempty"`
	SalesIDIsNil        bool     `json:"salesIDIsNil,omitempty"`
	SalesIDNotNil       bool     `json:"salesIDNotNil,omitempty"`
	SalesIDEqualFold    *xid.ID  `json:"salesIDEqualFold,omitempty"`
	SalesIDContainsFold *xid.ID  `json:"salesIDContainsFold,omitempty"`

	// "created_by_id" field predicates.
	CreatedByID             *xid.ID  `json:"createdByID,omitempty"`
	CreatedByIDNEQ          *xid.ID  `json:"createdByIDNEQ,omitempty"`
	CreatedByIDIn           []xid.ID `json:"createdByIDIn,omitempty"`
	CreatedByIDNotIn        []xid.ID `json:"createdByIDNotIn,omitempty"`
	CreatedByIDGT           *xid.ID  `json:"createdByIDGT,omitempty"`
	CreatedByIDGTE          *xid.ID  `json:"createdByIDGTE,omitempty"`
	CreatedByIDLT           *xid.ID  `json:"createdByIDLT,omitempty"`
	CreatedByIDLTE          *xid.ID  `json:"createdByIDLTE,omitempty"`
	CreatedByIDContains     *xid.ID  `json:"createdByIDContains,omitempty"`
	CreatedByIDHasPrefix    *xid.ID  `json:"createdByIDHasPrefix,omitempty"`
	CreatedByIDHasSuffix    *xid.ID  `json:"createdByIDHasSuffix,omitempty"`
	CreatedByIDEqualFold    *xid.ID  `json:"createdByIDEqualFold,omitempty"`
	CreatedByIDContainsFold *xid.ID  `json:"createdByIDContainsFold,omitempty"`

	// "area" edge predicates.
	HasArea     *bool             `json:"hasArea,omitempty"`
	HasAreaWith []*AreaWhereInput `json:"hasAreaWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`

	// "sales" edge predicates.
	HasSales     *bool             `json:"hasSales,omitempty"`
	HasSalesWith []*UserWhereInput `json:"hasSalesWith,omitempty"`

	// "created_by" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "visit_records" edge predicates.
	HasVisitRecords     *bool                    `json:"hasVisitRecords,omitempty"`
	HasVisitRecordsWith []*VisitRecordWhereInput `json:"hasVisitRecordsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("ent: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, customer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, customer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, customer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, customer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, customer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, customer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, customer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, customer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, customer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, customer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, customer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, customer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, customer.NameContainsFold(*i.NameContainsFold))
	}
	if i.OwnerType != nil {
		predicates = append(predicates, customer.OwnerTypeEQ(*i.OwnerType))
	}
	if i.OwnerTypeNEQ != nil {
		predicates = append(predicates, customer.OwnerTypeNEQ(*i.OwnerTypeNEQ))
	}
	if len(i.OwnerTypeIn) > 0 {
		predicates = append(predicates, customer.OwnerTypeIn(i.OwnerTypeIn...))
	}
	if len(i.OwnerTypeNotIn) > 0 {
		predicates = append(predicates, customer.OwnerTypeNotIn(i.OwnerTypeNotIn...))
	}
	if i.OwnerTypeGT != nil {
		predicates = append(predicates, customer.OwnerTypeGT(*i.OwnerTypeGT))
	}
	if i.OwnerTypeGTE != nil {
		predicates = append(predicates, customer.OwnerTypeGTE(*i.OwnerTypeGTE))
	}
	if i.OwnerTypeLT != nil {
		predicates = append(predicates, customer.OwnerTypeLT(*i.OwnerTypeLT))
	}
	if i.OwnerTypeLTE != nil {
		predicates = append(predicates, customer.OwnerTypeLTE(*i.OwnerTypeLTE))
	}
	if i.OwnerTypeIsNil {
		predicates = append(predicates, customer.OwnerTypeIsNil())
	}
	if i.OwnerTypeNotNil {
		predicates = append(predicates, customer.OwnerTypeNotNil())
	}
	if i.Industry != nil {
		predicates = append(predicates, customer.IndustryEQ(*i.Industry))
	}
	if i.IndustryNEQ != nil {
		predicates = append(predicates, customer.IndustryNEQ(*i.IndustryNEQ))
	}
	if len(i.IndustryIn) > 0 {
		predicates = append(predicates, customer.IndustryIn(i.IndustryIn...))
	}
	if len(i.IndustryNotIn) > 0 {
		predicates = append(predicates, customer.IndustryNotIn(i.IndustryNotIn...))
	}
	if i.IndustryGT != nil {
		predicates = append(predicates, customer.IndustryGT(*i.IndustryGT))
	}
	if i.IndustryGTE != nil {
		predicates = append(predicates, customer.IndustryGTE(*i.IndustryGTE))
	}
	if i.IndustryLT != nil {
		predicates = append(predicates, customer.IndustryLT(*i.IndustryLT))
	}
	if i.IndustryLTE != nil {
		predicates = append(predicates, customer.IndustryLTE(*i.IndustryLTE))
	}
	if i.IndustryIsNil {
		predicates = append(predicates, customer.IndustryIsNil())
	}
	if i.IndustryNotNil {
		predicates = append(predicates, customer.IndustryNotNil())
	}
	if i.Size != nil {
		predicates = append(predicates, customer.SizeEQ(*i.Size))
	}
	if i.SizeNEQ != nil {
		predicates = append(predicates, customer.SizeNEQ(*i.SizeNEQ))
	}
	if len(i.SizeIn) > 0 {
		predicates = append(predicates, customer.SizeIn(i.SizeIn...))
	}
	if len(i.SizeNotIn) > 0 {
		predicates = append(predicates, customer.SizeNotIn(i.SizeNotIn...))
	}
	if i.SizeGT != nil {
		predicates = append(predicates, customer.SizeGT(*i.SizeGT))
	}
	if i.SizeGTE != nil {
		predicates = append(predicates, customer.SizeGTE(*i.SizeGTE))
	}
	if i.SizeLT != nil {
		predicates = append(predicates, customer.SizeLT(*i.SizeLT))
	}
	if i.SizeLTE != nil {
		predicates = append(predicates, customer.SizeLTE(*i.SizeLTE))
	}
	if i.SizeIsNil {
		predicates = append(predicates, customer.SizeIsNil())
	}
	if i.SizeNotNil {
		predicates = append(predicates, customer.SizeNotNil())
	}
	if i.ContactPerson != nil {
		predicates = append(predicates, customer.ContactPersonEQ(*i.ContactPerson))
	}
	if i.ContactPersonNEQ != nil {
		predicates = append(predicates, customer.ContactPersonNEQ(*i.ContactPersonNEQ))
	}
	if len(i.ContactPersonIn) > 0 {
		predicates = append(predicates, customer.ContactPersonIn(i.ContactPersonIn...))
	}
	if len(i.ContactPersonNotIn) > 0 {
		predicates = append(predicates, customer.ContactPersonNotIn(i.ContactPersonNotIn...))
	}
	if i.ContactPersonGT != nil {
		predicates = append(predicates, customer.ContactPersonGT(*i.ContactPersonGT))
	}
	if i.ContactPersonGTE != nil {
		predicates = append(predicates, customer.ContactPersonGTE(*i.ContactPersonGTE))
	}
	if i.ContactPersonLT != nil {
		predicates = append(predicates, customer.ContactPersonLT(*i.ContactPersonLT))
	}
	if i.ContactPersonLTE != nil {
		predicates = append(predicates, customer.ContactPersonLTE(*i.ContactPersonLTE))
	}
	if i.ContactPersonContains != nil {
		predicates = append(predicates, customer.ContactPersonContains(*i.ContactPersonContains))
	}
	if i.ContactPersonHasPrefix != nil {
		predicates = append(predicates, customer.ContactPersonHasPrefix(*i.ContactPersonHasPrefix))
	}
	if i.ContactPersonHasSuffix != nil {
		predicates = append(predicates, customer.ContactPersonHasSuffix(*i.ContactPersonHasSuffix))
	}
	if i.ContactPersonIsNil {
		predicates = append(predicates, customer.ContactPersonIsNil())
	}
	if i.ContactPersonNotNil {
		predicates = append(predicates, customer.ContactPersonNotNil())
	}
	if i.ContactPersonEqualFold != nil {
		predicates = append(predicates, customer.ContactPersonEqualFold(*i.ContactPersonEqualFold))
	}
	if i.ContactPersonContainsFold != nil {
		predicates = append(predicates, customer.ContactPersonContainsFold(*i.ContactPersonContainsFold))
	}
	if i.ContactPersonPosition != nil {
		predicates = append(predicates, customer.ContactPersonPositionEQ(*i.ContactPersonPosition))
	}
	if i.ContactPersonPositionNEQ != nil {
		predicates = append(predicates, customer.ContactPersonPositionNEQ(*i.ContactPersonPositionNEQ))
	}
	if len(i.ContactPersonPositionIn) > 0 {
		predicates = append(predicates, customer.ContactPersonPositionIn(i.ContactPersonPositionIn...))
	}
	if len(i.ContactPersonPositionNotIn) > 0 {
		predicates = append(predicates, customer.ContactPersonPositionNotIn(i.ContactPersonPositionNotIn...))
	}
	if i.ContactPersonPositionGT != nil {
		predicates = append(predicates, customer.ContactPersonPositionGT(*i.ContactPersonPositionGT))
	}
	if i.ContactPersonPositionGTE != nil {
		predicates = append(predicates, customer.ContactPersonPositionGTE(*i.ContactPersonPositionGTE))
	}
	if i.ContactPersonPositionLT != nil {
		predicates = append(predicates, customer.ContactPersonPositionLT(*i.ContactPersonPositionLT))
	}
	if i.ContactPersonPositionLTE != nil {
		predicates = append(predicates, customer.ContactPersonPositionLTE(*i.ContactPersonPositionLTE))
	}
	if i.ContactPersonPositionContains != nil {
		predicates = append(predicates, customer.ContactPersonPositionContains(*i.ContactPersonPositionContains))
	}
	if i.ContactPersonPositionHasPrefix != nil {
		predicates = append(predicates, customer.ContactPersonPositionHasPrefix(*i.ContactPersonPositionHasPrefix))
	}
	if i.ContactPersonPositionHasSuffix != nil {
		predicates = append(predicates, customer.ContactPersonPositionHasSuffix(*i.ContactPersonPositionHasSuffix))
	}
	if i.ContactPersonPositionIsNil {
		predicates = append(predicates, customer.ContactPersonPositionIsNil())
	}
	if i.ContactPersonPositionNotNil {
		predicates = append(predicates, customer.ContactPersonPositionNotNil())
	}
	if i.ContactPersonPositionEqualFold != nil {
		predicates = append(predicates, customer.ContactPersonPositionEqualFold(*i.ContactPersonPositionEqualFold))
	}
	if i.ContactPersonPositionContainsFold != nil {
		predicates = append(predicates, customer.ContactPersonPositionContainsFold(*i.ContactPersonPositionContainsFold))
	}
	if i.ContactPersonPhone != nil {
		predicates = append(predicates, customer.ContactPersonPhoneEQ(*i.ContactPersonPhone))
	}
	if i.ContactPersonPhoneNEQ != nil {
		predicates = append(predicates, customer.ContactPersonPhoneNEQ(*i.ContactPersonPhoneNEQ))
	}
	if len(i.ContactPersonPhoneIn) > 0 {
		predicates = append(predicates, customer.ContactPersonPhoneIn(i.ContactPersonPhoneIn...))
	}
	if len(i.ContactPersonPhoneNotIn) > 0 {
		predicates = append(predicates, customer.ContactPersonPhoneNotIn(i.ContactPersonPhoneNotIn...))
	}
	if i.ContactPersonPhoneGT != nil {
		predicates = append(predicates, customer.ContactPersonPhoneGT(*i.ContactPersonPhoneGT))
	}
	if i.ContactPersonPhoneGTE != nil {
		predicates = append(predicates, customer.ContactPersonPhoneGTE(*i.ContactPersonPhoneGTE))
	}
	if i.ContactPersonPhoneLT != nil {
		predicates = append(predicates, customer.ContactPersonPhoneLT(*i.ContactPersonPhoneLT))
	}
	if i.ContactPersonPhoneLTE != nil {
		predicates = append(predicates, customer.ContactPersonPhoneLTE(*i.ContactPersonPhoneLTE))
	}
	if i.ContactPersonPhoneContains != nil {
		predicates = append(predicates, customer.ContactPersonPhoneContains(*i.ContactPersonPhoneContains))
	}
	if i.ContactPersonPhoneHasPrefix != nil {
		predicates = append(predicates, customer.ContactPersonPhoneHasPrefix(*i.ContactPersonPhoneHasPrefix))
	}
	if i.ContactPersonPhoneHasSuffix != nil {
		predicates = append(predicates, customer.ContactPersonPhoneHasSuffix(*i.ContactPersonPhoneHasSuffix))
	}
	if i.ContactPersonPhoneIsNil {
		predicates = append(predicates, customer.ContactPersonPhoneIsNil())
	}
	if i.ContactPersonPhoneNotNil {
		predicates = append(predicates, customer.ContactPersonPhoneNotNil())
	}
	if i.ContactPersonPhoneEqualFold != nil {
		predicates = append(predicates, customer.ContactPersonPhoneEqualFold(*i.ContactPersonPhoneEqualFold))
	}
	if i.ContactPersonPhoneContainsFold != nil {
		predicates = append(predicates, customer.ContactPersonPhoneContainsFold(*i.ContactPersonPhoneContainsFold))
	}
	if i.ContactPersonEmail != nil {
		predicates = append(predicates, customer.ContactPersonEmailEQ(*i.ContactPersonEmail))
	}
	if i.ContactPersonEmailNEQ != nil {
		predicates = append(predicates, customer.ContactPersonEmailNEQ(*i.ContactPersonEmailNEQ))
	}
	if len(i.ContactPersonEmailIn) > 0 {
		predicates = append(predicates, customer.ContactPersonEmailIn(i.ContactPersonEmailIn...))
	}
	if len(i.ContactPersonEmailNotIn) > 0 {
		predicates = append(predicates, customer.ContactPersonEmailNotIn(i.ContactPersonEmailNotIn...))
	}
	if i.ContactPersonEmailGT != nil {
		predicates = append(predicates, customer.ContactPersonEmailGT(*i.ContactPersonEmailGT))
	}
	if i.ContactPersonEmailGTE != nil {
		predicates = append(predicates, customer.ContactPersonEmailGTE(*i.ContactPersonEmailGTE))
	}
	if i.ContactPersonEmailLT != nil {
		predicates = append(predicates, customer.ContactPersonEmailLT(*i.ContactPersonEmailLT))
	}
	if i.ContactPersonEmailLTE != nil {
		predicates = append(predicates, customer.ContactPersonEmailLTE(*i.ContactPersonEmailLTE))
	}
	if i.ContactPersonEmailContains != nil {
		predicates = append(predicates, customer.ContactPersonEmailContains(*i.ContactPersonEmailContains))
	}
	if i.ContactPersonEmailHasPrefix != nil {
		predicates = append(predicates, customer.ContactPersonEmailHasPrefix(*i.ContactPersonEmailHasPrefix))
	}
	if i.ContactPersonEmailHasSuffix != nil {
		predicates = append(predicates, customer.ContactPersonEmailHasSuffix(*i.ContactPersonEmailHasSuffix))
	}
	if i.ContactPersonEmailIsNil {
		predicates = append(predicates, customer.ContactPersonEmailIsNil())
	}
	if i.ContactPersonEmailNotNil {
		predicates = append(predicates, customer.ContactPersonEmailNotNil())
	}
	if i.ContactPersonEmailEqualFold != nil {
		predicates = append(predicates, customer.ContactPersonEmailEqualFold(*i.ContactPersonEmailEqualFold))
	}
	if i.ContactPersonEmailContainsFold != nil {
		predicates = append(predicates, customer.ContactPersonEmailContainsFold(*i.ContactPersonEmailContainsFold))
	}
	if i.AreaID != nil {
		predicates = append(predicates, customer.AreaIDEQ(*i.AreaID))
	}
	if i.AreaIDNEQ != nil {
		predicates = append(predicates, customer.AreaIDNEQ(*i.AreaIDNEQ))
	}
	if len(i.AreaIDIn) > 0 {
		predicates = append(predicates, customer.AreaIDIn(i.AreaIDIn...))
	}
	if len(i.AreaIDNotIn) > 0 {
		predicates = append(predicates, customer.AreaIDNotIn(i.AreaIDNotIn...))
	}
	if i.AreaIDGT != nil {
		predicates = append(predicates, customer.AreaIDGT(*i.AreaIDGT))
	}
	if i.AreaIDGTE != nil {
		predicates = append(predicates, customer.AreaIDGTE(*i.AreaIDGTE))
	}
	if i.AreaIDLT != nil {
		predicates = append(predicates, customer.AreaIDLT(*i.AreaIDLT))
	}
	if i.AreaIDLTE != nil {
		predicates = append(predicates, customer.AreaIDLTE(*i.AreaIDLTE))
	}
	if i.AreaIDContains != nil {
		predicates = append(predicates, customer.AreaIDContains(*i.AreaIDContains))
	}
	if i.AreaIDHasPrefix != nil {
		predicates = append(predicates, customer.AreaIDHasPrefix(*i.AreaIDHasPrefix))
	}
	if i.AreaIDHasSuffix != nil {
		predicates = append(predicates, customer.AreaIDHasSuffix(*i.AreaIDHasSuffix))
	}
	if i.AreaIDEqualFold != nil {
		predicates = append(predicates, customer.AreaIDEqualFold(*i.AreaIDEqualFold))
	}
	if i.AreaIDContainsFold != nil {
		predicates = append(predicates, customer.AreaIDContainsFold(*i.AreaIDContainsFold))
	}
	if i.SalesID != nil {
		predicates = append(predicates, customer.SalesIDEQ(*i.SalesID))
	}
	if i.SalesIDNEQ != nil {
		predicates = append(predicates, customer.SalesIDNEQ(*i.SalesIDNEQ))
	}
	if len(i.SalesIDIn) > 0 {
		predicates = append(predicates, customer.SalesIDIn(i.SalesIDIn...))
	}
	if len(i.SalesIDNotIn) > 0 {
		predicates = append(predicates, customer.SalesIDNotIn(i.SalesIDNotIn...))
	}
	if i.SalesIDGT != nil {
		predicates = append(predicates, customer.SalesIDGT(*i.SalesIDGT))
	}
	if i.SalesIDGTE != nil {
		predicates = append(predicates, customer.SalesIDGTE(*i.SalesIDGTE))
	}
	if i.SalesIDLT != nil {
		predicates = append(predicates, customer.SalesIDLT(*i.SalesIDLT))
	}
	if i.SalesIDLTE != nil {
		predicates = append(predicates, customer.SalesIDLTE(*i.SalesIDLTE))
	}
	if i.SalesIDContains != nil {
		predicates = append(predicates, customer.SalesIDContains(*i.SalesIDContains))
	}
	if i.SalesIDHasPrefix != nil {
		predicates = append(predicates, customer.SalesIDHasPrefix(*i.SalesIDHasPrefix))
	}
	if i.SalesIDHasSuffix != nil {
		predicates = append(predicates, customer.SalesIDHasSuffix(*i.SalesIDHasSuffix))
	}
	if i.SalesIDIsNil {
		predicates = append(predicates, customer.SalesIDIsNil())
	}
	if i.SalesIDNotNil {
		predicates = append(predicates, customer.SalesIDNotNil())
	}
	if i.SalesIDEqualFold != nil {
		predicates = append(predicates, customer.SalesIDEqualFold(*i.SalesIDEqualFold))
	}
	if i.SalesIDContainsFold != nil {
		predicates = append(predicates, customer.SalesIDContainsFold(*i.SalesIDContainsFold))
	}
	if i.CreatedByID != nil {
		predicates = append(predicates, customer.CreatedByIDEQ(*i.CreatedByID))
	}
	if i.CreatedByIDNEQ != nil {
		predicates = append(predicates, customer.CreatedByIDNEQ(*i.CreatedByIDNEQ))
	}
	if len(i.CreatedByIDIn) > 0 {
		predicates = append(predicates, customer.CreatedByIDIn(i.CreatedByIDIn...))
	}
	if len(i.CreatedByIDNotIn) > 0 {
		predicates = append(predicates, customer.CreatedByIDNotIn(i.CreatedByIDNotIn...))
	}
	if i.CreatedByIDGT != nil {
		predicates = append(predicates, customer.CreatedByIDGT(*i.CreatedByIDGT))
	}
	if i.CreatedByIDGTE != nil {
		predicates = append(predicates, customer.CreatedByIDGTE(*i.CreatedByIDGTE))
	}
	if i.CreatedByIDLT != nil {
		predicates = append(predicates, customer.CreatedByIDLT(*i.CreatedByIDLT))
	}
	if i.CreatedByIDLTE != nil {
		predicates = append(predicates, customer.CreatedByIDLTE(*i.CreatedByIDLTE))
	}
	if i.CreatedByIDContains != nil {
		predicates = append(predicates, customer.CreatedByIDContains(*i.CreatedByIDContains))
	}
	if i.CreatedByIDHasPrefix != nil {
		predicates = append(predicates, customer.CreatedByIDHasPrefix(*i.CreatedByIDHasPrefix))
	}
	if i.CreatedByIDHasSuffix != nil {
		predicates = append(predicates, customer.CreatedByIDHasSuffix(*i.CreatedByIDHasSuffix))
	}
	if i.CreatedByIDEqualFold != nil {
		predicates = append(predicates, customer.CreatedByIDEqualFold(*i.CreatedByIDEqualFold))
	}
	if i.CreatedByIDContainsFold != nil {
		predicates = append(predicates, customer.CreatedByIDContainsFold(*i.CreatedByIDContainsFold))
	}

	if i.HasArea != nil {
		p := customer.HasArea()
		if !*i.HasArea {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAreaWith) > 0 {
		with := make([]predicate.Area, 0, len(i.HasAreaWith))
		for _, w := range i.HasAreaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAreaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasAreaWith(with...))
	}
	if i.HasTenders != nil {
		p := customer.HasTenders()
		if !*i.HasTenders {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasTendersWith(with...))
	}
	if i.HasSales != nil {
		p := customer.HasSales()
		if !*i.HasSales {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSalesWith))
		for _, w := range i.HasSalesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasSalesWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := customer.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasCreatedByWith(with...))
	}
	if i.HasVisitRecords != nil {
		p := customer.HasVisitRecords()
		if !*i.HasVisitRecords {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVisitRecordsWith) > 0 {
		with := make([]predicate.VisitRecord, 0, len(i.HasVisitRecordsWith))
		for _, w := range i.HasVisitRecordsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVisitRecordsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasVisitRecordsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// DistrictWhereInput represents a where input for filtering District queries.
type DistrictWhereInput struct {
	Predicates []predicate.District  `json:"-"`
	Not        *DistrictWhereInput   `json:"not,omitempty"`
	Or         []*DistrictWhereInput `json:"or,omitempty"`
	And        []*DistrictWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "adcode" field predicates.
	Adcode      *int  `json:"adcode,omitempty"`
	AdcodeNEQ   *int  `json:"adcodeNEQ,omitempty"`
	AdcodeIn    []int `json:"adcodeIn,omitempty"`
	AdcodeNotIn []int `json:"adcodeNotIn,omitempty"`
	AdcodeGT    *int  `json:"adcodeGT,omitempty"`
	AdcodeGTE   *int  `json:"adcodeGTE,omitempty"`
	AdcodeLT    *int  `json:"adcodeLT,omitempty"`
	AdcodeLTE   *int  `json:"adcodeLTE,omitempty"`

	// "prov_code" field predicates.
	ProvCode      *int  `json:"provCode,omitempty"`
	ProvCodeNEQ   *int  `json:"provCodeNEQ,omitempty"`
	ProvCodeIn    []int `json:"provCodeIn,omitempty"`
	ProvCodeNotIn []int `json:"provCodeNotIn,omitempty"`
	ProvCodeGT    *int  `json:"provCodeGT,omitempty"`
	ProvCodeGTE   *int  `json:"provCodeGTE,omitempty"`
	ProvCodeLT    *int  `json:"provCodeLT,omitempty"`
	ProvCodeLTE   *int  `json:"provCodeLTE,omitempty"`

	// "city_code" field predicates.
	CityCode      *int  `json:"cityCode,omitempty"`
	CityCodeNEQ   *int  `json:"cityCodeNEQ,omitempty"`
	CityCodeIn    []int `json:"cityCodeIn,omitempty"`
	CityCodeNotIn []int `json:"cityCodeNotIn,omitempty"`
	CityCodeGT    *int  `json:"cityCodeGT,omitempty"`
	CityCodeGTE   *int  `json:"cityCodeGTE,omitempty"`
	CityCodeLT    *int  `json:"cityCodeLT,omitempty"`
	CityCodeLTE   *int  `json:"cityCodeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "province_id" field predicates.
	ProvinceID             *xid.ID  `json:"provinceID,omitempty"`
	ProvinceIDNEQ          *xid.ID  `json:"provinceIDNEQ,omitempty"`
	ProvinceIDIn           []xid.ID `json:"provinceIDIn,omitempty"`
	ProvinceIDNotIn        []xid.ID `json:"provinceIDNotIn,omitempty"`
	ProvinceIDGT           *xid.ID  `json:"provinceIDGT,omitempty"`
	ProvinceIDGTE          *xid.ID  `json:"provinceIDGTE,omitempty"`
	ProvinceIDLT           *xid.ID  `json:"provinceIDLT,omitempty"`
	ProvinceIDLTE          *xid.ID  `json:"provinceIDLTE,omitempty"`
	ProvinceIDContains     *xid.ID  `json:"provinceIDContains,omitempty"`
	ProvinceIDHasPrefix    *xid.ID  `json:"provinceIDHasPrefix,omitempty"`
	ProvinceIDHasSuffix    *xid.ID  `json:"provinceIDHasSuffix,omitempty"`
	ProvinceIDEqualFold    *xid.ID  `json:"provinceIDEqualFold,omitempty"`
	ProvinceIDContainsFold *xid.ID  `json:"provinceIDContainsFold,omitempty"`

	// "city_id" field predicates.
	CityID             *xid.ID  `json:"cityID,omitempty"`
	CityIDNEQ          *xid.ID  `json:"cityIDNEQ,omitempty"`
	CityIDIn           []xid.ID `json:"cityIDIn,omitempty"`
	CityIDNotIn        []xid.ID `json:"cityIDNotIn,omitempty"`
	CityIDGT           *xid.ID  `json:"cityIDGT,omitempty"`
	CityIDGTE          *xid.ID  `json:"cityIDGTE,omitempty"`
	CityIDLT           *xid.ID  `json:"cityIDLT,omitempty"`
	CityIDLTE          *xid.ID  `json:"cityIDLTE,omitempty"`
	CityIDContains     *xid.ID  `json:"cityIDContains,omitempty"`
	CityIDHasPrefix    *xid.ID  `json:"cityIDHasPrefix,omitempty"`
	CityIDHasSuffix    *xid.ID  `json:"cityIDHasSuffix,omitempty"`
	CityIDIsNil        bool     `json:"cityIDIsNil,omitempty"`
	CityIDNotNil       bool     `json:"cityIDNotNil,omitempty"`
	CityIDEqualFold    *xid.ID  `json:"cityIDEqualFold,omitempty"`
	CityIDContainsFold *xid.ID  `json:"cityIDContainsFold,omitempty"`

	// "province" edge predicates.
	HasProvince     *bool                 `json:"hasProvince,omitempty"`
	HasProvinceWith []*ProvinceWhereInput `json:"hasProvinceWith,omitempty"`

	// "city" edge predicates.
	HasCity     *bool             `json:"hasCity,omitempty"`
	HasCityWith []*CityWhereInput `json:"hasCityWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`

	// "plots" edge predicates.
	HasPlots     *bool             `json:"hasPlots,omitempty"`
	HasPlotsWith []*PlotWhereInput `json:"hasPlotsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DistrictWhereInput) AddPredicates(predicates ...predicate.District) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DistrictWhereInput filter on the DistrictQuery builder.
func (i *DistrictWhereInput) Filter(q *DistrictQuery) (*DistrictQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDistrictWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDistrictWhereInput is returned in case the DistrictWhereInput is empty.
var ErrEmptyDistrictWhereInput = errors.New("ent: empty predicate DistrictWhereInput")

// P returns a predicate for filtering districts.
// An error is returned if the input is empty or invalid.
func (i *DistrictWhereInput) P() (predicate.District, error) {
	var predicates []predicate.District
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, district.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.District, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, district.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.District, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, district.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, district.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, district.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, district.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, district.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, district.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, district.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, district.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, district.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, district.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, district.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, district.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, district.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, district.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, district.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, district.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, district.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, district.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, district.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, district.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, district.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, district.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, district.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, district.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, district.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Adcode != nil {
		predicates = append(predicates, district.AdcodeEQ(*i.Adcode))
	}
	if i.AdcodeNEQ != nil {
		predicates = append(predicates, district.AdcodeNEQ(*i.AdcodeNEQ))
	}
	if len(i.AdcodeIn) > 0 {
		predicates = append(predicates, district.AdcodeIn(i.AdcodeIn...))
	}
	if len(i.AdcodeNotIn) > 0 {
		predicates = append(predicates, district.AdcodeNotIn(i.AdcodeNotIn...))
	}
	if i.AdcodeGT != nil {
		predicates = append(predicates, district.AdcodeGT(*i.AdcodeGT))
	}
	if i.AdcodeGTE != nil {
		predicates = append(predicates, district.AdcodeGTE(*i.AdcodeGTE))
	}
	if i.AdcodeLT != nil {
		predicates = append(predicates, district.AdcodeLT(*i.AdcodeLT))
	}
	if i.AdcodeLTE != nil {
		predicates = append(predicates, district.AdcodeLTE(*i.AdcodeLTE))
	}
	if i.ProvCode != nil {
		predicates = append(predicates, district.ProvCodeEQ(*i.ProvCode))
	}
	if i.ProvCodeNEQ != nil {
		predicates = append(predicates, district.ProvCodeNEQ(*i.ProvCodeNEQ))
	}
	if len(i.ProvCodeIn) > 0 {
		predicates = append(predicates, district.ProvCodeIn(i.ProvCodeIn...))
	}
	if len(i.ProvCodeNotIn) > 0 {
		predicates = append(predicates, district.ProvCodeNotIn(i.ProvCodeNotIn...))
	}
	if i.ProvCodeGT != nil {
		predicates = append(predicates, district.ProvCodeGT(*i.ProvCodeGT))
	}
	if i.ProvCodeGTE != nil {
		predicates = append(predicates, district.ProvCodeGTE(*i.ProvCodeGTE))
	}
	if i.ProvCodeLT != nil {
		predicates = append(predicates, district.ProvCodeLT(*i.ProvCodeLT))
	}
	if i.ProvCodeLTE != nil {
		predicates = append(predicates, district.ProvCodeLTE(*i.ProvCodeLTE))
	}
	if i.CityCode != nil {
		predicates = append(predicates, district.CityCodeEQ(*i.CityCode))
	}
	if i.CityCodeNEQ != nil {
		predicates = append(predicates, district.CityCodeNEQ(*i.CityCodeNEQ))
	}
	if len(i.CityCodeIn) > 0 {
		predicates = append(predicates, district.CityCodeIn(i.CityCodeIn...))
	}
	if len(i.CityCodeNotIn) > 0 {
		predicates = append(predicates, district.CityCodeNotIn(i.CityCodeNotIn...))
	}
	if i.CityCodeGT != nil {
		predicates = append(predicates, district.CityCodeGT(*i.CityCodeGT))
	}
	if i.CityCodeGTE != nil {
		predicates = append(predicates, district.CityCodeGTE(*i.CityCodeGTE))
	}
	if i.CityCodeLT != nil {
		predicates = append(predicates, district.CityCodeLT(*i.CityCodeLT))
	}
	if i.CityCodeLTE != nil {
		predicates = append(predicates, district.CityCodeLTE(*i.CityCodeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, district.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, district.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, district.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, district.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, district.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, district.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, district.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, district.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, district.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, district.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, district.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, district.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, district.NameContainsFold(*i.NameContainsFold))
	}
	if i.ProvinceID != nil {
		predicates = append(predicates, district.ProvinceIDEQ(*i.ProvinceID))
	}
	if i.ProvinceIDNEQ != nil {
		predicates = append(predicates, district.ProvinceIDNEQ(*i.ProvinceIDNEQ))
	}
	if len(i.ProvinceIDIn) > 0 {
		predicates = append(predicates, district.ProvinceIDIn(i.ProvinceIDIn...))
	}
	if len(i.ProvinceIDNotIn) > 0 {
		predicates = append(predicates, district.ProvinceIDNotIn(i.ProvinceIDNotIn...))
	}
	if i.ProvinceIDGT != nil {
		predicates = append(predicates, district.ProvinceIDGT(*i.ProvinceIDGT))
	}
	if i.ProvinceIDGTE != nil {
		predicates = append(predicates, district.ProvinceIDGTE(*i.ProvinceIDGTE))
	}
	if i.ProvinceIDLT != nil {
		predicates = append(predicates, district.ProvinceIDLT(*i.ProvinceIDLT))
	}
	if i.ProvinceIDLTE != nil {
		predicates = append(predicates, district.ProvinceIDLTE(*i.ProvinceIDLTE))
	}
	if i.ProvinceIDContains != nil {
		predicates = append(predicates, district.ProvinceIDContains(*i.ProvinceIDContains))
	}
	if i.ProvinceIDHasPrefix != nil {
		predicates = append(predicates, district.ProvinceIDHasPrefix(*i.ProvinceIDHasPrefix))
	}
	if i.ProvinceIDHasSuffix != nil {
		predicates = append(predicates, district.ProvinceIDHasSuffix(*i.ProvinceIDHasSuffix))
	}
	if i.ProvinceIDEqualFold != nil {
		predicates = append(predicates, district.ProvinceIDEqualFold(*i.ProvinceIDEqualFold))
	}
	if i.ProvinceIDContainsFold != nil {
		predicates = append(predicates, district.ProvinceIDContainsFold(*i.ProvinceIDContainsFold))
	}
	if i.CityID != nil {
		predicates = append(predicates, district.CityIDEQ(*i.CityID))
	}
	if i.CityIDNEQ != nil {
		predicates = append(predicates, district.CityIDNEQ(*i.CityIDNEQ))
	}
	if len(i.CityIDIn) > 0 {
		predicates = append(predicates, district.CityIDIn(i.CityIDIn...))
	}
	if len(i.CityIDNotIn) > 0 {
		predicates = append(predicates, district.CityIDNotIn(i.CityIDNotIn...))
	}
	if i.CityIDGT != nil {
		predicates = append(predicates, district.CityIDGT(*i.CityIDGT))
	}
	if i.CityIDGTE != nil {
		predicates = append(predicates, district.CityIDGTE(*i.CityIDGTE))
	}
	if i.CityIDLT != nil {
		predicates = append(predicates, district.CityIDLT(*i.CityIDLT))
	}
	if i.CityIDLTE != nil {
		predicates = append(predicates, district.CityIDLTE(*i.CityIDLTE))
	}
	if i.CityIDContains != nil {
		predicates = append(predicates, district.CityIDContains(*i.CityIDContains))
	}
	if i.CityIDHasPrefix != nil {
		predicates = append(predicates, district.CityIDHasPrefix(*i.CityIDHasPrefix))
	}
	if i.CityIDHasSuffix != nil {
		predicates = append(predicates, district.CityIDHasSuffix(*i.CityIDHasSuffix))
	}
	if i.CityIDIsNil {
		predicates = append(predicates, district.CityIDIsNil())
	}
	if i.CityIDNotNil {
		predicates = append(predicates, district.CityIDNotNil())
	}
	if i.CityIDEqualFold != nil {
		predicates = append(predicates, district.CityIDEqualFold(*i.CityIDEqualFold))
	}
	if i.CityIDContainsFold != nil {
		predicates = append(predicates, district.CityIDContainsFold(*i.CityIDContainsFold))
	}

	if i.HasProvince != nil {
		p := district.HasProvince()
		if !*i.HasProvince {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProvinceWith) > 0 {
		with := make([]predicate.Province, 0, len(i.HasProvinceWith))
		for _, w := range i.HasProvinceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProvinceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasProvinceWith(with...))
	}
	if i.HasCity != nil {
		p := district.HasCity()
		if !*i.HasCity {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCityWith) > 0 {
		with := make([]predicate.City, 0, len(i.HasCityWith))
		for _, w := range i.HasCityWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCityWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasCityWith(with...))
	}
	if i.HasTenders != nil {
		p := district.HasTenders()
		if !*i.HasTenders {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasTendersWith(with...))
	}
	if i.HasPlots != nil {
		p := district.HasPlots()
		if !*i.HasPlots {
			p = district.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlotsWith) > 0 {
		with := make([]predicate.Plot, 0, len(i.HasPlotsWith))
		for _, w := range i.HasPlotsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlotsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, district.HasPlotsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDistrictWhereInput
	case 1:
		return predicates[0], nil
	default:
		return district.And(predicates...), nil
	}
}

// PlotWhereInput represents a where input for filtering Plot queries.
type PlotWhereInput struct {
	Predicates []predicate.Plot  `json:"-"`
	Not        *PlotWhereInput   `json:"not,omitempty"`
	Or         []*PlotWhereInput `json:"or,omitempty"`
	And        []*PlotWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "color_hex" field predicates.
	ColorHex             *string  `json:"colorHex,omitempty"`
	ColorHexNEQ          *string  `json:"colorHexNEQ,omitempty"`
	ColorHexIn           []string `json:"colorHexIn,omitempty"`
	ColorHexNotIn        []string `json:"colorHexNotIn,omitempty"`
	ColorHexGT           *string  `json:"colorHexGT,omitempty"`
	ColorHexGTE          *string  `json:"colorHexGTE,omitempty"`
	ColorHexLT           *string  `json:"colorHexLT,omitempty"`
	ColorHexLTE          *string  `json:"colorHexLTE,omitempty"`
	ColorHexContains     *string  `json:"colorHexContains,omitempty"`
	ColorHexHasPrefix    *string  `json:"colorHexHasPrefix,omitempty"`
	ColorHexHasSuffix    *string  `json:"colorHexHasSuffix,omitempty"`
	ColorHexEqualFold    *string  `json:"colorHexEqualFold,omitempty"`
	ColorHexContainsFold *string  `json:"colorHexContainsFold,omitempty"`

	// "district_id" field predicates.
	DistrictID             *xid.ID  `json:"districtID,omitempty"`
	DistrictIDNEQ          *xid.ID  `json:"districtIDNEQ,omitempty"`
	DistrictIDIn           []xid.ID `json:"districtIDIn,omitempty"`
	DistrictIDNotIn        []xid.ID `json:"districtIDNotIn,omitempty"`
	DistrictIDGT           *xid.ID  `json:"districtIDGT,omitempty"`
	DistrictIDGTE          *xid.ID  `json:"districtIDGTE,omitempty"`
	DistrictIDLT           *xid.ID  `json:"districtIDLT,omitempty"`
	DistrictIDLTE          *xid.ID  `json:"districtIDLTE,omitempty"`
	DistrictIDContains     *xid.ID  `json:"districtIDContains,omitempty"`
	DistrictIDHasPrefix    *xid.ID  `json:"districtIDHasPrefix,omitempty"`
	DistrictIDHasSuffix    *xid.ID  `json:"districtIDHasSuffix,omitempty"`
	DistrictIDEqualFold    *xid.ID  `json:"districtIDEqualFold,omitempty"`
	DistrictIDContainsFold *xid.ID  `json:"districtIDContainsFold,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlotWhereInput) AddPredicates(predicates ...predicate.Plot) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlotWhereInput filter on the PlotQuery builder.
func (i *PlotWhereInput) Filter(q *PlotQuery) (*PlotQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlotWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlotWhereInput is returned in case the PlotWhereInput is empty.
var ErrEmptyPlotWhereInput = errors.New("ent: empty predicate PlotWhereInput")

// P returns a predicate for filtering plots.
// An error is returned if the input is empty or invalid.
func (i *PlotWhereInput) P() (predicate.Plot, error) {
	var predicates []predicate.Plot
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plot.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Plot, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plot.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Plot, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plot.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plot.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plot.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plot.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plot.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plot.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plot.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plot.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plot.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, plot.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, plot.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, plot.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, plot.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, plot.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, plot.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, plot.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, plot.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, plot.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, plot.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, plot.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, plot.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, plot.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, plot.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, plot.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, plot.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, plot.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, plot.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, plot.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, plot.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, plot.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, plot.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, plot.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, plot.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, plot.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, plot.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, plot.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, plot.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, plot.NameContainsFold(*i.NameContainsFold))
	}
	if i.ColorHex != nil {
		predicates = append(predicates, plot.ColorHexEQ(*i.ColorHex))
	}
	if i.ColorHexNEQ != nil {
		predicates = append(predicates, plot.ColorHexNEQ(*i.ColorHexNEQ))
	}
	if len(i.ColorHexIn) > 0 {
		predicates = append(predicates, plot.ColorHexIn(i.ColorHexIn...))
	}
	if len(i.ColorHexNotIn) > 0 {
		predicates = append(predicates, plot.ColorHexNotIn(i.ColorHexNotIn...))
	}
	if i.ColorHexGT != nil {
		predicates = append(predicates, plot.ColorHexGT(*i.ColorHexGT))
	}
	if i.ColorHexGTE != nil {
		predicates = append(predicates, plot.ColorHexGTE(*i.ColorHexGTE))
	}
	if i.ColorHexLT != nil {
		predicates = append(predicates, plot.ColorHexLT(*i.ColorHexLT))
	}
	if i.ColorHexLTE != nil {
		predicates = append(predicates, plot.ColorHexLTE(*i.ColorHexLTE))
	}
	if i.ColorHexContains != nil {
		predicates = append(predicates, plot.ColorHexContains(*i.ColorHexContains))
	}
	if i.ColorHexHasPrefix != nil {
		predicates = append(predicates, plot.ColorHexHasPrefix(*i.ColorHexHasPrefix))
	}
	if i.ColorHexHasSuffix != nil {
		predicates = append(predicates, plot.ColorHexHasSuffix(*i.ColorHexHasSuffix))
	}
	if i.ColorHexEqualFold != nil {
		predicates = append(predicates, plot.ColorHexEqualFold(*i.ColorHexEqualFold))
	}
	if i.ColorHexContainsFold != nil {
		predicates = append(predicates, plot.ColorHexContainsFold(*i.ColorHexContainsFold))
	}
	if i.DistrictID != nil {
		predicates = append(predicates, plot.DistrictIDEQ(*i.DistrictID))
	}
	if i.DistrictIDNEQ != nil {
		predicates = append(predicates, plot.DistrictIDNEQ(*i.DistrictIDNEQ))
	}
	if len(i.DistrictIDIn) > 0 {
		predicates = append(predicates, plot.DistrictIDIn(i.DistrictIDIn...))
	}
	if len(i.DistrictIDNotIn) > 0 {
		predicates = append(predicates, plot.DistrictIDNotIn(i.DistrictIDNotIn...))
	}
	if i.DistrictIDGT != nil {
		predicates = append(predicates, plot.DistrictIDGT(*i.DistrictIDGT))
	}
	if i.DistrictIDGTE != nil {
		predicates = append(predicates, plot.DistrictIDGTE(*i.DistrictIDGTE))
	}
	if i.DistrictIDLT != nil {
		predicates = append(predicates, plot.DistrictIDLT(*i.DistrictIDLT))
	}
	if i.DistrictIDLTE != nil {
		predicates = append(predicates, plot.DistrictIDLTE(*i.DistrictIDLTE))
	}
	if i.DistrictIDContains != nil {
		predicates = append(predicates, plot.DistrictIDContains(*i.DistrictIDContains))
	}
	if i.DistrictIDHasPrefix != nil {
		predicates = append(predicates, plot.DistrictIDHasPrefix(*i.DistrictIDHasPrefix))
	}
	if i.DistrictIDHasSuffix != nil {
		predicates = append(predicates, plot.DistrictIDHasSuffix(*i.DistrictIDHasSuffix))
	}
	if i.DistrictIDEqualFold != nil {
		predicates = append(predicates, plot.DistrictIDEqualFold(*i.DistrictIDEqualFold))
	}
	if i.DistrictIDContainsFold != nil {
		predicates = append(predicates, plot.DistrictIDContainsFold(*i.DistrictIDContainsFold))
	}

	if i.HasDistrict != nil {
		p := plot.HasDistrict()
		if !*i.HasDistrict {
			p = plot.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plot.HasDistrictWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlotWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plot.And(predicates...), nil
	}
}

// ProvinceWhereInput represents a where input for filtering Province queries.
type ProvinceWhereInput struct {
	Predicates []predicate.Province  `json:"-"`
	Not        *ProvinceWhereInput   `json:"not,omitempty"`
	Or         []*ProvinceWhereInput `json:"or,omitempty"`
	And        []*ProvinceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "adcode" field predicates.
	Adcode      *int  `json:"adcode,omitempty"`
	AdcodeNEQ   *int  `json:"adcodeNEQ,omitempty"`
	AdcodeIn    []int `json:"adcodeIn,omitempty"`
	AdcodeNotIn []int `json:"adcodeNotIn,omitempty"`
	AdcodeGT    *int  `json:"adcodeGT,omitempty"`
	AdcodeGTE   *int  `json:"adcodeGTE,omitempty"`
	AdcodeLT    *int  `json:"adcodeLT,omitempty"`
	AdcodeLTE   *int  `json:"adcodeLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "country_id" field predicates.
	CountryID             *xid.ID  `json:"countryID,omitempty"`
	CountryIDNEQ          *xid.ID  `json:"countryIDNEQ,omitempty"`
	CountryIDIn           []xid.ID `json:"countryIDIn,omitempty"`
	CountryIDNotIn        []xid.ID `json:"countryIDNotIn,omitempty"`
	CountryIDGT           *xid.ID  `json:"countryIDGT,omitempty"`
	CountryIDGTE          *xid.ID  `json:"countryIDGTE,omitempty"`
	CountryIDLT           *xid.ID  `json:"countryIDLT,omitempty"`
	CountryIDLTE          *xid.ID  `json:"countryIDLTE,omitempty"`
	CountryIDContains     *xid.ID  `json:"countryIDContains,omitempty"`
	CountryIDHasPrefix    *xid.ID  `json:"countryIDHasPrefix,omitempty"`
	CountryIDHasSuffix    *xid.ID  `json:"countryIDHasSuffix,omitempty"`
	CountryIDEqualFold    *xid.ID  `json:"countryIDEqualFold,omitempty"`
	CountryIDContainsFold *xid.ID  `json:"countryIDContainsFold,omitempty"`

	// "area_id" field predicates.
	AreaID             *xid.ID  `json:"areaID,omitempty"`
	AreaIDNEQ          *xid.ID  `json:"areaIDNEQ,omitempty"`
	AreaIDIn           []xid.ID `json:"areaIDIn,omitempty"`
	AreaIDNotIn        []xid.ID `json:"areaIDNotIn,omitempty"`
	AreaIDGT           *xid.ID  `json:"areaIDGT,omitempty"`
	AreaIDGTE          *xid.ID  `json:"areaIDGTE,omitempty"`
	AreaIDLT           *xid.ID  `json:"areaIDLT,omitempty"`
	AreaIDLTE          *xid.ID  `json:"areaIDLTE,omitempty"`
	AreaIDContains     *xid.ID  `json:"areaIDContains,omitempty"`
	AreaIDHasPrefix    *xid.ID  `json:"areaIDHasPrefix,omitempty"`
	AreaIDHasSuffix    *xid.ID  `json:"areaIDHasSuffix,omitempty"`
	AreaIDIsNil        bool     `json:"areaIDIsNil,omitempty"`
	AreaIDNotNil       bool     `json:"areaIDNotNil,omitempty"`
	AreaIDEqualFold    *xid.ID  `json:"areaIDEqualFold,omitempty"`
	AreaIDContainsFold *xid.ID  `json:"areaIDContainsFold,omitempty"`

	// "districts" edge predicates.
	HasDistricts     *bool                 `json:"hasDistricts,omitempty"`
	HasDistrictsWith []*DistrictWhereInput `json:"hasDistrictsWith,omitempty"`

	// "cities" edge predicates.
	HasCities     *bool             `json:"hasCities,omitempty"`
	HasCitiesWith []*CityWhereInput `json:"hasCitiesWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`

	// "area" edge predicates.
	HasArea     *bool             `json:"hasArea,omitempty"`
	HasAreaWith []*AreaWhereInput `json:"hasAreaWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProvinceWhereInput) AddPredicates(predicates ...predicate.Province) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProvinceWhereInput filter on the ProvinceQuery builder.
func (i *ProvinceWhereInput) Filter(q *ProvinceQuery) (*ProvinceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProvinceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProvinceWhereInput is returned in case the ProvinceWhereInput is empty.
var ErrEmptyProvinceWhereInput = errors.New("ent: empty predicate ProvinceWhereInput")

// P returns a predicate for filtering provinces.
// An error is returned if the input is empty or invalid.
func (i *ProvinceWhereInput) P() (predicate.Province, error) {
	var predicates []predicate.Province
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, province.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Province, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, province.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Province, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, province.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, province.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, province.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, province.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, province.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, province.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, province.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, province.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, province.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, province.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, province.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, province.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, province.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, province.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, province.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, province.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, province.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, province.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, province.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, province.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, province.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, province.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, province.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, province.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, province.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Adcode != nil {
		predicates = append(predicates, province.AdcodeEQ(*i.Adcode))
	}
	if i.AdcodeNEQ != nil {
		predicates = append(predicates, province.AdcodeNEQ(*i.AdcodeNEQ))
	}
	if len(i.AdcodeIn) > 0 {
		predicates = append(predicates, province.AdcodeIn(i.AdcodeIn...))
	}
	if len(i.AdcodeNotIn) > 0 {
		predicates = append(predicates, province.AdcodeNotIn(i.AdcodeNotIn...))
	}
	if i.AdcodeGT != nil {
		predicates = append(predicates, province.AdcodeGT(*i.AdcodeGT))
	}
	if i.AdcodeGTE != nil {
		predicates = append(predicates, province.AdcodeGTE(*i.AdcodeGTE))
	}
	if i.AdcodeLT != nil {
		predicates = append(predicates, province.AdcodeLT(*i.AdcodeLT))
	}
	if i.AdcodeLTE != nil {
		predicates = append(predicates, province.AdcodeLTE(*i.AdcodeLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, province.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, province.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, province.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, province.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, province.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, province.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, province.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, province.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, province.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, province.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, province.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, province.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, province.NameContainsFold(*i.NameContainsFold))
	}
	if i.CountryID != nil {
		predicates = append(predicates, province.CountryIDEQ(*i.CountryID))
	}
	if i.CountryIDNEQ != nil {
		predicates = append(predicates, province.CountryIDNEQ(*i.CountryIDNEQ))
	}
	if len(i.CountryIDIn) > 0 {
		predicates = append(predicates, province.CountryIDIn(i.CountryIDIn...))
	}
	if len(i.CountryIDNotIn) > 0 {
		predicates = append(predicates, province.CountryIDNotIn(i.CountryIDNotIn...))
	}
	if i.CountryIDGT != nil {
		predicates = append(predicates, province.CountryIDGT(*i.CountryIDGT))
	}
	if i.CountryIDGTE != nil {
		predicates = append(predicates, province.CountryIDGTE(*i.CountryIDGTE))
	}
	if i.CountryIDLT != nil {
		predicates = append(predicates, province.CountryIDLT(*i.CountryIDLT))
	}
	if i.CountryIDLTE != nil {
		predicates = append(predicates, province.CountryIDLTE(*i.CountryIDLTE))
	}
	if i.CountryIDContains != nil {
		predicates = append(predicates, province.CountryIDContains(*i.CountryIDContains))
	}
	if i.CountryIDHasPrefix != nil {
		predicates = append(predicates, province.CountryIDHasPrefix(*i.CountryIDHasPrefix))
	}
	if i.CountryIDHasSuffix != nil {
		predicates = append(predicates, province.CountryIDHasSuffix(*i.CountryIDHasSuffix))
	}
	if i.CountryIDEqualFold != nil {
		predicates = append(predicates, province.CountryIDEqualFold(*i.CountryIDEqualFold))
	}
	if i.CountryIDContainsFold != nil {
		predicates = append(predicates, province.CountryIDContainsFold(*i.CountryIDContainsFold))
	}
	if i.AreaID != nil {
		predicates = append(predicates, province.AreaIDEQ(*i.AreaID))
	}
	if i.AreaIDNEQ != nil {
		predicates = append(predicates, province.AreaIDNEQ(*i.AreaIDNEQ))
	}
	if len(i.AreaIDIn) > 0 {
		predicates = append(predicates, province.AreaIDIn(i.AreaIDIn...))
	}
	if len(i.AreaIDNotIn) > 0 {
		predicates = append(predicates, province.AreaIDNotIn(i.AreaIDNotIn...))
	}
	if i.AreaIDGT != nil {
		predicates = append(predicates, province.AreaIDGT(*i.AreaIDGT))
	}
	if i.AreaIDGTE != nil {
		predicates = append(predicates, province.AreaIDGTE(*i.AreaIDGTE))
	}
	if i.AreaIDLT != nil {
		predicates = append(predicates, province.AreaIDLT(*i.AreaIDLT))
	}
	if i.AreaIDLTE != nil {
		predicates = append(predicates, province.AreaIDLTE(*i.AreaIDLTE))
	}
	if i.AreaIDContains != nil {
		predicates = append(predicates, province.AreaIDContains(*i.AreaIDContains))
	}
	if i.AreaIDHasPrefix != nil {
		predicates = append(predicates, province.AreaIDHasPrefix(*i.AreaIDHasPrefix))
	}
	if i.AreaIDHasSuffix != nil {
		predicates = append(predicates, province.AreaIDHasSuffix(*i.AreaIDHasSuffix))
	}
	if i.AreaIDIsNil {
		predicates = append(predicates, province.AreaIDIsNil())
	}
	if i.AreaIDNotNil {
		predicates = append(predicates, province.AreaIDNotNil())
	}
	if i.AreaIDEqualFold != nil {
		predicates = append(predicates, province.AreaIDEqualFold(*i.AreaIDEqualFold))
	}
	if i.AreaIDContainsFold != nil {
		predicates = append(predicates, province.AreaIDContainsFold(*i.AreaIDContainsFold))
	}

	if i.HasDistricts != nil {
		p := province.HasDistricts()
		if !*i.HasDistricts {
			p = province.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictsWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictsWith))
		for _, w := range i.HasDistrictsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, province.HasDistrictsWith(with...))
	}
	if i.HasCities != nil {
		p := province.HasCities()
		if !*i.HasCities {
			p = province.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCitiesWith) > 0 {
		with := make([]predicate.City, 0, len(i.HasCitiesWith))
		for _, w := range i.HasCitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, province.HasCitiesWith(with...))
	}
	if i.HasCountry != nil {
		p := province.HasCountry()
		if !*i.HasCountry {
			p = province.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, province.HasCountryWith(with...))
	}
	if i.HasTenders != nil {
		p := province.HasTenders()
		if !*i.HasTenders {
			p = province.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, province.HasTendersWith(with...))
	}
	if i.HasArea != nil {
		p := province.HasArea()
		if !*i.HasArea {
			p = province.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAreaWith) > 0 {
		with := make([]predicate.Area, 0, len(i.HasAreaWith))
		for _, w := range i.HasAreaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAreaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, province.HasAreaWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProvinceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return province.And(predicates...), nil
	}
}

// TenderWhereInput represents a where input for filtering Tender queries.
type TenderWhereInput struct {
	Predicates []predicate.Tender  `json:"-"`
	Not        *TenderWhereInput   `json:"not,omitempty"`
	Or         []*TenderWhereInput `json:"or,omitempty"`
	And        []*TenderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "status" field predicates.
	Status      *int  `json:"status,omitempty"`
	StatusNEQ   *int  `json:"statusNEQ,omitempty"`
	StatusIn    []int `json:"statusIn,omitempty"`
	StatusNotIn []int `json:"statusNotIn,omitempty"`
	StatusGT    *int  `json:"statusGT,omitempty"`
	StatusGTE   *int  `json:"statusGTE,omitempty"`
	StatusLT    *int  `json:"statusLT,omitempty"`
	StatusLTE   *int  `json:"statusLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "estimated_amount" field predicates.
	EstimatedAmount       *float64  `json:"estimatedAmount,omitempty"`
	EstimatedAmountNEQ    *float64  `json:"estimatedAmountNEQ,omitempty"`
	EstimatedAmountIn     []float64 `json:"estimatedAmountIn,omitempty"`
	EstimatedAmountNotIn  []float64 `json:"estimatedAmountNotIn,omitempty"`
	EstimatedAmountGT     *float64  `json:"estimatedAmountGT,omitempty"`
	EstimatedAmountGTE    *float64  `json:"estimatedAmountGTE,omitempty"`
	EstimatedAmountLT     *float64  `json:"estimatedAmountLT,omitempty"`
	EstimatedAmountLTE    *float64  `json:"estimatedAmountLTE,omitempty"`
	EstimatedAmountIsNil  bool      `json:"estimatedAmountIsNil,omitempty"`
	EstimatedAmountNotNil bool      `json:"estimatedAmountNotNil,omitempty"`

	// "tender_date" field predicates.
	TenderDate       *time.Time  `json:"tenderDate,omitempty"`
	TenderDateNEQ    *time.Time  `json:"tenderDateNEQ,omitempty"`
	TenderDateIn     []time.Time `json:"tenderDateIn,omitempty"`
	TenderDateNotIn  []time.Time `json:"tenderDateNotIn,omitempty"`
	TenderDateGT     *time.Time  `json:"tenderDateGT,omitempty"`
	TenderDateGTE    *time.Time  `json:"tenderDateGTE,omitempty"`
	TenderDateLT     *time.Time  `json:"tenderDateLT,omitempty"`
	TenderDateLTE    *time.Time  `json:"tenderDateLTE,omitempty"`
	TenderDateIsNil  bool        `json:"tenderDateIsNil,omitempty"`
	TenderDateNotNil bool        `json:"tenderDateNotNil,omitempty"`

	// "discovery_date" field predicates.
	DiscoveryDate      *time.Time  `json:"discoveryDate,omitempty"`
	DiscoveryDateNEQ   *time.Time  `json:"discoveryDateNEQ,omitempty"`
	DiscoveryDateIn    []time.Time `json:"discoveryDateIn,omitempty"`
	DiscoveryDateNotIn []time.Time `json:"discoveryDateNotIn,omitempty"`
	DiscoveryDateGT    *time.Time  `json:"discoveryDateGT,omitempty"`
	DiscoveryDateGTE   *time.Time  `json:"discoveryDateGTE,omitempty"`
	DiscoveryDateLT    *time.Time  `json:"discoveryDateLT,omitempty"`
	DiscoveryDateLTE   *time.Time  `json:"discoveryDateLTE,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "full_address" field predicates.
	FullAddress             *string  `json:"fullAddress,omitempty"`
	FullAddressNEQ          *string  `json:"fullAddressNEQ,omitempty"`
	FullAddressIn           []string `json:"fullAddressIn,omitempty"`
	FullAddressNotIn        []string `json:"fullAddressNotIn,omitempty"`
	FullAddressGT           *string  `json:"fullAddressGT,omitempty"`
	FullAddressGTE          *string  `json:"fullAddressGTE,omitempty"`
	FullAddressLT           *string  `json:"fullAddressLT,omitempty"`
	FullAddressLTE          *string  `json:"fullAddressLTE,omitempty"`
	FullAddressContains     *string  `json:"fullAddressContains,omitempty"`
	FullAddressHasPrefix    *string  `json:"fullAddressHasPrefix,omitempty"`
	FullAddressHasSuffix    *string  `json:"fullAddressHasSuffix,omitempty"`
	FullAddressIsNil        bool     `json:"fullAddressIsNil,omitempty"`
	FullAddressNotNil       bool     `json:"fullAddressNotNil,omitempty"`
	FullAddressEqualFold    *string  `json:"fullAddressEqualFold,omitempty"`
	FullAddressContainsFold *string  `json:"fullAddressContainsFold,omitempty"`

	// "contractor" field predicates.
	Contractor             *string  `json:"contractor,omitempty"`
	ContractorNEQ          *string  `json:"contractorNEQ,omitempty"`
	ContractorIn           []string `json:"contractorIn,omitempty"`
	ContractorNotIn        []string `json:"contractorNotIn,omitempty"`
	ContractorGT           *string  `json:"contractorGT,omitempty"`
	ContractorGTE          *string  `json:"contractorGTE,omitempty"`
	ContractorLT           *string  `json:"contractorLT,omitempty"`
	ContractorLTE          *string  `json:"contractorLTE,omitempty"`
	ContractorContains     *string  `json:"contractorContains,omitempty"`
	ContractorHasPrefix    *string  `json:"contractorHasPrefix,omitempty"`
	ContractorHasSuffix    *string  `json:"contractorHasSuffix,omitempty"`
	ContractorIsNil        bool     `json:"contractorIsNil,omitempty"`
	ContractorNotNil       bool     `json:"contractorNotNil,omitempty"`
	ContractorEqualFold    *string  `json:"contractorEqualFold,omitempty"`
	ContractorContainsFold *string  `json:"contractorContainsFold,omitempty"`

	// "size_and_value_rating" field predicates.
	SizeAndValueRating       *int  `json:"sizeAndValueRating,omitempty"`
	SizeAndValueRatingNEQ    *int  `json:"sizeAndValueRatingNEQ,omitempty"`
	SizeAndValueRatingIn     []int `json:"sizeAndValueRatingIn,omitempty"`
	SizeAndValueRatingNotIn  []int `json:"sizeAndValueRatingNotIn,omitempty"`
	SizeAndValueRatingGT     *int  `json:"sizeAndValueRatingGT,omitempty"`
	SizeAndValueRatingGTE    *int  `json:"sizeAndValueRatingGTE,omitempty"`
	SizeAndValueRatingLT     *int  `json:"sizeAndValueRatingLT,omitempty"`
	SizeAndValueRatingLTE    *int  `json:"sizeAndValueRatingLTE,omitempty"`
	SizeAndValueRatingIsNil  bool  `json:"sizeAndValueRatingIsNil,omitempty"`
	SizeAndValueRatingNotNil bool  `json:"sizeAndValueRatingNotNil,omitempty"`

	// "size_and_value_rating_overview" field predicates.
	SizeAndValueRatingOverview             *string  `json:"sizeAndValueRatingOverview,omitempty"`
	SizeAndValueRatingOverviewNEQ          *string  `json:"sizeAndValueRatingOverviewNEQ,omitempty"`
	SizeAndValueRatingOverviewIn           []string `json:"sizeAndValueRatingOverviewIn,omitempty"`
	SizeAndValueRatingOverviewNotIn        []string `json:"sizeAndValueRatingOverviewNotIn,omitempty"`
	SizeAndValueRatingOverviewGT           *string  `json:"sizeAndValueRatingOverviewGT,omitempty"`
	SizeAndValueRatingOverviewGTE          *string  `json:"sizeAndValueRatingOverviewGTE,omitempty"`
	SizeAndValueRatingOverviewLT           *string  `json:"sizeAndValueRatingOverviewLT,omitempty"`
	SizeAndValueRatingOverviewLTE          *string  `json:"sizeAndValueRatingOverviewLTE,omitempty"`
	SizeAndValueRatingOverviewContains     *string  `json:"sizeAndValueRatingOverviewContains,omitempty"`
	SizeAndValueRatingOverviewHasPrefix    *string  `json:"sizeAndValueRatingOverviewHasPrefix,omitempty"`
	SizeAndValueRatingOverviewHasSuffix    *string  `json:"sizeAndValueRatingOverviewHasSuffix,omitempty"`
	SizeAndValueRatingOverviewIsNil        bool     `json:"sizeAndValueRatingOverviewIsNil,omitempty"`
	SizeAndValueRatingOverviewNotNil       bool     `json:"sizeAndValueRatingOverviewNotNil,omitempty"`
	SizeAndValueRatingOverviewEqualFold    *string  `json:"sizeAndValueRatingOverviewEqualFold,omitempty"`
	SizeAndValueRatingOverviewContainsFold *string  `json:"sizeAndValueRatingOverviewContainsFold,omitempty"`

	// "credit_and_payment_rating" field predicates.
	CreditAndPaymentRating       *int  `json:"creditAndPaymentRating,omitempty"`
	CreditAndPaymentRatingNEQ    *int  `json:"creditAndPaymentRatingNEQ,omitempty"`
	CreditAndPaymentRatingIn     []int `json:"creditAndPaymentRatingIn,omitempty"`
	CreditAndPaymentRatingNotIn  []int `json:"creditAndPaymentRatingNotIn,omitempty"`
	CreditAndPaymentRatingGT     *int  `json:"creditAndPaymentRatingGT,omitempty"`
	CreditAndPaymentRatingGTE    *int  `json:"creditAndPaymentRatingGTE,omitempty"`
	CreditAndPaymentRatingLT     *int  `json:"creditAndPaymentRatingLT,omitempty"`
	CreditAndPaymentRatingLTE    *int  `json:"creditAndPaymentRatingLTE,omitempty"`
	CreditAndPaymentRatingIsNil  bool  `json:"creditAndPaymentRatingIsNil,omitempty"`
	CreditAndPaymentRatingNotNil bool  `json:"creditAndPaymentRatingNotNil,omitempty"`

	// "credit_and_payment_rating_overview" field predicates.
	CreditAndPaymentRatingOverview             *string  `json:"creditAndPaymentRatingOverview,omitempty"`
	CreditAndPaymentRatingOverviewNEQ          *string  `json:"creditAndPaymentRatingOverviewNEQ,omitempty"`
	CreditAndPaymentRatingOverviewIn           []string `json:"creditAndPaymentRatingOverviewIn,omitempty"`
	CreditAndPaymentRatingOverviewNotIn        []string `json:"creditAndPaymentRatingOverviewNotIn,omitempty"`
	CreditAndPaymentRatingOverviewGT           *string  `json:"creditAndPaymentRatingOverviewGT,omitempty"`
	CreditAndPaymentRatingOverviewGTE          *string  `json:"creditAndPaymentRatingOverviewGTE,omitempty"`
	CreditAndPaymentRatingOverviewLT           *string  `json:"creditAndPaymentRatingOverviewLT,omitempty"`
	CreditAndPaymentRatingOverviewLTE          *string  `json:"creditAndPaymentRatingOverviewLTE,omitempty"`
	CreditAndPaymentRatingOverviewContains     *string  `json:"creditAndPaymentRatingOverviewContains,omitempty"`
	CreditAndPaymentRatingOverviewHasPrefix    *string  `json:"creditAndPaymentRatingOverviewHasPrefix,omitempty"`
	CreditAndPaymentRatingOverviewHasSuffix    *string  `json:"creditAndPaymentRatingOverviewHasSuffix,omitempty"`
	CreditAndPaymentRatingOverviewIsNil        bool     `json:"creditAndPaymentRatingOverviewIsNil,omitempty"`
	CreditAndPaymentRatingOverviewNotNil       bool     `json:"creditAndPaymentRatingOverviewNotNil,omitempty"`
	CreditAndPaymentRatingOverviewEqualFold    *string  `json:"creditAndPaymentRatingOverviewEqualFold,omitempty"`
	CreditAndPaymentRatingOverviewContainsFold *string  `json:"creditAndPaymentRatingOverviewContainsFold,omitempty"`

	// "time_limit_rating" field predicates.
	TimeLimitRating       *int  `json:"timeLimitRating,omitempty"`
	TimeLimitRatingNEQ    *int  `json:"timeLimitRatingNEQ,omitempty"`
	TimeLimitRatingIn     []int `json:"timeLimitRatingIn,omitempty"`
	TimeLimitRatingNotIn  []int `json:"timeLimitRatingNotIn,omitempty"`
	TimeLimitRatingGT     *int  `json:"timeLimitRatingGT,omitempty"`
	TimeLimitRatingGTE    *int  `json:"timeLimitRatingGTE,omitempty"`
	TimeLimitRatingLT     *int  `json:"timeLimitRatingLT,omitempty"`
	TimeLimitRatingLTE    *int  `json:"timeLimitRatingLTE,omitempty"`
	TimeLimitRatingIsNil  bool  `json:"timeLimitRatingIsNil,omitempty"`
	TimeLimitRatingNotNil bool  `json:"timeLimitRatingNotNil,omitempty"`

	// "time_limit_rating_overview" field predicates.
	TimeLimitRatingOverview             *string  `json:"timeLimitRatingOverview,omitempty"`
	TimeLimitRatingOverviewNEQ          *string  `json:"timeLimitRatingOverviewNEQ,omitempty"`
	TimeLimitRatingOverviewIn           []string `json:"timeLimitRatingOverviewIn,omitempty"`
	TimeLimitRatingOverviewNotIn        []string `json:"timeLimitRatingOverviewNotIn,omitempty"`
	TimeLimitRatingOverviewGT           *string  `json:"timeLimitRatingOverviewGT,omitempty"`
	TimeLimitRatingOverviewGTE          *string  `json:"timeLimitRatingOverviewGTE,omitempty"`
	TimeLimitRatingOverviewLT           *string  `json:"timeLimitRatingOverviewLT,omitempty"`
	TimeLimitRatingOverviewLTE          *string  `json:"timeLimitRatingOverviewLTE,omitempty"`
	TimeLimitRatingOverviewContains     *string  `json:"timeLimitRatingOverviewContains,omitempty"`
	TimeLimitRatingOverviewHasPrefix    *string  `json:"timeLimitRatingOverviewHasPrefix,omitempty"`
	TimeLimitRatingOverviewHasSuffix    *string  `json:"timeLimitRatingOverviewHasSuffix,omitempty"`
	TimeLimitRatingOverviewIsNil        bool     `json:"timeLimitRatingOverviewIsNil,omitempty"`
	TimeLimitRatingOverviewNotNil       bool     `json:"timeLimitRatingOverviewNotNil,omitempty"`
	TimeLimitRatingOverviewEqualFold    *string  `json:"timeLimitRatingOverviewEqualFold,omitempty"`
	TimeLimitRatingOverviewContainsFold *string  `json:"timeLimitRatingOverviewContainsFold,omitempty"`

	// "customer_relationship_rating" field predicates.
	CustomerRelationshipRating       *int  `json:"customerRelationshipRating,omitempty"`
	CustomerRelationshipRatingNEQ    *int  `json:"customerRelationshipRatingNEQ,omitempty"`
	CustomerRelationshipRatingIn     []int `json:"customerRelationshipRatingIn,omitempty"`
	CustomerRelationshipRatingNotIn  []int `json:"customerRelationshipRatingNotIn,omitempty"`
	CustomerRelationshipRatingGT     *int  `json:"customerRelationshipRatingGT,omitempty"`
	CustomerRelationshipRatingGTE    *int  `json:"customerRelationshipRatingGTE,omitempty"`
	CustomerRelationshipRatingLT     *int  `json:"customerRelationshipRatingLT,omitempty"`
	CustomerRelationshipRatingLTE    *int  `json:"customerRelationshipRatingLTE,omitempty"`
	CustomerRelationshipRatingIsNil  bool  `json:"customerRelationshipRatingIsNil,omitempty"`
	CustomerRelationshipRatingNotNil bool  `json:"customerRelationshipRatingNotNil,omitempty"`

	// "customer_relationship_rating_overview" field predicates.
	CustomerRelationshipRatingOverview             *string  `json:"customerRelationshipRatingOverview,omitempty"`
	CustomerRelationshipRatingOverviewNEQ          *string  `json:"customerRelationshipRatingOverviewNEQ,omitempty"`
	CustomerRelationshipRatingOverviewIn           []string `json:"customerRelationshipRatingOverviewIn,omitempty"`
	CustomerRelationshipRatingOverviewNotIn        []string `json:"customerRelationshipRatingOverviewNotIn,omitempty"`
	CustomerRelationshipRatingOverviewGT           *string  `json:"customerRelationshipRatingOverviewGT,omitempty"`
	CustomerRelationshipRatingOverviewGTE          *string  `json:"customerRelationshipRatingOverviewGTE,omitempty"`
	CustomerRelationshipRatingOverviewLT           *string  `json:"customerRelationshipRatingOverviewLT,omitempty"`
	CustomerRelationshipRatingOverviewLTE          *string  `json:"customerRelationshipRatingOverviewLTE,omitempty"`
	CustomerRelationshipRatingOverviewContains     *string  `json:"customerRelationshipRatingOverviewContains,omitempty"`
	CustomerRelationshipRatingOverviewHasPrefix    *string  `json:"customerRelationshipRatingOverviewHasPrefix,omitempty"`
	CustomerRelationshipRatingOverviewHasSuffix    *string  `json:"customerRelationshipRatingOverviewHasSuffix,omitempty"`
	CustomerRelationshipRatingOverviewIsNil        bool     `json:"customerRelationshipRatingOverviewIsNil,omitempty"`
	CustomerRelationshipRatingOverviewNotNil       bool     `json:"customerRelationshipRatingOverviewNotNil,omitempty"`
	CustomerRelationshipRatingOverviewEqualFold    *string  `json:"customerRelationshipRatingOverviewEqualFold,omitempty"`
	CustomerRelationshipRatingOverviewContainsFold *string  `json:"customerRelationshipRatingOverviewContainsFold,omitempty"`

	// "competitive_partnership_rating" field predicates.
	CompetitivePartnershipRating       *int  `json:"competitivePartnershipRating,omitempty"`
	CompetitivePartnershipRatingNEQ    *int  `json:"competitivePartnershipRatingNEQ,omitempty"`
	CompetitivePartnershipRatingIn     []int `json:"competitivePartnershipRatingIn,omitempty"`
	CompetitivePartnershipRatingNotIn  []int `json:"competitivePartnershipRatingNotIn,omitempty"`
	CompetitivePartnershipRatingGT     *int  `json:"competitivePartnershipRatingGT,omitempty"`
	CompetitivePartnershipRatingGTE    *int  `json:"competitivePartnershipRatingGTE,omitempty"`
	CompetitivePartnershipRatingLT     *int  `json:"competitivePartnershipRatingLT,omitempty"`
	CompetitivePartnershipRatingLTE    *int  `json:"competitivePartnershipRatingLTE,omitempty"`
	CompetitivePartnershipRatingIsNil  bool  `json:"competitivePartnershipRatingIsNil,omitempty"`
	CompetitivePartnershipRatingNotNil bool  `json:"competitivePartnershipRatingNotNil,omitempty"`

	// "competitive_partnership_rating_overview" field predicates.
	CompetitivePartnershipRatingOverview             *string  `json:"competitivePartnershipRatingOverview,omitempty"`
	CompetitivePartnershipRatingOverviewNEQ          *string  `json:"competitivePartnershipRatingOverviewNEQ,omitempty"`
	CompetitivePartnershipRatingOverviewIn           []string `json:"competitivePartnershipRatingOverviewIn,omitempty"`
	CompetitivePartnershipRatingOverviewNotIn        []string `json:"competitivePartnershipRatingOverviewNotIn,omitempty"`
	CompetitivePartnershipRatingOverviewGT           *string  `json:"competitivePartnershipRatingOverviewGT,omitempty"`
	CompetitivePartnershipRatingOverviewGTE          *string  `json:"competitivePartnershipRatingOverviewGTE,omitempty"`
	CompetitivePartnershipRatingOverviewLT           *string  `json:"competitivePartnershipRatingOverviewLT,omitempty"`
	CompetitivePartnershipRatingOverviewLTE          *string  `json:"competitivePartnershipRatingOverviewLTE,omitempty"`
	CompetitivePartnershipRatingOverviewContains     *string  `json:"competitivePartnershipRatingOverviewContains,omitempty"`
	CompetitivePartnershipRatingOverviewHasPrefix    *string  `json:"competitivePartnershipRatingOverviewHasPrefix,omitempty"`
	CompetitivePartnershipRatingOverviewHasSuffix    *string  `json:"competitivePartnershipRatingOverviewHasSuffix,omitempty"`
	CompetitivePartnershipRatingOverviewIsNil        bool     `json:"competitivePartnershipRatingOverviewIsNil,omitempty"`
	CompetitivePartnershipRatingOverviewNotNil       bool     `json:"competitivePartnershipRatingOverviewNotNil,omitempty"`
	CompetitivePartnershipRatingOverviewEqualFold    *string  `json:"competitivePartnershipRatingOverviewEqualFold,omitempty"`
	CompetitivePartnershipRatingOverviewContainsFold *string  `json:"competitivePartnershipRatingOverviewContainsFold,omitempty"`

	// "prepare_to_bid" field predicates.
	PrepareToBid    *bool `json:"prepareToBid,omitempty"`
	PrepareToBidNEQ *bool `json:"prepareToBidNEQ,omitempty"`

	// "project_code" field predicates.
	ProjectCode             *string  `json:"projectCode,omitempty"`
	ProjectCodeNEQ          *string  `json:"projectCodeNEQ,omitempty"`
	ProjectCodeIn           []string `json:"projectCodeIn,omitempty"`
	ProjectCodeNotIn        []string `json:"projectCodeNotIn,omitempty"`
	ProjectCodeGT           *string  `json:"projectCodeGT,omitempty"`
	ProjectCodeGTE          *string  `json:"projectCodeGTE,omitempty"`
	ProjectCodeLT           *string  `json:"projectCodeLT,omitempty"`
	ProjectCodeLTE          *string  `json:"projectCodeLTE,omitempty"`
	ProjectCodeContains     *string  `json:"projectCodeContains,omitempty"`
	ProjectCodeHasPrefix    *string  `json:"projectCodeHasPrefix,omitempty"`
	ProjectCodeHasSuffix    *string  `json:"projectCodeHasSuffix,omitempty"`
	ProjectCodeIsNil        bool     `json:"projectCodeIsNil,omitempty"`
	ProjectCodeNotNil       bool     `json:"projectCodeNotNil,omitempty"`
	ProjectCodeEqualFold    *string  `json:"projectCodeEqualFold,omitempty"`
	ProjectCodeContainsFold *string  `json:"projectCodeContainsFold,omitempty"`

	// "project_definition" field predicates.
	ProjectDefinition             *string  `json:"projectDefinition,omitempty"`
	ProjectDefinitionNEQ          *string  `json:"projectDefinitionNEQ,omitempty"`
	ProjectDefinitionIn           []string `json:"projectDefinitionIn,omitempty"`
	ProjectDefinitionNotIn        []string `json:"projectDefinitionNotIn,omitempty"`
	ProjectDefinitionGT           *string  `json:"projectDefinitionGT,omitempty"`
	ProjectDefinitionGTE          *string  `json:"projectDefinitionGTE,omitempty"`
	ProjectDefinitionLT           *string  `json:"projectDefinitionLT,omitempty"`
	ProjectDefinitionLTE          *string  `json:"projectDefinitionLTE,omitempty"`
	ProjectDefinitionContains     *string  `json:"projectDefinitionContains,omitempty"`
	ProjectDefinitionHasPrefix    *string  `json:"projectDefinitionHasPrefix,omitempty"`
	ProjectDefinitionHasSuffix    *string  `json:"projectDefinitionHasSuffix,omitempty"`
	ProjectDefinitionIsNil        bool     `json:"projectDefinitionIsNil,omitempty"`
	ProjectDefinitionNotNil       bool     `json:"projectDefinitionNotNil,omitempty"`
	ProjectDefinitionEqualFold    *string  `json:"projectDefinitionEqualFold,omitempty"`
	ProjectDefinitionContainsFold *string  `json:"projectDefinitionContainsFold,omitempty"`

	// "estimated_project_start_date" field predicates.
	EstimatedProjectStartDate       *time.Time  `json:"estimatedProjectStartDate,omitempty"`
	EstimatedProjectStartDateNEQ    *time.Time  `json:"estimatedProjectStartDateNEQ,omitempty"`
	EstimatedProjectStartDateIn     []time.Time `json:"estimatedProjectStartDateIn,omitempty"`
	EstimatedProjectStartDateNotIn  []time.Time `json:"estimatedProjectStartDateNotIn,omitempty"`
	EstimatedProjectStartDateGT     *time.Time  `json:"estimatedProjectStartDateGT,omitempty"`
	EstimatedProjectStartDateGTE    *time.Time  `json:"estimatedProjectStartDateGTE,omitempty"`
	EstimatedProjectStartDateLT     *time.Time  `json:"estimatedProjectStartDateLT,omitempty"`
	EstimatedProjectStartDateLTE    *time.Time  `json:"estimatedProjectStartDateLTE,omitempty"`
	EstimatedProjectStartDateIsNil  bool        `json:"estimatedProjectStartDateIsNil,omitempty"`
	EstimatedProjectStartDateNotNil bool        `json:"estimatedProjectStartDateNotNil,omitempty"`

	// "estimated_project_end_date" field predicates.
	EstimatedProjectEndDate       *time.Time  `json:"estimatedProjectEndDate,omitempty"`
	EstimatedProjectEndDateNEQ    *time.Time  `json:"estimatedProjectEndDateNEQ,omitempty"`
	EstimatedProjectEndDateIn     []time.Time `json:"estimatedProjectEndDateIn,omitempty"`
	EstimatedProjectEndDateNotIn  []time.Time `json:"estimatedProjectEndDateNotIn,omitempty"`
	EstimatedProjectEndDateGT     *time.Time  `json:"estimatedProjectEndDateGT,omitempty"`
	EstimatedProjectEndDateGTE    *time.Time  `json:"estimatedProjectEndDateGTE,omitempty"`
	EstimatedProjectEndDateLT     *time.Time  `json:"estimatedProjectEndDateLT,omitempty"`
	EstimatedProjectEndDateLTE    *time.Time  `json:"estimatedProjectEndDateLTE,omitempty"`
	EstimatedProjectEndDateIsNil  bool        `json:"estimatedProjectEndDateIsNil,omitempty"`
	EstimatedProjectEndDateNotNil bool        `json:"estimatedProjectEndDateNotNil,omitempty"`

	// "project_type" field predicates.
	ProjectType             *string  `json:"projectType,omitempty"`
	ProjectTypeNEQ          *string  `json:"projectTypeNEQ,omitempty"`
	ProjectTypeIn           []string `json:"projectTypeIn,omitempty"`
	ProjectTypeNotIn        []string `json:"projectTypeNotIn,omitempty"`
	ProjectTypeGT           *string  `json:"projectTypeGT,omitempty"`
	ProjectTypeGTE          *string  `json:"projectTypeGTE,omitempty"`
	ProjectTypeLT           *string  `json:"projectTypeLT,omitempty"`
	ProjectTypeLTE          *string  `json:"projectTypeLTE,omitempty"`
	ProjectTypeContains     *string  `json:"projectTypeContains,omitempty"`
	ProjectTypeHasPrefix    *string  `json:"projectTypeHasPrefix,omitempty"`
	ProjectTypeHasSuffix    *string  `json:"projectTypeHasSuffix,omitempty"`
	ProjectTypeIsNil        bool     `json:"projectTypeIsNil,omitempty"`
	ProjectTypeNotNil       bool     `json:"projectTypeNotNil,omitempty"`
	ProjectTypeEqualFold    *string  `json:"projectTypeEqualFold,omitempty"`
	ProjectTypeContainsFold *string  `json:"projectTypeContainsFold,omitempty"`

	// "remark" field predicates.
	Remark             *string  `json:"remark,omitempty"`
	RemarkNEQ          *string  `json:"remarkNEQ,omitempty"`
	RemarkIn           []string `json:"remarkIn,omitempty"`
	RemarkNotIn        []string `json:"remarkNotIn,omitempty"`
	RemarkGT           *string  `json:"remarkGT,omitempty"`
	RemarkGTE          *string  `json:"remarkGTE,omitempty"`
	RemarkLT           *string  `json:"remarkLT,omitempty"`
	RemarkLTE          *string  `json:"remarkLTE,omitempty"`
	RemarkContains     *string  `json:"remarkContains,omitempty"`
	RemarkHasPrefix    *string  `json:"remarkHasPrefix,omitempty"`
	RemarkHasSuffix    *string  `json:"remarkHasSuffix,omitempty"`
	RemarkIsNil        bool     `json:"remarkIsNil,omitempty"`
	RemarkNotNil       bool     `json:"remarkNotNil,omitempty"`
	RemarkEqualFold    *string  `json:"remarkEqualFold,omitempty"`
	RemarkContainsFold *string  `json:"remarkContainsFold,omitempty"`

	// "tender_situations" field predicates.
	TenderSituations             *string  `json:"tenderSituations,omitempty"`
	TenderSituationsNEQ          *string  `json:"tenderSituationsNEQ,omitempty"`
	TenderSituationsIn           []string `json:"tenderSituationsIn,omitempty"`
	TenderSituationsNotIn        []string `json:"tenderSituationsNotIn,omitempty"`
	TenderSituationsGT           *string  `json:"tenderSituationsGT,omitempty"`
	TenderSituationsGTE          *string  `json:"tenderSituationsGTE,omitempty"`
	TenderSituationsLT           *string  `json:"tenderSituationsLT,omitempty"`
	TenderSituationsLTE          *string  `json:"tenderSituationsLTE,omitempty"`
	TenderSituationsContains     *string  `json:"tenderSituationsContains,omitempty"`
	TenderSituationsHasPrefix    *string  `json:"tenderSituationsHasPrefix,omitempty"`
	TenderSituationsHasSuffix    *string  `json:"tenderSituationsHasSuffix,omitempty"`
	TenderSituationsIsNil        bool     `json:"tenderSituationsIsNil,omitempty"`
	TenderSituationsNotNil       bool     `json:"tenderSituationsNotNil,omitempty"`
	TenderSituationsEqualFold    *string  `json:"tenderSituationsEqualFold,omitempty"`
	TenderSituationsContainsFold *string  `json:"tenderSituationsContainsFold,omitempty"`

	// "owner_situations" field predicates.
	OwnerSituations             *string  `json:"ownerSituations,omitempty"`
	OwnerSituationsNEQ          *string  `json:"ownerSituationsNEQ,omitempty"`
	OwnerSituationsIn           []string `json:"ownerSituationsIn,omitempty"`
	OwnerSituationsNotIn        []string `json:"ownerSituationsNotIn,omitempty"`
	OwnerSituationsGT           *string  `json:"ownerSituationsGT,omitempty"`
	OwnerSituationsGTE          *string  `json:"ownerSituationsGTE,omitempty"`
	OwnerSituationsLT           *string  `json:"ownerSituationsLT,omitempty"`
	OwnerSituationsLTE          *string  `json:"ownerSituationsLTE,omitempty"`
	OwnerSituationsContains     *string  `json:"ownerSituationsContains,omitempty"`
	OwnerSituationsHasPrefix    *string  `json:"ownerSituationsHasPrefix,omitempty"`
	OwnerSituationsHasSuffix    *string  `json:"ownerSituationsHasSuffix,omitempty"`
	OwnerSituationsIsNil        bool     `json:"ownerSituationsIsNil,omitempty"`
	OwnerSituationsNotNil       bool     `json:"ownerSituationsNotNil,omitempty"`
	OwnerSituationsEqualFold    *string  `json:"ownerSituationsEqualFold,omitempty"`
	OwnerSituationsContainsFold *string  `json:"ownerSituationsContainsFold,omitempty"`

	// "bidding_instructions" field predicates.
	BiddingInstructions             *string  `json:"biddingInstructions,omitempty"`
	BiddingInstructionsNEQ          *string  `json:"biddingInstructionsNEQ,omitempty"`
	BiddingInstructionsIn           []string `json:"biddingInstructionsIn,omitempty"`
	BiddingInstructionsNotIn        []string `json:"biddingInstructionsNotIn,omitempty"`
	BiddingInstructionsGT           *string  `json:"biddingInstructionsGT,omitempty"`
	BiddingInstructionsGTE          *string  `json:"biddingInstructionsGTE,omitempty"`
	BiddingInstructionsLT           *string  `json:"biddingInstructionsLT,omitempty"`
	BiddingInstructionsLTE          *string  `json:"biddingInstructionsLTE,omitempty"`
	BiddingInstructionsContains     *string  `json:"biddingInstructionsContains,omitempty"`
	BiddingInstructionsHasPrefix    *string  `json:"biddingInstructionsHasPrefix,omitempty"`
	BiddingInstructionsHasSuffix    *string  `json:"biddingInstructionsHasSuffix,omitempty"`
	BiddingInstructionsIsNil        bool     `json:"biddingInstructionsIsNil,omitempty"`
	BiddingInstructionsNotNil       bool     `json:"biddingInstructionsNotNil,omitempty"`
	BiddingInstructionsEqualFold    *string  `json:"biddingInstructionsEqualFold,omitempty"`
	BiddingInstructionsContainsFold *string  `json:"biddingInstructionsContainsFold,omitempty"`

	// "competitor_situations" field predicates.
	CompetitorSituations             *string  `json:"competitorSituations,omitempty"`
	CompetitorSituationsNEQ          *string  `json:"competitorSituationsNEQ,omitempty"`
	CompetitorSituationsIn           []string `json:"competitorSituationsIn,omitempty"`
	CompetitorSituationsNotIn        []string `json:"competitorSituationsNotIn,omitempty"`
	CompetitorSituationsGT           *string  `json:"competitorSituationsGT,omitempty"`
	CompetitorSituationsGTE          *string  `json:"competitorSituationsGTE,omitempty"`
	CompetitorSituationsLT           *string  `json:"competitorSituationsLT,omitempty"`
	CompetitorSituationsLTE          *string  `json:"competitorSituationsLTE,omitempty"`
	CompetitorSituationsContains     *string  `json:"competitorSituationsContains,omitempty"`
	CompetitorSituationsHasPrefix    *string  `json:"competitorSituationsHasPrefix,omitempty"`
	CompetitorSituationsHasSuffix    *string  `json:"competitorSituationsHasSuffix,omitempty"`
	CompetitorSituationsIsNil        bool     `json:"competitorSituationsIsNil,omitempty"`
	CompetitorSituationsNotNil       bool     `json:"competitorSituationsNotNil,omitempty"`
	CompetitorSituationsEqualFold    *string  `json:"competitorSituationsEqualFold,omitempty"`
	CompetitorSituationsContainsFold *string  `json:"competitorSituationsContainsFold,omitempty"`

	// "cost_engineer" field predicates.
	CostEngineer             *string  `json:"costEngineer,omitempty"`
	CostEngineerNEQ          *string  `json:"costEngineerNEQ,omitempty"`
	CostEngineerIn           []string `json:"costEngineerIn,omitempty"`
	CostEngineerNotIn        []string `json:"costEngineerNotIn,omitempty"`
	CostEngineerGT           *string  `json:"costEngineerGT,omitempty"`
	CostEngineerGTE          *string  `json:"costEngineerGTE,omitempty"`
	CostEngineerLT           *string  `json:"costEngineerLT,omitempty"`
	CostEngineerLTE          *string  `json:"costEngineerLTE,omitempty"`
	CostEngineerContains     *string  `json:"costEngineerContains,omitempty"`
	CostEngineerHasPrefix    *string  `json:"costEngineerHasPrefix,omitempty"`
	CostEngineerHasSuffix    *string  `json:"costEngineerHasSuffix,omitempty"`
	CostEngineerIsNil        bool     `json:"costEngineerIsNil,omitempty"`
	CostEngineerNotNil       bool     `json:"costEngineerNotNil,omitempty"`
	CostEngineerEqualFold    *string  `json:"costEngineerEqualFold,omitempty"`
	CostEngineerContainsFold *string  `json:"costEngineerContainsFold,omitempty"`

	// "tender_form" field predicates.
	TenderForm             *string  `json:"tenderForm,omitempty"`
	TenderFormNEQ          *string  `json:"tenderFormNEQ,omitempty"`
	TenderFormIn           []string `json:"tenderFormIn,omitempty"`
	TenderFormNotIn        []string `json:"tenderFormNotIn,omitempty"`
	TenderFormGT           *string  `json:"tenderFormGT,omitempty"`
	TenderFormGTE          *string  `json:"tenderFormGTE,omitempty"`
	TenderFormLT           *string  `json:"tenderFormLT,omitempty"`
	TenderFormLTE          *string  `json:"tenderFormLTE,omitempty"`
	TenderFormContains     *string  `json:"tenderFormContains,omitempty"`
	TenderFormHasPrefix    *string  `json:"tenderFormHasPrefix,omitempty"`
	TenderFormHasSuffix    *string  `json:"tenderFormHasSuffix,omitempty"`
	TenderFormIsNil        bool     `json:"tenderFormIsNil,omitempty"`
	TenderFormNotNil       bool     `json:"tenderFormNotNil,omitempty"`
	TenderFormEqualFold    *string  `json:"tenderFormEqualFold,omitempty"`
	TenderFormContainsFold *string  `json:"tenderFormContainsFold,omitempty"`

	// "contract_form" field predicates.
	ContractForm             *string  `json:"contractForm,omitempty"`
	ContractFormNEQ          *string  `json:"contractFormNEQ,omitempty"`
	ContractFormIn           []string `json:"contractFormIn,omitempty"`
	ContractFormNotIn        []string `json:"contractFormNotIn,omitempty"`
	ContractFormGT           *string  `json:"contractFormGT,omitempty"`
	ContractFormGTE          *string  `json:"contractFormGTE,omitempty"`
	ContractFormLT           *string  `json:"contractFormLT,omitempty"`
	ContractFormLTE          *string  `json:"contractFormLTE,omitempty"`
	ContractFormContains     *string  `json:"contractFormContains,omitempty"`
	ContractFormHasPrefix    *string  `json:"contractFormHasPrefix,omitempty"`
	ContractFormHasSuffix    *string  `json:"contractFormHasSuffix,omitempty"`
	ContractFormIsNil        bool     `json:"contractFormIsNil,omitempty"`
	ContractFormNotNil       bool     `json:"contractFormNotNil,omitempty"`
	ContractFormEqualFold    *string  `json:"contractFormEqualFold,omitempty"`
	ContractFormContainsFold *string  `json:"contractFormContainsFold,omitempty"`

	// "management_company" field predicates.
	ManagementCompany             *string  `json:"managementCompany,omitempty"`
	ManagementCompanyNEQ          *string  `json:"managementCompanyNEQ,omitempty"`
	ManagementCompanyIn           []string `json:"managementCompanyIn,omitempty"`
	ManagementCompanyNotIn        []string `json:"managementCompanyNotIn,omitempty"`
	ManagementCompanyGT           *string  `json:"managementCompanyGT,omitempty"`
	ManagementCompanyGTE          *string  `json:"managementCompanyGTE,omitempty"`
	ManagementCompanyLT           *string  `json:"managementCompanyLT,omitempty"`
	ManagementCompanyLTE          *string  `json:"managementCompanyLTE,omitempty"`
	ManagementCompanyContains     *string  `json:"managementCompanyContains,omitempty"`
	ManagementCompanyHasPrefix    *string  `json:"managementCompanyHasPrefix,omitempty"`
	ManagementCompanyHasSuffix    *string  `json:"managementCompanyHasSuffix,omitempty"`
	ManagementCompanyIsNil        bool     `json:"managementCompanyIsNil,omitempty"`
	ManagementCompanyNotNil       bool     `json:"managementCompanyNotNil,omitempty"`
	ManagementCompanyEqualFold    *string  `json:"managementCompanyEqualFold,omitempty"`
	ManagementCompanyContainsFold *string  `json:"managementCompanyContainsFold,omitempty"`

	// "tendering_agency" field predicates.
	TenderingAgency             *string  `json:"tenderingAgency,omitempty"`
	TenderingAgencyNEQ          *string  `json:"tenderingAgencyNEQ,omitempty"`
	TenderingAgencyIn           []string `json:"tenderingAgencyIn,omitempty"`
	TenderingAgencyNotIn        []string `json:"tenderingAgencyNotIn,omitempty"`
	TenderingAgencyGT           *string  `json:"tenderingAgencyGT,omitempty"`
	TenderingAgencyGTE          *string  `json:"tenderingAgencyGTE,omitempty"`
	TenderingAgencyLT           *string  `json:"tenderingAgencyLT,omitempty"`
	TenderingAgencyLTE          *string  `json:"tenderingAgencyLTE,omitempty"`
	TenderingAgencyContains     *string  `json:"tenderingAgencyContains,omitempty"`
	TenderingAgencyHasPrefix    *string  `json:"tenderingAgencyHasPrefix,omitempty"`
	TenderingAgencyHasSuffix    *string  `json:"tenderingAgencyHasSuffix,omitempty"`
	TenderingAgencyIsNil        bool     `json:"tenderingAgencyIsNil,omitempty"`
	TenderingAgencyNotNil       bool     `json:"tenderingAgencyNotNil,omitempty"`
	TenderingAgencyEqualFold    *string  `json:"tenderingAgencyEqualFold,omitempty"`
	TenderingAgencyContainsFold *string  `json:"tenderingAgencyContainsFold,omitempty"`

	// "bidding_date" field predicates.
	BiddingDate       *time.Time  `json:"biddingDate,omitempty"`
	BiddingDateNEQ    *time.Time  `json:"biddingDateNEQ,omitempty"`
	BiddingDateIn     []time.Time `json:"biddingDateIn,omitempty"`
	BiddingDateNotIn  []time.Time `json:"biddingDateNotIn,omitempty"`
	BiddingDateGT     *time.Time  `json:"biddingDateGT,omitempty"`
	BiddingDateGTE    *time.Time  `json:"biddingDateGTE,omitempty"`
	BiddingDateLT     *time.Time  `json:"biddingDateLT,omitempty"`
	BiddingDateLTE    *time.Time  `json:"biddingDateLTE,omitempty"`
	BiddingDateIsNil  bool        `json:"biddingDateIsNil,omitempty"`
	BiddingDateNotNil bool        `json:"biddingDateNotNil,omitempty"`

	// "facade_consultant" field predicates.
	FacadeConsultant             *string  `json:"facadeConsultant,omitempty"`
	FacadeConsultantNEQ          *string  `json:"facadeConsultantNEQ,omitempty"`
	FacadeConsultantIn           []string `json:"facadeConsultantIn,omitempty"`
	FacadeConsultantNotIn        []string `json:"facadeConsultantNotIn,omitempty"`
	FacadeConsultantGT           *string  `json:"facadeConsultantGT,omitempty"`
	FacadeConsultantGTE          *string  `json:"facadeConsultantGTE,omitempty"`
	FacadeConsultantLT           *string  `json:"facadeConsultantLT,omitempty"`
	FacadeConsultantLTE          *string  `json:"facadeConsultantLTE,omitempty"`
	FacadeConsultantContains     *string  `json:"facadeConsultantContains,omitempty"`
	FacadeConsultantHasPrefix    *string  `json:"facadeConsultantHasPrefix,omitempty"`
	FacadeConsultantHasSuffix    *string  `json:"facadeConsultantHasSuffix,omitempty"`
	FacadeConsultantIsNil        bool     `json:"facadeConsultantIsNil,omitempty"`
	FacadeConsultantNotNil       bool     `json:"facadeConsultantNotNil,omitempty"`
	FacadeConsultantEqualFold    *string  `json:"facadeConsultantEqualFold,omitempty"`
	FacadeConsultantContainsFold *string  `json:"facadeConsultantContainsFold,omitempty"`

	// "design_unit" field predicates.
	DesignUnit             *string  `json:"designUnit,omitempty"`
	DesignUnitNEQ          *string  `json:"designUnitNEQ,omitempty"`
	DesignUnitIn           []string `json:"designUnitIn,omitempty"`
	DesignUnitNotIn        []string `json:"designUnitNotIn,omitempty"`
	DesignUnitGT           *string  `json:"designUnitGT,omitempty"`
	DesignUnitGTE          *string  `json:"designUnitGTE,omitempty"`
	DesignUnitLT           *string  `json:"designUnitLT,omitempty"`
	DesignUnitLTE          *string  `json:"designUnitLTE,omitempty"`
	DesignUnitContains     *string  `json:"designUnitContains,omitempty"`
	DesignUnitHasPrefix    *string  `json:"designUnitHasPrefix,omitempty"`
	DesignUnitHasSuffix    *string  `json:"designUnitHasSuffix,omitempty"`
	DesignUnitIsNil        bool     `json:"designUnitIsNil,omitempty"`
	DesignUnitNotNil       bool     `json:"designUnitNotNil,omitempty"`
	DesignUnitEqualFold    *string  `json:"designUnitEqualFold,omitempty"`
	DesignUnitContainsFold *string  `json:"designUnitContainsFold,omitempty"`

	// "consulting_firm" field predicates.
	ConsultingFirm             *string  `json:"consultingFirm,omitempty"`
	ConsultingFirmNEQ          *string  `json:"consultingFirmNEQ,omitempty"`
	ConsultingFirmIn           []string `json:"consultingFirmIn,omitempty"`
	ConsultingFirmNotIn        []string `json:"consultingFirmNotIn,omitempty"`
	ConsultingFirmGT           *string  `json:"consultingFirmGT,omitempty"`
	ConsultingFirmGTE          *string  `json:"consultingFirmGTE,omitempty"`
	ConsultingFirmLT           *string  `json:"consultingFirmLT,omitempty"`
	ConsultingFirmLTE          *string  `json:"consultingFirmLTE,omitempty"`
	ConsultingFirmContains     *string  `json:"consultingFirmContains,omitempty"`
	ConsultingFirmHasPrefix    *string  `json:"consultingFirmHasPrefix,omitempty"`
	ConsultingFirmHasSuffix    *string  `json:"consultingFirmHasSuffix,omitempty"`
	ConsultingFirmIsNil        bool     `json:"consultingFirmIsNil,omitempty"`
	ConsultingFirmNotNil       bool     `json:"consultingFirmNotNil,omitempty"`
	ConsultingFirmEqualFold    *string  `json:"consultingFirmEqualFold,omitempty"`
	ConsultingFirmContainsFold *string  `json:"consultingFirmContainsFold,omitempty"`

	// "key_project" field predicates.
	KeyProject    *bool `json:"keyProject,omitempty"`
	KeyProjectNEQ *bool `json:"keyProjectNEQ,omitempty"`

	// "tender_win_company" field predicates.
	TenderWinCompany             *string  `json:"tenderWinCompany,omitempty"`
	TenderWinCompanyNEQ          *string  `json:"tenderWinCompanyNEQ,omitempty"`
	TenderWinCompanyIn           []string `json:"tenderWinCompanyIn,omitempty"`
	TenderWinCompanyNotIn        []string `json:"tenderWinCompanyNotIn,omitempty"`
	TenderWinCompanyGT           *string  `json:"tenderWinCompanyGT,omitempty"`
	TenderWinCompanyGTE          *string  `json:"tenderWinCompanyGTE,omitempty"`
	TenderWinCompanyLT           *string  `json:"tenderWinCompanyLT,omitempty"`
	TenderWinCompanyLTE          *string  `json:"tenderWinCompanyLTE,omitempty"`
	TenderWinCompanyContains     *string  `json:"tenderWinCompanyContains,omitempty"`
	TenderWinCompanyHasPrefix    *string  `json:"tenderWinCompanyHasPrefix,omitempty"`
	TenderWinCompanyHasSuffix    *string  `json:"tenderWinCompanyHasSuffix,omitempty"`
	TenderWinCompanyIsNil        bool     `json:"tenderWinCompanyIsNil,omitempty"`
	TenderWinCompanyNotNil       bool     `json:"tenderWinCompanyNotNil,omitempty"`
	TenderWinCompanyEqualFold    *string  `json:"tenderWinCompanyEqualFold,omitempty"`
	TenderWinCompanyContainsFold *string  `json:"tenderWinCompanyContainsFold,omitempty"`

	// "tender_code" field predicates.
	TenderCode             *string  `json:"tenderCode,omitempty"`
	TenderCodeNEQ          *string  `json:"tenderCodeNEQ,omitempty"`
	TenderCodeIn           []string `json:"tenderCodeIn,omitempty"`
	TenderCodeNotIn        []string `json:"tenderCodeNotIn,omitempty"`
	TenderCodeGT           *string  `json:"tenderCodeGT,omitempty"`
	TenderCodeGTE          *string  `json:"tenderCodeGTE,omitempty"`
	TenderCodeLT           *string  `json:"tenderCodeLT,omitempty"`
	TenderCodeLTE          *string  `json:"tenderCodeLTE,omitempty"`
	TenderCodeContains     *string  `json:"tenderCodeContains,omitempty"`
	TenderCodeHasPrefix    *string  `json:"tenderCodeHasPrefix,omitempty"`
	TenderCodeHasSuffix    *string  `json:"tenderCodeHasSuffix,omitempty"`
	TenderCodeIsNil        bool     `json:"tenderCodeIsNil,omitempty"`
	TenderCodeNotNil       bool     `json:"tenderCodeNotNil,omitempty"`
	TenderCodeEqualFold    *string  `json:"tenderCodeEqualFold,omitempty"`
	TenderCodeContainsFold *string  `json:"tenderCodeContainsFold,omitempty"`

	// "architect" field predicates.
	Architect             *string  `json:"architect,omitempty"`
	ArchitectNEQ          *string  `json:"architectNEQ,omitempty"`
	ArchitectIn           []string `json:"architectIn,omitempty"`
	ArchitectNotIn        []string `json:"architectNotIn,omitempty"`
	ArchitectGT           *string  `json:"architectGT,omitempty"`
	ArchitectGTE          *string  `json:"architectGTE,omitempty"`
	ArchitectLT           *string  `json:"architectLT,omitempty"`
	ArchitectLTE          *string  `json:"architectLTE,omitempty"`
	ArchitectContains     *string  `json:"architectContains,omitempty"`
	ArchitectHasPrefix    *string  `json:"architectHasPrefix,omitempty"`
	ArchitectHasSuffix    *string  `json:"architectHasSuffix,omitempty"`
	ArchitectIsNil        bool     `json:"architectIsNil,omitempty"`
	ArchitectNotNil       bool     `json:"architectNotNil,omitempty"`
	ArchitectEqualFold    *string  `json:"architectEqualFold,omitempty"`
	ArchitectContainsFold *string  `json:"architectContainsFold,omitempty"`

	// "developer" field predicates.
	Developer             *string  `json:"developer,omitempty"`
	DeveloperNEQ          *string  `json:"developerNEQ,omitempty"`
	DeveloperIn           []string `json:"developerIn,omitempty"`
	DeveloperNotIn        []string `json:"developerNotIn,omitempty"`
	DeveloperGT           *string  `json:"developerGT,omitempty"`
	DeveloperGTE          *string  `json:"developerGTE,omitempty"`
	DeveloperLT           *string  `json:"developerLT,omitempty"`
	DeveloperLTE          *string  `json:"developerLTE,omitempty"`
	DeveloperContains     *string  `json:"developerContains,omitempty"`
	DeveloperHasPrefix    *string  `json:"developerHasPrefix,omitempty"`
	DeveloperHasSuffix    *string  `json:"developerHasSuffix,omitempty"`
	DeveloperIsNil        bool     `json:"developerIsNil,omitempty"`
	DeveloperNotNil       bool     `json:"developerNotNil,omitempty"`
	DeveloperEqualFold    *string  `json:"developerEqualFold,omitempty"`
	DeveloperContainsFold *string  `json:"developerContainsFold,omitempty"`

	// "tender_closing_date" field predicates.
	TenderClosingDate       *time.Time  `json:"tenderClosingDate,omitempty"`
	TenderClosingDateNEQ    *time.Time  `json:"tenderClosingDateNEQ,omitempty"`
	TenderClosingDateIn     []time.Time `json:"tenderClosingDateIn,omitempty"`
	TenderClosingDateNotIn  []time.Time `json:"tenderClosingDateNotIn,omitempty"`
	TenderClosingDateGT     *time.Time  `json:"tenderClosingDateGT,omitempty"`
	TenderClosingDateGTE    *time.Time  `json:"tenderClosingDateGTE,omitempty"`
	TenderClosingDateLT     *time.Time  `json:"tenderClosingDateLT,omitempty"`
	TenderClosingDateLTE    *time.Time  `json:"tenderClosingDateLTE,omitempty"`
	TenderClosingDateIsNil  bool        `json:"tenderClosingDateIsNil,omitempty"`
	TenderClosingDateNotNil bool        `json:"tenderClosingDateNotNil,omitempty"`

	// "construction_area" field predicates.
	ConstructionArea             *string  `json:"constructionArea,omitempty"`
	ConstructionAreaNEQ          *string  `json:"constructionAreaNEQ,omitempty"`
	ConstructionAreaIn           []string `json:"constructionAreaIn,omitempty"`
	ConstructionAreaNotIn        []string `json:"constructionAreaNotIn,omitempty"`
	ConstructionAreaGT           *string  `json:"constructionAreaGT,omitempty"`
	ConstructionAreaGTE          *string  `json:"constructionAreaGTE,omitempty"`
	ConstructionAreaLT           *string  `json:"constructionAreaLT,omitempty"`
	ConstructionAreaLTE          *string  `json:"constructionAreaLTE,omitempty"`
	ConstructionAreaContains     *string  `json:"constructionAreaContains,omitempty"`
	ConstructionAreaHasPrefix    *string  `json:"constructionAreaHasPrefix,omitempty"`
	ConstructionAreaHasSuffix    *string  `json:"constructionAreaHasSuffix,omitempty"`
	ConstructionAreaIsNil        bool     `json:"constructionAreaIsNil,omitempty"`
	ConstructionAreaNotNil       bool     `json:"constructionAreaNotNil,omitempty"`
	ConstructionAreaEqualFold    *string  `json:"constructionAreaEqualFold,omitempty"`
	ConstructionAreaContainsFold *string  `json:"constructionAreaContainsFold,omitempty"`

	// "tender_win_date" field predicates.
	TenderWinDate       *time.Time  `json:"tenderWinDate,omitempty"`
	TenderWinDateNEQ    *time.Time  `json:"tenderWinDateNEQ,omitempty"`
	TenderWinDateIn     []time.Time `json:"tenderWinDateIn,omitempty"`
	TenderWinDateNotIn  []time.Time `json:"tenderWinDateNotIn,omitempty"`
	TenderWinDateGT     *time.Time  `json:"tenderWinDateGT,omitempty"`
	TenderWinDateGTE    *time.Time  `json:"tenderWinDateGTE,omitempty"`
	TenderWinDateLT     *time.Time  `json:"tenderWinDateLT,omitempty"`
	TenderWinDateLTE    *time.Time  `json:"tenderWinDateLTE,omitempty"`
	TenderWinDateIsNil  bool        `json:"tenderWinDateIsNil,omitempty"`
	TenderWinDateNotNil bool        `json:"tenderWinDateNotNil,omitempty"`

	// "tender_win_amount" field predicates.
	TenderWinAmount       *float64  `json:"tenderWinAmount,omitempty"`
	TenderWinAmountNEQ    *float64  `json:"tenderWinAmountNEQ,omitempty"`
	TenderWinAmountIn     []float64 `json:"tenderWinAmountIn,omitempty"`
	TenderWinAmountNotIn  []float64 `json:"tenderWinAmountNotIn,omitempty"`
	TenderWinAmountGT     *float64  `json:"tenderWinAmountGT,omitempty"`
	TenderWinAmountGTE    *float64  `json:"tenderWinAmountGTE,omitempty"`
	TenderWinAmountLT     *float64  `json:"tenderWinAmountLT,omitempty"`
	TenderWinAmountLTE    *float64  `json:"tenderWinAmountLTE,omitempty"`
	TenderWinAmountIsNil  bool      `json:"tenderWinAmountIsNil,omitempty"`
	TenderWinAmountNotNil bool      `json:"tenderWinAmountNotNil,omitempty"`

	// "last_tender_amount" field predicates.
	LastTenderAmount       *float64  `json:"lastTenderAmount,omitempty"`
	LastTenderAmountNEQ    *float64  `json:"lastTenderAmountNEQ,omitempty"`
	LastTenderAmountIn     []float64 `json:"lastTenderAmountIn,omitempty"`
	LastTenderAmountNotIn  []float64 `json:"lastTenderAmountNotIn,omitempty"`
	LastTenderAmountGT     *float64  `json:"lastTenderAmountGT,omitempty"`
	LastTenderAmountGTE    *float64  `json:"lastTenderAmountGTE,omitempty"`
	LastTenderAmountLT     *float64  `json:"lastTenderAmountLT,omitempty"`
	LastTenderAmountLTE    *float64  `json:"lastTenderAmountLTE,omitempty"`
	LastTenderAmountIsNil  bool      `json:"lastTenderAmountIsNil,omitempty"`
	LastTenderAmountNotNil bool      `json:"lastTenderAmountNotNil,omitempty"`

	// "area_id" field predicates.
	AreaID             *xid.ID  `json:"areaID,omitempty"`
	AreaIDNEQ          *xid.ID  `json:"areaIDNEQ,omitempty"`
	AreaIDIn           []xid.ID `json:"areaIDIn,omitempty"`
	AreaIDNotIn        []xid.ID `json:"areaIDNotIn,omitempty"`
	AreaIDGT           *xid.ID  `json:"areaIDGT,omitempty"`
	AreaIDGTE          *xid.ID  `json:"areaIDGTE,omitempty"`
	AreaIDLT           *xid.ID  `json:"areaIDLT,omitempty"`
	AreaIDLTE          *xid.ID  `json:"areaIDLTE,omitempty"`
	AreaIDContains     *xid.ID  `json:"areaIDContains,omitempty"`
	AreaIDHasPrefix    *xid.ID  `json:"areaIDHasPrefix,omitempty"`
	AreaIDHasSuffix    *xid.ID  `json:"areaIDHasSuffix,omitempty"`
	AreaIDEqualFold    *xid.ID  `json:"areaIDEqualFold,omitempty"`
	AreaIDContainsFold *xid.ID  `json:"areaIDContainsFold,omitempty"`

	// "province_id" field predicates.
	ProvinceID             *xid.ID  `json:"provinceID,omitempty"`
	ProvinceIDNEQ          *xid.ID  `json:"provinceIDNEQ,omitempty"`
	ProvinceIDIn           []xid.ID `json:"provinceIDIn,omitempty"`
	ProvinceIDNotIn        []xid.ID `json:"provinceIDNotIn,omitempty"`
	ProvinceIDGT           *xid.ID  `json:"provinceIDGT,omitempty"`
	ProvinceIDGTE          *xid.ID  `json:"provinceIDGTE,omitempty"`
	ProvinceIDLT           *xid.ID  `json:"provinceIDLT,omitempty"`
	ProvinceIDLTE          *xid.ID  `json:"provinceIDLTE,omitempty"`
	ProvinceIDContains     *xid.ID  `json:"provinceIDContains,omitempty"`
	ProvinceIDHasPrefix    *xid.ID  `json:"provinceIDHasPrefix,omitempty"`
	ProvinceIDHasSuffix    *xid.ID  `json:"provinceIDHasSuffix,omitempty"`
	ProvinceIDIsNil        bool     `json:"provinceIDIsNil,omitempty"`
	ProvinceIDNotNil       bool     `json:"provinceIDNotNil,omitempty"`
	ProvinceIDEqualFold    *xid.ID  `json:"provinceIDEqualFold,omitempty"`
	ProvinceIDContainsFold *xid.ID  `json:"provinceIDContainsFold,omitempty"`

	// "city_id" field predicates.
	CityID             *xid.ID  `json:"cityID,omitempty"`
	CityIDNEQ          *xid.ID  `json:"cityIDNEQ,omitempty"`
	CityIDIn           []xid.ID `json:"cityIDIn,omitempty"`
	CityIDNotIn        []xid.ID `json:"cityIDNotIn,omitempty"`
	CityIDGT           *xid.ID  `json:"cityIDGT,omitempty"`
	CityIDGTE          *xid.ID  `json:"cityIDGTE,omitempty"`
	CityIDLT           *xid.ID  `json:"cityIDLT,omitempty"`
	CityIDLTE          *xid.ID  `json:"cityIDLTE,omitempty"`
	CityIDContains     *xid.ID  `json:"cityIDContains,omitempty"`
	CityIDHasPrefix    *xid.ID  `json:"cityIDHasPrefix,omitempty"`
	CityIDHasSuffix    *xid.ID  `json:"cityIDHasSuffix,omitempty"`
	CityIDIsNil        bool     `json:"cityIDIsNil,omitempty"`
	CityIDNotNil       bool     `json:"cityIDNotNil,omitempty"`
	CityIDEqualFold    *xid.ID  `json:"cityIDEqualFold,omitempty"`
	CityIDContainsFold *xid.ID  `json:"cityIDContainsFold,omitempty"`

	// "district_id" field predicates.
	DistrictID             *xid.ID  `json:"districtID,omitempty"`
	DistrictIDNEQ          *xid.ID  `json:"districtIDNEQ,omitempty"`
	DistrictIDIn           []xid.ID `json:"districtIDIn,omitempty"`
	DistrictIDNotIn        []xid.ID `json:"districtIDNotIn,omitempty"`
	DistrictIDGT           *xid.ID  `json:"districtIDGT,omitempty"`
	DistrictIDGTE          *xid.ID  `json:"districtIDGTE,omitempty"`
	DistrictIDLT           *xid.ID  `json:"districtIDLT,omitempty"`
	DistrictIDLTE          *xid.ID  `json:"districtIDLTE,omitempty"`
	DistrictIDContains     *xid.ID  `json:"districtIDContains,omitempty"`
	DistrictIDHasPrefix    *xid.ID  `json:"districtIDHasPrefix,omitempty"`
	DistrictIDHasSuffix    *xid.ID  `json:"districtIDHasSuffix,omitempty"`
	DistrictIDIsNil        bool     `json:"districtIDIsNil,omitempty"`
	DistrictIDNotNil       bool     `json:"districtIDNotNil,omitempty"`
	DistrictIDEqualFold    *xid.ID  `json:"districtIDEqualFold,omitempty"`
	DistrictIDContainsFold *xid.ID  `json:"districtIDContainsFold,omitempty"`

	// "customer_id" field predicates.
	CustomerID             *xid.ID  `json:"customerID,omitempty"`
	CustomerIDNEQ          *xid.ID  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn           []xid.ID `json:"customerIDIn,omitempty"`
	CustomerIDNotIn        []xid.ID `json:"customerIDNotIn,omitempty"`
	CustomerIDGT           *xid.ID  `json:"customerIDGT,omitempty"`
	CustomerIDGTE          *xid.ID  `json:"customerIDGTE,omitempty"`
	CustomerIDLT           *xid.ID  `json:"customerIDLT,omitempty"`
	CustomerIDLTE          *xid.ID  `json:"customerIDLTE,omitempty"`
	CustomerIDContains     *xid.ID  `json:"customerIDContains,omitempty"`
	CustomerIDHasPrefix    *xid.ID  `json:"customerIDHasPrefix,omitempty"`
	CustomerIDHasSuffix    *xid.ID  `json:"customerIDHasSuffix,omitempty"`
	CustomerIDIsNil        bool     `json:"customerIDIsNil,omitempty"`
	CustomerIDNotNil       bool     `json:"customerIDNotNil,omitempty"`
	CustomerIDEqualFold    *xid.ID  `json:"customerIDEqualFold,omitempty"`
	CustomerIDContainsFold *xid.ID  `json:"customerIDContainsFold,omitempty"`

	// "finder_id" field predicates.
	FinderID             *xid.ID  `json:"finderID,omitempty"`
	FinderIDNEQ          *xid.ID  `json:"finderIDNEQ,omitempty"`
	FinderIDIn           []xid.ID `json:"finderIDIn,omitempty"`
	FinderIDNotIn        []xid.ID `json:"finderIDNotIn,omitempty"`
	FinderIDGT           *xid.ID  `json:"finderIDGT,omitempty"`
	FinderIDGTE          *xid.ID  `json:"finderIDGTE,omitempty"`
	FinderIDLT           *xid.ID  `json:"finderIDLT,omitempty"`
	FinderIDLTE          *xid.ID  `json:"finderIDLTE,omitempty"`
	FinderIDContains     *xid.ID  `json:"finderIDContains,omitempty"`
	FinderIDHasPrefix    *xid.ID  `json:"finderIDHasPrefix,omitempty"`
	FinderIDHasSuffix    *xid.ID  `json:"finderIDHasSuffix,omitempty"`
	FinderIDEqualFold    *xid.ID  `json:"finderIDEqualFold,omitempty"`
	FinderIDContainsFold *xid.ID  `json:"finderIDContainsFold,omitempty"`

	// "created_by_id" field predicates.
	CreatedByID             *xid.ID  `json:"createdByID,omitempty"`
	CreatedByIDNEQ          *xid.ID  `json:"createdByIDNEQ,omitempty"`
	CreatedByIDIn           []xid.ID `json:"createdByIDIn,omitempty"`
	CreatedByIDNotIn        []xid.ID `json:"createdByIDNotIn,omitempty"`
	CreatedByIDGT           *xid.ID  `json:"createdByIDGT,omitempty"`
	CreatedByIDGTE          *xid.ID  `json:"createdByIDGTE,omitempty"`
	CreatedByIDLT           *xid.ID  `json:"createdByIDLT,omitempty"`
	CreatedByIDLTE          *xid.ID  `json:"createdByIDLTE,omitempty"`
	CreatedByIDContains     *xid.ID  `json:"createdByIDContains,omitempty"`
	CreatedByIDHasPrefix    *xid.ID  `json:"createdByIDHasPrefix,omitempty"`
	CreatedByIDHasSuffix    *xid.ID  `json:"createdByIDHasSuffix,omitempty"`
	CreatedByIDEqualFold    *xid.ID  `json:"createdByIDEqualFold,omitempty"`
	CreatedByIDContainsFold *xid.ID  `json:"createdByIDContainsFold,omitempty"`

	// "area" edge predicates.
	HasArea     *bool             `json:"hasArea,omitempty"`
	HasAreaWith []*AreaWhereInput `json:"hasAreaWith,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`

	// "finder" edge predicates.
	HasFinder     *bool             `json:"hasFinder,omitempty"`
	HasFinderWith []*UserWhereInput `json:"hasFinderWith,omitempty"`

	// "created_by" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "following_sales" edge predicates.
	HasFollowingSales     *bool             `json:"hasFollowingSales,omitempty"`
	HasFollowingSalesWith []*UserWhereInput `json:"hasFollowingSalesWith,omitempty"`

	// "province" edge predicates.
	HasProvince     *bool                 `json:"hasProvince,omitempty"`
	HasProvinceWith []*ProvinceWhereInput `json:"hasProvinceWith,omitempty"`

	// "city" edge predicates.
	HasCity     *bool             `json:"hasCity,omitempty"`
	HasCityWith []*CityWhereInput `json:"hasCityWith,omitempty"`

	// "district" edge predicates.
	HasDistrict     *bool                 `json:"hasDistrict,omitempty"`
	HasDistrictWith []*DistrictWhereInput `json:"hasDistrictWith,omitempty"`

	// "visit_records" edge predicates.
	HasVisitRecords     *bool                    `json:"hasVisitRecords,omitempty"`
	HasVisitRecordsWith []*VisitRecordWhereInput `json:"hasVisitRecordsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TenderWhereInput) AddPredicates(predicates ...predicate.Tender) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TenderWhereInput filter on the TenderQuery builder.
func (i *TenderWhereInput) Filter(q *TenderQuery) (*TenderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTenderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTenderWhereInput is returned in case the TenderWhereInput is empty.
var ErrEmptyTenderWhereInput = errors.New("ent: empty predicate TenderWhereInput")

// P returns a predicate for filtering tenders.
// An error is returned if the input is empty or invalid.
func (i *TenderWhereInput) P() (predicate.Tender, error) {
	var predicates []predicate.Tender
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tender.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tender, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tender.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tender, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tender.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tender.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tender.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tender.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tender.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tender.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tender.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tender.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tender.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tender.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tender.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tender.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tender.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tender.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tender.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tender.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tender.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, tender.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, tender.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, tender.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, tender.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, tender.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, tender.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, tender.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, tender.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, tender.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, tender.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, tender.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, tender.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, tender.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, tender.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, tender.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, tender.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, tender.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, tender.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, tender.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, tender.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, tender.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, tender.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, tender.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, tender.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, tender.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, tender.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, tender.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, tender.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, tender.StatusLTE(*i.StatusLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tender.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tender.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tender.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tender.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tender.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tender.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tender.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tender.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tender.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tender.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tender.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tender.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tender.NameContainsFold(*i.NameContainsFold))
	}
	if i.EstimatedAmount != nil {
		predicates = append(predicates, tender.EstimatedAmountEQ(*i.EstimatedAmount))
	}
	if i.EstimatedAmountNEQ != nil {
		predicates = append(predicates, tender.EstimatedAmountNEQ(*i.EstimatedAmountNEQ))
	}
	if len(i.EstimatedAmountIn) > 0 {
		predicates = append(predicates, tender.EstimatedAmountIn(i.EstimatedAmountIn...))
	}
	if len(i.EstimatedAmountNotIn) > 0 {
		predicates = append(predicates, tender.EstimatedAmountNotIn(i.EstimatedAmountNotIn...))
	}
	if i.EstimatedAmountGT != nil {
		predicates = append(predicates, tender.EstimatedAmountGT(*i.EstimatedAmountGT))
	}
	if i.EstimatedAmountGTE != nil {
		predicates = append(predicates, tender.EstimatedAmountGTE(*i.EstimatedAmountGTE))
	}
	if i.EstimatedAmountLT != nil {
		predicates = append(predicates, tender.EstimatedAmountLT(*i.EstimatedAmountLT))
	}
	if i.EstimatedAmountLTE != nil {
		predicates = append(predicates, tender.EstimatedAmountLTE(*i.EstimatedAmountLTE))
	}
	if i.EstimatedAmountIsNil {
		predicates = append(predicates, tender.EstimatedAmountIsNil())
	}
	if i.EstimatedAmountNotNil {
		predicates = append(predicates, tender.EstimatedAmountNotNil())
	}
	if i.TenderDate != nil {
		predicates = append(predicates, tender.TenderDateEQ(*i.TenderDate))
	}
	if i.TenderDateNEQ != nil {
		predicates = append(predicates, tender.TenderDateNEQ(*i.TenderDateNEQ))
	}
	if len(i.TenderDateIn) > 0 {
		predicates = append(predicates, tender.TenderDateIn(i.TenderDateIn...))
	}
	if len(i.TenderDateNotIn) > 0 {
		predicates = append(predicates, tender.TenderDateNotIn(i.TenderDateNotIn...))
	}
	if i.TenderDateGT != nil {
		predicates = append(predicates, tender.TenderDateGT(*i.TenderDateGT))
	}
	if i.TenderDateGTE != nil {
		predicates = append(predicates, tender.TenderDateGTE(*i.TenderDateGTE))
	}
	if i.TenderDateLT != nil {
		predicates = append(predicates, tender.TenderDateLT(*i.TenderDateLT))
	}
	if i.TenderDateLTE != nil {
		predicates = append(predicates, tender.TenderDateLTE(*i.TenderDateLTE))
	}
	if i.TenderDateIsNil {
		predicates = append(predicates, tender.TenderDateIsNil())
	}
	if i.TenderDateNotNil {
		predicates = append(predicates, tender.TenderDateNotNil())
	}
	if i.DiscoveryDate != nil {
		predicates = append(predicates, tender.DiscoveryDateEQ(*i.DiscoveryDate))
	}
	if i.DiscoveryDateNEQ != nil {
		predicates = append(predicates, tender.DiscoveryDateNEQ(*i.DiscoveryDateNEQ))
	}
	if len(i.DiscoveryDateIn) > 0 {
		predicates = append(predicates, tender.DiscoveryDateIn(i.DiscoveryDateIn...))
	}
	if len(i.DiscoveryDateNotIn) > 0 {
		predicates = append(predicates, tender.DiscoveryDateNotIn(i.DiscoveryDateNotIn...))
	}
	if i.DiscoveryDateGT != nil {
		predicates = append(predicates, tender.DiscoveryDateGT(*i.DiscoveryDateGT))
	}
	if i.DiscoveryDateGTE != nil {
		predicates = append(predicates, tender.DiscoveryDateGTE(*i.DiscoveryDateGTE))
	}
	if i.DiscoveryDateLT != nil {
		predicates = append(predicates, tender.DiscoveryDateLT(*i.DiscoveryDateLT))
	}
	if i.DiscoveryDateLTE != nil {
		predicates = append(predicates, tender.DiscoveryDateLTE(*i.DiscoveryDateLTE))
	}
	if i.Address != nil {
		predicates = append(predicates, tender.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, tender.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, tender.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, tender.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, tender.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, tender.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, tender.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, tender.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, tender.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, tender.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, tender.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, tender.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, tender.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, tender.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, tender.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.FullAddress != nil {
		predicates = append(predicates, tender.FullAddressEQ(*i.FullAddress))
	}
	if i.FullAddressNEQ != nil {
		predicates = append(predicates, tender.FullAddressNEQ(*i.FullAddressNEQ))
	}
	if len(i.FullAddressIn) > 0 {
		predicates = append(predicates, tender.FullAddressIn(i.FullAddressIn...))
	}
	if len(i.FullAddressNotIn) > 0 {
		predicates = append(predicates, tender.FullAddressNotIn(i.FullAddressNotIn...))
	}
	if i.FullAddressGT != nil {
		predicates = append(predicates, tender.FullAddressGT(*i.FullAddressGT))
	}
	if i.FullAddressGTE != nil {
		predicates = append(predicates, tender.FullAddressGTE(*i.FullAddressGTE))
	}
	if i.FullAddressLT != nil {
		predicates = append(predicates, tender.FullAddressLT(*i.FullAddressLT))
	}
	if i.FullAddressLTE != nil {
		predicates = append(predicates, tender.FullAddressLTE(*i.FullAddressLTE))
	}
	if i.FullAddressContains != nil {
		predicates = append(predicates, tender.FullAddressContains(*i.FullAddressContains))
	}
	if i.FullAddressHasPrefix != nil {
		predicates = append(predicates, tender.FullAddressHasPrefix(*i.FullAddressHasPrefix))
	}
	if i.FullAddressHasSuffix != nil {
		predicates = append(predicates, tender.FullAddressHasSuffix(*i.FullAddressHasSuffix))
	}
	if i.FullAddressIsNil {
		predicates = append(predicates, tender.FullAddressIsNil())
	}
	if i.FullAddressNotNil {
		predicates = append(predicates, tender.FullAddressNotNil())
	}
	if i.FullAddressEqualFold != nil {
		predicates = append(predicates, tender.FullAddressEqualFold(*i.FullAddressEqualFold))
	}
	if i.FullAddressContainsFold != nil {
		predicates = append(predicates, tender.FullAddressContainsFold(*i.FullAddressContainsFold))
	}
	if i.Contractor != nil {
		predicates = append(predicates, tender.ContractorEQ(*i.Contractor))
	}
	if i.ContractorNEQ != nil {
		predicates = append(predicates, tender.ContractorNEQ(*i.ContractorNEQ))
	}
	if len(i.ContractorIn) > 0 {
		predicates = append(predicates, tender.ContractorIn(i.ContractorIn...))
	}
	if len(i.ContractorNotIn) > 0 {
		predicates = append(predicates, tender.ContractorNotIn(i.ContractorNotIn...))
	}
	if i.ContractorGT != nil {
		predicates = append(predicates, tender.ContractorGT(*i.ContractorGT))
	}
	if i.ContractorGTE != nil {
		predicates = append(predicates, tender.ContractorGTE(*i.ContractorGTE))
	}
	if i.ContractorLT != nil {
		predicates = append(predicates, tender.ContractorLT(*i.ContractorLT))
	}
	if i.ContractorLTE != nil {
		predicates = append(predicates, tender.ContractorLTE(*i.ContractorLTE))
	}
	if i.ContractorContains != nil {
		predicates = append(predicates, tender.ContractorContains(*i.ContractorContains))
	}
	if i.ContractorHasPrefix != nil {
		predicates = append(predicates, tender.ContractorHasPrefix(*i.ContractorHasPrefix))
	}
	if i.ContractorHasSuffix != nil {
		predicates = append(predicates, tender.ContractorHasSuffix(*i.ContractorHasSuffix))
	}
	if i.ContractorIsNil {
		predicates = append(predicates, tender.ContractorIsNil())
	}
	if i.ContractorNotNil {
		predicates = append(predicates, tender.ContractorNotNil())
	}
	if i.ContractorEqualFold != nil {
		predicates = append(predicates, tender.ContractorEqualFold(*i.ContractorEqualFold))
	}
	if i.ContractorContainsFold != nil {
		predicates = append(predicates, tender.ContractorContainsFold(*i.ContractorContainsFold))
	}
	if i.SizeAndValueRating != nil {
		predicates = append(predicates, tender.SizeAndValueRatingEQ(*i.SizeAndValueRating))
	}
	if i.SizeAndValueRatingNEQ != nil {
		predicates = append(predicates, tender.SizeAndValueRatingNEQ(*i.SizeAndValueRatingNEQ))
	}
	if len(i.SizeAndValueRatingIn) > 0 {
		predicates = append(predicates, tender.SizeAndValueRatingIn(i.SizeAndValueRatingIn...))
	}
	if len(i.SizeAndValueRatingNotIn) > 0 {
		predicates = append(predicates, tender.SizeAndValueRatingNotIn(i.SizeAndValueRatingNotIn...))
	}
	if i.SizeAndValueRatingGT != nil {
		predicates = append(predicates, tender.SizeAndValueRatingGT(*i.SizeAndValueRatingGT))
	}
	if i.SizeAndValueRatingGTE != nil {
		predicates = append(predicates, tender.SizeAndValueRatingGTE(*i.SizeAndValueRatingGTE))
	}
	if i.SizeAndValueRatingLT != nil {
		predicates = append(predicates, tender.SizeAndValueRatingLT(*i.SizeAndValueRatingLT))
	}
	if i.SizeAndValueRatingLTE != nil {
		predicates = append(predicates, tender.SizeAndValueRatingLTE(*i.SizeAndValueRatingLTE))
	}
	if i.SizeAndValueRatingIsNil {
		predicates = append(predicates, tender.SizeAndValueRatingIsNil())
	}
	if i.SizeAndValueRatingNotNil {
		predicates = append(predicates, tender.SizeAndValueRatingNotNil())
	}
	if i.SizeAndValueRatingOverview != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewEQ(*i.SizeAndValueRatingOverview))
	}
	if i.SizeAndValueRatingOverviewNEQ != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewNEQ(*i.SizeAndValueRatingOverviewNEQ))
	}
	if len(i.SizeAndValueRatingOverviewIn) > 0 {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewIn(i.SizeAndValueRatingOverviewIn...))
	}
	if len(i.SizeAndValueRatingOverviewNotIn) > 0 {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewNotIn(i.SizeAndValueRatingOverviewNotIn...))
	}
	if i.SizeAndValueRatingOverviewGT != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewGT(*i.SizeAndValueRatingOverviewGT))
	}
	if i.SizeAndValueRatingOverviewGTE != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewGTE(*i.SizeAndValueRatingOverviewGTE))
	}
	if i.SizeAndValueRatingOverviewLT != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewLT(*i.SizeAndValueRatingOverviewLT))
	}
	if i.SizeAndValueRatingOverviewLTE != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewLTE(*i.SizeAndValueRatingOverviewLTE))
	}
	if i.SizeAndValueRatingOverviewContains != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewContains(*i.SizeAndValueRatingOverviewContains))
	}
	if i.SizeAndValueRatingOverviewHasPrefix != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewHasPrefix(*i.SizeAndValueRatingOverviewHasPrefix))
	}
	if i.SizeAndValueRatingOverviewHasSuffix != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewHasSuffix(*i.SizeAndValueRatingOverviewHasSuffix))
	}
	if i.SizeAndValueRatingOverviewIsNil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewIsNil())
	}
	if i.SizeAndValueRatingOverviewNotNil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewNotNil())
	}
	if i.SizeAndValueRatingOverviewEqualFold != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewEqualFold(*i.SizeAndValueRatingOverviewEqualFold))
	}
	if i.SizeAndValueRatingOverviewContainsFold != nil {
		predicates = append(predicates, tender.SizeAndValueRatingOverviewContainsFold(*i.SizeAndValueRatingOverviewContainsFold))
	}
	if i.CreditAndPaymentRating != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingEQ(*i.CreditAndPaymentRating))
	}
	if i.CreditAndPaymentRatingNEQ != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingNEQ(*i.CreditAndPaymentRatingNEQ))
	}
	if len(i.CreditAndPaymentRatingIn) > 0 {
		predicates = append(predicates, tender.CreditAndPaymentRatingIn(i.CreditAndPaymentRatingIn...))
	}
	if len(i.CreditAndPaymentRatingNotIn) > 0 {
		predicates = append(predicates, tender.CreditAndPaymentRatingNotIn(i.CreditAndPaymentRatingNotIn...))
	}
	if i.CreditAndPaymentRatingGT != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingGT(*i.CreditAndPaymentRatingGT))
	}
	if i.CreditAndPaymentRatingGTE != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingGTE(*i.CreditAndPaymentRatingGTE))
	}
	if i.CreditAndPaymentRatingLT != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingLT(*i.CreditAndPaymentRatingLT))
	}
	if i.CreditAndPaymentRatingLTE != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingLTE(*i.CreditAndPaymentRatingLTE))
	}
	if i.CreditAndPaymentRatingIsNil {
		predicates = append(predicates, tender.CreditAndPaymentRatingIsNil())
	}
	if i.CreditAndPaymentRatingNotNil {
		predicates = append(predicates, tender.CreditAndPaymentRatingNotNil())
	}
	if i.CreditAndPaymentRatingOverview != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewEQ(*i.CreditAndPaymentRatingOverview))
	}
	if i.CreditAndPaymentRatingOverviewNEQ != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewNEQ(*i.CreditAndPaymentRatingOverviewNEQ))
	}
	if len(i.CreditAndPaymentRatingOverviewIn) > 0 {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewIn(i.CreditAndPaymentRatingOverviewIn...))
	}
	if len(i.CreditAndPaymentRatingOverviewNotIn) > 0 {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewNotIn(i.CreditAndPaymentRatingOverviewNotIn...))
	}
	if i.CreditAndPaymentRatingOverviewGT != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewGT(*i.CreditAndPaymentRatingOverviewGT))
	}
	if i.CreditAndPaymentRatingOverviewGTE != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewGTE(*i.CreditAndPaymentRatingOverviewGTE))
	}
	if i.CreditAndPaymentRatingOverviewLT != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewLT(*i.CreditAndPaymentRatingOverviewLT))
	}
	if i.CreditAndPaymentRatingOverviewLTE != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewLTE(*i.CreditAndPaymentRatingOverviewLTE))
	}
	if i.CreditAndPaymentRatingOverviewContains != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewContains(*i.CreditAndPaymentRatingOverviewContains))
	}
	if i.CreditAndPaymentRatingOverviewHasPrefix != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewHasPrefix(*i.CreditAndPaymentRatingOverviewHasPrefix))
	}
	if i.CreditAndPaymentRatingOverviewHasSuffix != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewHasSuffix(*i.CreditAndPaymentRatingOverviewHasSuffix))
	}
	if i.CreditAndPaymentRatingOverviewIsNil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewIsNil())
	}
	if i.CreditAndPaymentRatingOverviewNotNil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewNotNil())
	}
	if i.CreditAndPaymentRatingOverviewEqualFold != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewEqualFold(*i.CreditAndPaymentRatingOverviewEqualFold))
	}
	if i.CreditAndPaymentRatingOverviewContainsFold != nil {
		predicates = append(predicates, tender.CreditAndPaymentRatingOverviewContainsFold(*i.CreditAndPaymentRatingOverviewContainsFold))
	}
	if i.TimeLimitRating != nil {
		predicates = append(predicates, tender.TimeLimitRatingEQ(*i.TimeLimitRating))
	}
	if i.TimeLimitRatingNEQ != nil {
		predicates = append(predicates, tender.TimeLimitRatingNEQ(*i.TimeLimitRatingNEQ))
	}
	if len(i.TimeLimitRatingIn) > 0 {
		predicates = append(predicates, tender.TimeLimitRatingIn(i.TimeLimitRatingIn...))
	}
	if len(i.TimeLimitRatingNotIn) > 0 {
		predicates = append(predicates, tender.TimeLimitRatingNotIn(i.TimeLimitRatingNotIn...))
	}
	if i.TimeLimitRatingGT != nil {
		predicates = append(predicates, tender.TimeLimitRatingGT(*i.TimeLimitRatingGT))
	}
	if i.TimeLimitRatingGTE != nil {
		predicates = append(predicates, tender.TimeLimitRatingGTE(*i.TimeLimitRatingGTE))
	}
	if i.TimeLimitRatingLT != nil {
		predicates = append(predicates, tender.TimeLimitRatingLT(*i.TimeLimitRatingLT))
	}
	if i.TimeLimitRatingLTE != nil {
		predicates = append(predicates, tender.TimeLimitRatingLTE(*i.TimeLimitRatingLTE))
	}
	if i.TimeLimitRatingIsNil {
		predicates = append(predicates, tender.TimeLimitRatingIsNil())
	}
	if i.TimeLimitRatingNotNil {
		predicates = append(predicates, tender.TimeLimitRatingNotNil())
	}
	if i.TimeLimitRatingOverview != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewEQ(*i.TimeLimitRatingOverview))
	}
	if i.TimeLimitRatingOverviewNEQ != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewNEQ(*i.TimeLimitRatingOverviewNEQ))
	}
	if len(i.TimeLimitRatingOverviewIn) > 0 {
		predicates = append(predicates, tender.TimeLimitRatingOverviewIn(i.TimeLimitRatingOverviewIn...))
	}
	if len(i.TimeLimitRatingOverviewNotIn) > 0 {
		predicates = append(predicates, tender.TimeLimitRatingOverviewNotIn(i.TimeLimitRatingOverviewNotIn...))
	}
	if i.TimeLimitRatingOverviewGT != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewGT(*i.TimeLimitRatingOverviewGT))
	}
	if i.TimeLimitRatingOverviewGTE != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewGTE(*i.TimeLimitRatingOverviewGTE))
	}
	if i.TimeLimitRatingOverviewLT != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewLT(*i.TimeLimitRatingOverviewLT))
	}
	if i.TimeLimitRatingOverviewLTE != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewLTE(*i.TimeLimitRatingOverviewLTE))
	}
	if i.TimeLimitRatingOverviewContains != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewContains(*i.TimeLimitRatingOverviewContains))
	}
	if i.TimeLimitRatingOverviewHasPrefix != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewHasPrefix(*i.TimeLimitRatingOverviewHasPrefix))
	}
	if i.TimeLimitRatingOverviewHasSuffix != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewHasSuffix(*i.TimeLimitRatingOverviewHasSuffix))
	}
	if i.TimeLimitRatingOverviewIsNil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewIsNil())
	}
	if i.TimeLimitRatingOverviewNotNil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewNotNil())
	}
	if i.TimeLimitRatingOverviewEqualFold != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewEqualFold(*i.TimeLimitRatingOverviewEqualFold))
	}
	if i.TimeLimitRatingOverviewContainsFold != nil {
		predicates = append(predicates, tender.TimeLimitRatingOverviewContainsFold(*i.TimeLimitRatingOverviewContainsFold))
	}
	if i.CustomerRelationshipRating != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingEQ(*i.CustomerRelationshipRating))
	}
	if i.CustomerRelationshipRatingNEQ != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingNEQ(*i.CustomerRelationshipRatingNEQ))
	}
	if len(i.CustomerRelationshipRatingIn) > 0 {
		predicates = append(predicates, tender.CustomerRelationshipRatingIn(i.CustomerRelationshipRatingIn...))
	}
	if len(i.CustomerRelationshipRatingNotIn) > 0 {
		predicates = append(predicates, tender.CustomerRelationshipRatingNotIn(i.CustomerRelationshipRatingNotIn...))
	}
	if i.CustomerRelationshipRatingGT != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingGT(*i.CustomerRelationshipRatingGT))
	}
	if i.CustomerRelationshipRatingGTE != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingGTE(*i.CustomerRelationshipRatingGTE))
	}
	if i.CustomerRelationshipRatingLT != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingLT(*i.CustomerRelationshipRatingLT))
	}
	if i.CustomerRelationshipRatingLTE != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingLTE(*i.CustomerRelationshipRatingLTE))
	}
	if i.CustomerRelationshipRatingIsNil {
		predicates = append(predicates, tender.CustomerRelationshipRatingIsNil())
	}
	if i.CustomerRelationshipRatingNotNil {
		predicates = append(predicates, tender.CustomerRelationshipRatingNotNil())
	}
	if i.CustomerRelationshipRatingOverview != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewEQ(*i.CustomerRelationshipRatingOverview))
	}
	if i.CustomerRelationshipRatingOverviewNEQ != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewNEQ(*i.CustomerRelationshipRatingOverviewNEQ))
	}
	if len(i.CustomerRelationshipRatingOverviewIn) > 0 {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewIn(i.CustomerRelationshipRatingOverviewIn...))
	}
	if len(i.CustomerRelationshipRatingOverviewNotIn) > 0 {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewNotIn(i.CustomerRelationshipRatingOverviewNotIn...))
	}
	if i.CustomerRelationshipRatingOverviewGT != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewGT(*i.CustomerRelationshipRatingOverviewGT))
	}
	if i.CustomerRelationshipRatingOverviewGTE != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewGTE(*i.CustomerRelationshipRatingOverviewGTE))
	}
	if i.CustomerRelationshipRatingOverviewLT != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewLT(*i.CustomerRelationshipRatingOverviewLT))
	}
	if i.CustomerRelationshipRatingOverviewLTE != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewLTE(*i.CustomerRelationshipRatingOverviewLTE))
	}
	if i.CustomerRelationshipRatingOverviewContains != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewContains(*i.CustomerRelationshipRatingOverviewContains))
	}
	if i.CustomerRelationshipRatingOverviewHasPrefix != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewHasPrefix(*i.CustomerRelationshipRatingOverviewHasPrefix))
	}
	if i.CustomerRelationshipRatingOverviewHasSuffix != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewHasSuffix(*i.CustomerRelationshipRatingOverviewHasSuffix))
	}
	if i.CustomerRelationshipRatingOverviewIsNil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewIsNil())
	}
	if i.CustomerRelationshipRatingOverviewNotNil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewNotNil())
	}
	if i.CustomerRelationshipRatingOverviewEqualFold != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewEqualFold(*i.CustomerRelationshipRatingOverviewEqualFold))
	}
	if i.CustomerRelationshipRatingOverviewContainsFold != nil {
		predicates = append(predicates, tender.CustomerRelationshipRatingOverviewContainsFold(*i.CustomerRelationshipRatingOverviewContainsFold))
	}
	if i.CompetitivePartnershipRating != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingEQ(*i.CompetitivePartnershipRating))
	}
	if i.CompetitivePartnershipRatingNEQ != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingNEQ(*i.CompetitivePartnershipRatingNEQ))
	}
	if len(i.CompetitivePartnershipRatingIn) > 0 {
		predicates = append(predicates, tender.CompetitivePartnershipRatingIn(i.CompetitivePartnershipRatingIn...))
	}
	if len(i.CompetitivePartnershipRatingNotIn) > 0 {
		predicates = append(predicates, tender.CompetitivePartnershipRatingNotIn(i.CompetitivePartnershipRatingNotIn...))
	}
	if i.CompetitivePartnershipRatingGT != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingGT(*i.CompetitivePartnershipRatingGT))
	}
	if i.CompetitivePartnershipRatingGTE != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingGTE(*i.CompetitivePartnershipRatingGTE))
	}
	if i.CompetitivePartnershipRatingLT != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingLT(*i.CompetitivePartnershipRatingLT))
	}
	if i.CompetitivePartnershipRatingLTE != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingLTE(*i.CompetitivePartnershipRatingLTE))
	}
	if i.CompetitivePartnershipRatingIsNil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingIsNil())
	}
	if i.CompetitivePartnershipRatingNotNil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingNotNil())
	}
	if i.CompetitivePartnershipRatingOverview != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewEQ(*i.CompetitivePartnershipRatingOverview))
	}
	if i.CompetitivePartnershipRatingOverviewNEQ != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewNEQ(*i.CompetitivePartnershipRatingOverviewNEQ))
	}
	if len(i.CompetitivePartnershipRatingOverviewIn) > 0 {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewIn(i.CompetitivePartnershipRatingOverviewIn...))
	}
	if len(i.CompetitivePartnershipRatingOverviewNotIn) > 0 {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewNotIn(i.CompetitivePartnershipRatingOverviewNotIn...))
	}
	if i.CompetitivePartnershipRatingOverviewGT != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewGT(*i.CompetitivePartnershipRatingOverviewGT))
	}
	if i.CompetitivePartnershipRatingOverviewGTE != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewGTE(*i.CompetitivePartnershipRatingOverviewGTE))
	}
	if i.CompetitivePartnershipRatingOverviewLT != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewLT(*i.CompetitivePartnershipRatingOverviewLT))
	}
	if i.CompetitivePartnershipRatingOverviewLTE != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewLTE(*i.CompetitivePartnershipRatingOverviewLTE))
	}
	if i.CompetitivePartnershipRatingOverviewContains != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewContains(*i.CompetitivePartnershipRatingOverviewContains))
	}
	if i.CompetitivePartnershipRatingOverviewHasPrefix != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewHasPrefix(*i.CompetitivePartnershipRatingOverviewHasPrefix))
	}
	if i.CompetitivePartnershipRatingOverviewHasSuffix != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewHasSuffix(*i.CompetitivePartnershipRatingOverviewHasSuffix))
	}
	if i.CompetitivePartnershipRatingOverviewIsNil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewIsNil())
	}
	if i.CompetitivePartnershipRatingOverviewNotNil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewNotNil())
	}
	if i.CompetitivePartnershipRatingOverviewEqualFold != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewEqualFold(*i.CompetitivePartnershipRatingOverviewEqualFold))
	}
	if i.CompetitivePartnershipRatingOverviewContainsFold != nil {
		predicates = append(predicates, tender.CompetitivePartnershipRatingOverviewContainsFold(*i.CompetitivePartnershipRatingOverviewContainsFold))
	}
	if i.PrepareToBid != nil {
		predicates = append(predicates, tender.PrepareToBidEQ(*i.PrepareToBid))
	}
	if i.PrepareToBidNEQ != nil {
		predicates = append(predicates, tender.PrepareToBidNEQ(*i.PrepareToBidNEQ))
	}
	if i.ProjectCode != nil {
		predicates = append(predicates, tender.ProjectCodeEQ(*i.ProjectCode))
	}
	if i.ProjectCodeNEQ != nil {
		predicates = append(predicates, tender.ProjectCodeNEQ(*i.ProjectCodeNEQ))
	}
	if len(i.ProjectCodeIn) > 0 {
		predicates = append(predicates, tender.ProjectCodeIn(i.ProjectCodeIn...))
	}
	if len(i.ProjectCodeNotIn) > 0 {
		predicates = append(predicates, tender.ProjectCodeNotIn(i.ProjectCodeNotIn...))
	}
	if i.ProjectCodeGT != nil {
		predicates = append(predicates, tender.ProjectCodeGT(*i.ProjectCodeGT))
	}
	if i.ProjectCodeGTE != nil {
		predicates = append(predicates, tender.ProjectCodeGTE(*i.ProjectCodeGTE))
	}
	if i.ProjectCodeLT != nil {
		predicates = append(predicates, tender.ProjectCodeLT(*i.ProjectCodeLT))
	}
	if i.ProjectCodeLTE != nil {
		predicates = append(predicates, tender.ProjectCodeLTE(*i.ProjectCodeLTE))
	}
	if i.ProjectCodeContains != nil {
		predicates = append(predicates, tender.ProjectCodeContains(*i.ProjectCodeContains))
	}
	if i.ProjectCodeHasPrefix != nil {
		predicates = append(predicates, tender.ProjectCodeHasPrefix(*i.ProjectCodeHasPrefix))
	}
	if i.ProjectCodeHasSuffix != nil {
		predicates = append(predicates, tender.ProjectCodeHasSuffix(*i.ProjectCodeHasSuffix))
	}
	if i.ProjectCodeIsNil {
		predicates = append(predicates, tender.ProjectCodeIsNil())
	}
	if i.ProjectCodeNotNil {
		predicates = append(predicates, tender.ProjectCodeNotNil())
	}
	if i.ProjectCodeEqualFold != nil {
		predicates = append(predicates, tender.ProjectCodeEqualFold(*i.ProjectCodeEqualFold))
	}
	if i.ProjectCodeContainsFold != nil {
		predicates = append(predicates, tender.ProjectCodeContainsFold(*i.ProjectCodeContainsFold))
	}
	if i.ProjectDefinition != nil {
		predicates = append(predicates, tender.ProjectDefinitionEQ(*i.ProjectDefinition))
	}
	if i.ProjectDefinitionNEQ != nil {
		predicates = append(predicates, tender.ProjectDefinitionNEQ(*i.ProjectDefinitionNEQ))
	}
	if len(i.ProjectDefinitionIn) > 0 {
		predicates = append(predicates, tender.ProjectDefinitionIn(i.ProjectDefinitionIn...))
	}
	if len(i.ProjectDefinitionNotIn) > 0 {
		predicates = append(predicates, tender.ProjectDefinitionNotIn(i.ProjectDefinitionNotIn...))
	}
	if i.ProjectDefinitionGT != nil {
		predicates = append(predicates, tender.ProjectDefinitionGT(*i.ProjectDefinitionGT))
	}
	if i.ProjectDefinitionGTE != nil {
		predicates = append(predicates, tender.ProjectDefinitionGTE(*i.ProjectDefinitionGTE))
	}
	if i.ProjectDefinitionLT != nil {
		predicates = append(predicates, tender.ProjectDefinitionLT(*i.ProjectDefinitionLT))
	}
	if i.ProjectDefinitionLTE != nil {
		predicates = append(predicates, tender.ProjectDefinitionLTE(*i.ProjectDefinitionLTE))
	}
	if i.ProjectDefinitionContains != nil {
		predicates = append(predicates, tender.ProjectDefinitionContains(*i.ProjectDefinitionContains))
	}
	if i.ProjectDefinitionHasPrefix != nil {
		predicates = append(predicates, tender.ProjectDefinitionHasPrefix(*i.ProjectDefinitionHasPrefix))
	}
	if i.ProjectDefinitionHasSuffix != nil {
		predicates = append(predicates, tender.ProjectDefinitionHasSuffix(*i.ProjectDefinitionHasSuffix))
	}
	if i.ProjectDefinitionIsNil {
		predicates = append(predicates, tender.ProjectDefinitionIsNil())
	}
	if i.ProjectDefinitionNotNil {
		predicates = append(predicates, tender.ProjectDefinitionNotNil())
	}
	if i.ProjectDefinitionEqualFold != nil {
		predicates = append(predicates, tender.ProjectDefinitionEqualFold(*i.ProjectDefinitionEqualFold))
	}
	if i.ProjectDefinitionContainsFold != nil {
		predicates = append(predicates, tender.ProjectDefinitionContainsFold(*i.ProjectDefinitionContainsFold))
	}
	if i.EstimatedProjectStartDate != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateEQ(*i.EstimatedProjectStartDate))
	}
	if i.EstimatedProjectStartDateNEQ != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateNEQ(*i.EstimatedProjectStartDateNEQ))
	}
	if len(i.EstimatedProjectStartDateIn) > 0 {
		predicates = append(predicates, tender.EstimatedProjectStartDateIn(i.EstimatedProjectStartDateIn...))
	}
	if len(i.EstimatedProjectStartDateNotIn) > 0 {
		predicates = append(predicates, tender.EstimatedProjectStartDateNotIn(i.EstimatedProjectStartDateNotIn...))
	}
	if i.EstimatedProjectStartDateGT != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateGT(*i.EstimatedProjectStartDateGT))
	}
	if i.EstimatedProjectStartDateGTE != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateGTE(*i.EstimatedProjectStartDateGTE))
	}
	if i.EstimatedProjectStartDateLT != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateLT(*i.EstimatedProjectStartDateLT))
	}
	if i.EstimatedProjectStartDateLTE != nil {
		predicates = append(predicates, tender.EstimatedProjectStartDateLTE(*i.EstimatedProjectStartDateLTE))
	}
	if i.EstimatedProjectStartDateIsNil {
		predicates = append(predicates, tender.EstimatedProjectStartDateIsNil())
	}
	if i.EstimatedProjectStartDateNotNil {
		predicates = append(predicates, tender.EstimatedProjectStartDateNotNil())
	}
	if i.EstimatedProjectEndDate != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateEQ(*i.EstimatedProjectEndDate))
	}
	if i.EstimatedProjectEndDateNEQ != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateNEQ(*i.EstimatedProjectEndDateNEQ))
	}
	if len(i.EstimatedProjectEndDateIn) > 0 {
		predicates = append(predicates, tender.EstimatedProjectEndDateIn(i.EstimatedProjectEndDateIn...))
	}
	if len(i.EstimatedProjectEndDateNotIn) > 0 {
		predicates = append(predicates, tender.EstimatedProjectEndDateNotIn(i.EstimatedProjectEndDateNotIn...))
	}
	if i.EstimatedProjectEndDateGT != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateGT(*i.EstimatedProjectEndDateGT))
	}
	if i.EstimatedProjectEndDateGTE != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateGTE(*i.EstimatedProjectEndDateGTE))
	}
	if i.EstimatedProjectEndDateLT != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateLT(*i.EstimatedProjectEndDateLT))
	}
	if i.EstimatedProjectEndDateLTE != nil {
		predicates = append(predicates, tender.EstimatedProjectEndDateLTE(*i.EstimatedProjectEndDateLTE))
	}
	if i.EstimatedProjectEndDateIsNil {
		predicates = append(predicates, tender.EstimatedProjectEndDateIsNil())
	}
	if i.EstimatedProjectEndDateNotNil {
		predicates = append(predicates, tender.EstimatedProjectEndDateNotNil())
	}
	if i.ProjectType != nil {
		predicates = append(predicates, tender.ProjectTypeEQ(*i.ProjectType))
	}
	if i.ProjectTypeNEQ != nil {
		predicates = append(predicates, tender.ProjectTypeNEQ(*i.ProjectTypeNEQ))
	}
	if len(i.ProjectTypeIn) > 0 {
		predicates = append(predicates, tender.ProjectTypeIn(i.ProjectTypeIn...))
	}
	if len(i.ProjectTypeNotIn) > 0 {
		predicates = append(predicates, tender.ProjectTypeNotIn(i.ProjectTypeNotIn...))
	}
	if i.ProjectTypeGT != nil {
		predicates = append(predicates, tender.ProjectTypeGT(*i.ProjectTypeGT))
	}
	if i.ProjectTypeGTE != nil {
		predicates = append(predicates, tender.ProjectTypeGTE(*i.ProjectTypeGTE))
	}
	if i.ProjectTypeLT != nil {
		predicates = append(predicates, tender.ProjectTypeLT(*i.ProjectTypeLT))
	}
	if i.ProjectTypeLTE != nil {
		predicates = append(predicates, tender.ProjectTypeLTE(*i.ProjectTypeLTE))
	}
	if i.ProjectTypeContains != nil {
		predicates = append(predicates, tender.ProjectTypeContains(*i.ProjectTypeContains))
	}
	if i.ProjectTypeHasPrefix != nil {
		predicates = append(predicates, tender.ProjectTypeHasPrefix(*i.ProjectTypeHasPrefix))
	}
	if i.ProjectTypeHasSuffix != nil {
		predicates = append(predicates, tender.ProjectTypeHasSuffix(*i.ProjectTypeHasSuffix))
	}
	if i.ProjectTypeIsNil {
		predicates = append(predicates, tender.ProjectTypeIsNil())
	}
	if i.ProjectTypeNotNil {
		predicates = append(predicates, tender.ProjectTypeNotNil())
	}
	if i.ProjectTypeEqualFold != nil {
		predicates = append(predicates, tender.ProjectTypeEqualFold(*i.ProjectTypeEqualFold))
	}
	if i.ProjectTypeContainsFold != nil {
		predicates = append(predicates, tender.ProjectTypeContainsFold(*i.ProjectTypeContainsFold))
	}
	if i.Remark != nil {
		predicates = append(predicates, tender.RemarkEQ(*i.Remark))
	}
	if i.RemarkNEQ != nil {
		predicates = append(predicates, tender.RemarkNEQ(*i.RemarkNEQ))
	}
	if len(i.RemarkIn) > 0 {
		predicates = append(predicates, tender.RemarkIn(i.RemarkIn...))
	}
	if len(i.RemarkNotIn) > 0 {
		predicates = append(predicates, tender.RemarkNotIn(i.RemarkNotIn...))
	}
	if i.RemarkGT != nil {
		predicates = append(predicates, tender.RemarkGT(*i.RemarkGT))
	}
	if i.RemarkGTE != nil {
		predicates = append(predicates, tender.RemarkGTE(*i.RemarkGTE))
	}
	if i.RemarkLT != nil {
		predicates = append(predicates, tender.RemarkLT(*i.RemarkLT))
	}
	if i.RemarkLTE != nil {
		predicates = append(predicates, tender.RemarkLTE(*i.RemarkLTE))
	}
	if i.RemarkContains != nil {
		predicates = append(predicates, tender.RemarkContains(*i.RemarkContains))
	}
	if i.RemarkHasPrefix != nil {
		predicates = append(predicates, tender.RemarkHasPrefix(*i.RemarkHasPrefix))
	}
	if i.RemarkHasSuffix != nil {
		predicates = append(predicates, tender.RemarkHasSuffix(*i.RemarkHasSuffix))
	}
	if i.RemarkIsNil {
		predicates = append(predicates, tender.RemarkIsNil())
	}
	if i.RemarkNotNil {
		predicates = append(predicates, tender.RemarkNotNil())
	}
	if i.RemarkEqualFold != nil {
		predicates = append(predicates, tender.RemarkEqualFold(*i.RemarkEqualFold))
	}
	if i.RemarkContainsFold != nil {
		predicates = append(predicates, tender.RemarkContainsFold(*i.RemarkContainsFold))
	}
	if i.TenderSituations != nil {
		predicates = append(predicates, tender.TenderSituationsEQ(*i.TenderSituations))
	}
	if i.TenderSituationsNEQ != nil {
		predicates = append(predicates, tender.TenderSituationsNEQ(*i.TenderSituationsNEQ))
	}
	if len(i.TenderSituationsIn) > 0 {
		predicates = append(predicates, tender.TenderSituationsIn(i.TenderSituationsIn...))
	}
	if len(i.TenderSituationsNotIn) > 0 {
		predicates = append(predicates, tender.TenderSituationsNotIn(i.TenderSituationsNotIn...))
	}
	if i.TenderSituationsGT != nil {
		predicates = append(predicates, tender.TenderSituationsGT(*i.TenderSituationsGT))
	}
	if i.TenderSituationsGTE != nil {
		predicates = append(predicates, tender.TenderSituationsGTE(*i.TenderSituationsGTE))
	}
	if i.TenderSituationsLT != nil {
		predicates = append(predicates, tender.TenderSituationsLT(*i.TenderSituationsLT))
	}
	if i.TenderSituationsLTE != nil {
		predicates = append(predicates, tender.TenderSituationsLTE(*i.TenderSituationsLTE))
	}
	if i.TenderSituationsContains != nil {
		predicates = append(predicates, tender.TenderSituationsContains(*i.TenderSituationsContains))
	}
	if i.TenderSituationsHasPrefix != nil {
		predicates = append(predicates, tender.TenderSituationsHasPrefix(*i.TenderSituationsHasPrefix))
	}
	if i.TenderSituationsHasSuffix != nil {
		predicates = append(predicates, tender.TenderSituationsHasSuffix(*i.TenderSituationsHasSuffix))
	}
	if i.TenderSituationsIsNil {
		predicates = append(predicates, tender.TenderSituationsIsNil())
	}
	if i.TenderSituationsNotNil {
		predicates = append(predicates, tender.TenderSituationsNotNil())
	}
	if i.TenderSituationsEqualFold != nil {
		predicates = append(predicates, tender.TenderSituationsEqualFold(*i.TenderSituationsEqualFold))
	}
	if i.TenderSituationsContainsFold != nil {
		predicates = append(predicates, tender.TenderSituationsContainsFold(*i.TenderSituationsContainsFold))
	}
	if i.OwnerSituations != nil {
		predicates = append(predicates, tender.OwnerSituationsEQ(*i.OwnerSituations))
	}
	if i.OwnerSituationsNEQ != nil {
		predicates = append(predicates, tender.OwnerSituationsNEQ(*i.OwnerSituationsNEQ))
	}
	if len(i.OwnerSituationsIn) > 0 {
		predicates = append(predicates, tender.OwnerSituationsIn(i.OwnerSituationsIn...))
	}
	if len(i.OwnerSituationsNotIn) > 0 {
		predicates = append(predicates, tender.OwnerSituationsNotIn(i.OwnerSituationsNotIn...))
	}
	if i.OwnerSituationsGT != nil {
		predicates = append(predicates, tender.OwnerSituationsGT(*i.OwnerSituationsGT))
	}
	if i.OwnerSituationsGTE != nil {
		predicates = append(predicates, tender.OwnerSituationsGTE(*i.OwnerSituationsGTE))
	}
	if i.OwnerSituationsLT != nil {
		predicates = append(predicates, tender.OwnerSituationsLT(*i.OwnerSituationsLT))
	}
	if i.OwnerSituationsLTE != nil {
		predicates = append(predicates, tender.OwnerSituationsLTE(*i.OwnerSituationsLTE))
	}
	if i.OwnerSituationsContains != nil {
		predicates = append(predicates, tender.OwnerSituationsContains(*i.OwnerSituationsContains))
	}
	if i.OwnerSituationsHasPrefix != nil {
		predicates = append(predicates, tender.OwnerSituationsHasPrefix(*i.OwnerSituationsHasPrefix))
	}
	if i.OwnerSituationsHasSuffix != nil {
		predicates = append(predicates, tender.OwnerSituationsHasSuffix(*i.OwnerSituationsHasSuffix))
	}
	if i.OwnerSituationsIsNil {
		predicates = append(predicates, tender.OwnerSituationsIsNil())
	}
	if i.OwnerSituationsNotNil {
		predicates = append(predicates, tender.OwnerSituationsNotNil())
	}
	if i.OwnerSituationsEqualFold != nil {
		predicates = append(predicates, tender.OwnerSituationsEqualFold(*i.OwnerSituationsEqualFold))
	}
	if i.OwnerSituationsContainsFold != nil {
		predicates = append(predicates, tender.OwnerSituationsContainsFold(*i.OwnerSituationsContainsFold))
	}
	if i.BiddingInstructions != nil {
		predicates = append(predicates, tender.BiddingInstructionsEQ(*i.BiddingInstructions))
	}
	if i.BiddingInstructionsNEQ != nil {
		predicates = append(predicates, tender.BiddingInstructionsNEQ(*i.BiddingInstructionsNEQ))
	}
	if len(i.BiddingInstructionsIn) > 0 {
		predicates = append(predicates, tender.BiddingInstructionsIn(i.BiddingInstructionsIn...))
	}
	if len(i.BiddingInstructionsNotIn) > 0 {
		predicates = append(predicates, tender.BiddingInstructionsNotIn(i.BiddingInstructionsNotIn...))
	}
	if i.BiddingInstructionsGT != nil {
		predicates = append(predicates, tender.BiddingInstructionsGT(*i.BiddingInstructionsGT))
	}
	if i.BiddingInstructionsGTE != nil {
		predicates = append(predicates, tender.BiddingInstructionsGTE(*i.BiddingInstructionsGTE))
	}
	if i.BiddingInstructionsLT != nil {
		predicates = append(predicates, tender.BiddingInstructionsLT(*i.BiddingInstructionsLT))
	}
	if i.BiddingInstructionsLTE != nil {
		predicates = append(predicates, tender.BiddingInstructionsLTE(*i.BiddingInstructionsLTE))
	}
	if i.BiddingInstructionsContains != nil {
		predicates = append(predicates, tender.BiddingInstructionsContains(*i.BiddingInstructionsContains))
	}
	if i.BiddingInstructionsHasPrefix != nil {
		predicates = append(predicates, tender.BiddingInstructionsHasPrefix(*i.BiddingInstructionsHasPrefix))
	}
	if i.BiddingInstructionsHasSuffix != nil {
		predicates = append(predicates, tender.BiddingInstructionsHasSuffix(*i.BiddingInstructionsHasSuffix))
	}
	if i.BiddingInstructionsIsNil {
		predicates = append(predicates, tender.BiddingInstructionsIsNil())
	}
	if i.BiddingInstructionsNotNil {
		predicates = append(predicates, tender.BiddingInstructionsNotNil())
	}
	if i.BiddingInstructionsEqualFold != nil {
		predicates = append(predicates, tender.BiddingInstructionsEqualFold(*i.BiddingInstructionsEqualFold))
	}
	if i.BiddingInstructionsContainsFold != nil {
		predicates = append(predicates, tender.BiddingInstructionsContainsFold(*i.BiddingInstructionsContainsFold))
	}
	if i.CompetitorSituations != nil {
		predicates = append(predicates, tender.CompetitorSituationsEQ(*i.CompetitorSituations))
	}
	if i.CompetitorSituationsNEQ != nil {
		predicates = append(predicates, tender.CompetitorSituationsNEQ(*i.CompetitorSituationsNEQ))
	}
	if len(i.CompetitorSituationsIn) > 0 {
		predicates = append(predicates, tender.CompetitorSituationsIn(i.CompetitorSituationsIn...))
	}
	if len(i.CompetitorSituationsNotIn) > 0 {
		predicates = append(predicates, tender.CompetitorSituationsNotIn(i.CompetitorSituationsNotIn...))
	}
	if i.CompetitorSituationsGT != nil {
		predicates = append(predicates, tender.CompetitorSituationsGT(*i.CompetitorSituationsGT))
	}
	if i.CompetitorSituationsGTE != nil {
		predicates = append(predicates, tender.CompetitorSituationsGTE(*i.CompetitorSituationsGTE))
	}
	if i.CompetitorSituationsLT != nil {
		predicates = append(predicates, tender.CompetitorSituationsLT(*i.CompetitorSituationsLT))
	}
	if i.CompetitorSituationsLTE != nil {
		predicates = append(predicates, tender.CompetitorSituationsLTE(*i.CompetitorSituationsLTE))
	}
	if i.CompetitorSituationsContains != nil {
		predicates = append(predicates, tender.CompetitorSituationsContains(*i.CompetitorSituationsContains))
	}
	if i.CompetitorSituationsHasPrefix != nil {
		predicates = append(predicates, tender.CompetitorSituationsHasPrefix(*i.CompetitorSituationsHasPrefix))
	}
	if i.CompetitorSituationsHasSuffix != nil {
		predicates = append(predicates, tender.CompetitorSituationsHasSuffix(*i.CompetitorSituationsHasSuffix))
	}
	if i.CompetitorSituationsIsNil {
		predicates = append(predicates, tender.CompetitorSituationsIsNil())
	}
	if i.CompetitorSituationsNotNil {
		predicates = append(predicates, tender.CompetitorSituationsNotNil())
	}
	if i.CompetitorSituationsEqualFold != nil {
		predicates = append(predicates, tender.CompetitorSituationsEqualFold(*i.CompetitorSituationsEqualFold))
	}
	if i.CompetitorSituationsContainsFold != nil {
		predicates = append(predicates, tender.CompetitorSituationsContainsFold(*i.CompetitorSituationsContainsFold))
	}
	if i.CostEngineer != nil {
		predicates = append(predicates, tender.CostEngineerEQ(*i.CostEngineer))
	}
	if i.CostEngineerNEQ != nil {
		predicates = append(predicates, tender.CostEngineerNEQ(*i.CostEngineerNEQ))
	}
	if len(i.CostEngineerIn) > 0 {
		predicates = append(predicates, tender.CostEngineerIn(i.CostEngineerIn...))
	}
	if len(i.CostEngineerNotIn) > 0 {
		predicates = append(predicates, tender.CostEngineerNotIn(i.CostEngineerNotIn...))
	}
	if i.CostEngineerGT != nil {
		predicates = append(predicates, tender.CostEngineerGT(*i.CostEngineerGT))
	}
	if i.CostEngineerGTE != nil {
		predicates = append(predicates, tender.CostEngineerGTE(*i.CostEngineerGTE))
	}
	if i.CostEngineerLT != nil {
		predicates = append(predicates, tender.CostEngineerLT(*i.CostEngineerLT))
	}
	if i.CostEngineerLTE != nil {
		predicates = append(predicates, tender.CostEngineerLTE(*i.CostEngineerLTE))
	}
	if i.CostEngineerContains != nil {
		predicates = append(predicates, tender.CostEngineerContains(*i.CostEngineerContains))
	}
	if i.CostEngineerHasPrefix != nil {
		predicates = append(predicates, tender.CostEngineerHasPrefix(*i.CostEngineerHasPrefix))
	}
	if i.CostEngineerHasSuffix != nil {
		predicates = append(predicates, tender.CostEngineerHasSuffix(*i.CostEngineerHasSuffix))
	}
	if i.CostEngineerIsNil {
		predicates = append(predicates, tender.CostEngineerIsNil())
	}
	if i.CostEngineerNotNil {
		predicates = append(predicates, tender.CostEngineerNotNil())
	}
	if i.CostEngineerEqualFold != nil {
		predicates = append(predicates, tender.CostEngineerEqualFold(*i.CostEngineerEqualFold))
	}
	if i.CostEngineerContainsFold != nil {
		predicates = append(predicates, tender.CostEngineerContainsFold(*i.CostEngineerContainsFold))
	}
	if i.TenderForm != nil {
		predicates = append(predicates, tender.TenderFormEQ(*i.TenderForm))
	}
	if i.TenderFormNEQ != nil {
		predicates = append(predicates, tender.TenderFormNEQ(*i.TenderFormNEQ))
	}
	if len(i.TenderFormIn) > 0 {
		predicates = append(predicates, tender.TenderFormIn(i.TenderFormIn...))
	}
	if len(i.TenderFormNotIn) > 0 {
		predicates = append(predicates, tender.TenderFormNotIn(i.TenderFormNotIn...))
	}
	if i.TenderFormGT != nil {
		predicates = append(predicates, tender.TenderFormGT(*i.TenderFormGT))
	}
	if i.TenderFormGTE != nil {
		predicates = append(predicates, tender.TenderFormGTE(*i.TenderFormGTE))
	}
	if i.TenderFormLT != nil {
		predicates = append(predicates, tender.TenderFormLT(*i.TenderFormLT))
	}
	if i.TenderFormLTE != nil {
		predicates = append(predicates, tender.TenderFormLTE(*i.TenderFormLTE))
	}
	if i.TenderFormContains != nil {
		predicates = append(predicates, tender.TenderFormContains(*i.TenderFormContains))
	}
	if i.TenderFormHasPrefix != nil {
		predicates = append(predicates, tender.TenderFormHasPrefix(*i.TenderFormHasPrefix))
	}
	if i.TenderFormHasSuffix != nil {
		predicates = append(predicates, tender.TenderFormHasSuffix(*i.TenderFormHasSuffix))
	}
	if i.TenderFormIsNil {
		predicates = append(predicates, tender.TenderFormIsNil())
	}
	if i.TenderFormNotNil {
		predicates = append(predicates, tender.TenderFormNotNil())
	}
	if i.TenderFormEqualFold != nil {
		predicates = append(predicates, tender.TenderFormEqualFold(*i.TenderFormEqualFold))
	}
	if i.TenderFormContainsFold != nil {
		predicates = append(predicates, tender.TenderFormContainsFold(*i.TenderFormContainsFold))
	}
	if i.ContractForm != nil {
		predicates = append(predicates, tender.ContractFormEQ(*i.ContractForm))
	}
	if i.ContractFormNEQ != nil {
		predicates = append(predicates, tender.ContractFormNEQ(*i.ContractFormNEQ))
	}
	if len(i.ContractFormIn) > 0 {
		predicates = append(predicates, tender.ContractFormIn(i.ContractFormIn...))
	}
	if len(i.ContractFormNotIn) > 0 {
		predicates = append(predicates, tender.ContractFormNotIn(i.ContractFormNotIn...))
	}
	if i.ContractFormGT != nil {
		predicates = append(predicates, tender.ContractFormGT(*i.ContractFormGT))
	}
	if i.ContractFormGTE != nil {
		predicates = append(predicates, tender.ContractFormGTE(*i.ContractFormGTE))
	}
	if i.ContractFormLT != nil {
		predicates = append(predicates, tender.ContractFormLT(*i.ContractFormLT))
	}
	if i.ContractFormLTE != nil {
		predicates = append(predicates, tender.ContractFormLTE(*i.ContractFormLTE))
	}
	if i.ContractFormContains != nil {
		predicates = append(predicates, tender.ContractFormContains(*i.ContractFormContains))
	}
	if i.ContractFormHasPrefix != nil {
		predicates = append(predicates, tender.ContractFormHasPrefix(*i.ContractFormHasPrefix))
	}
	if i.ContractFormHasSuffix != nil {
		predicates = append(predicates, tender.ContractFormHasSuffix(*i.ContractFormHasSuffix))
	}
	if i.ContractFormIsNil {
		predicates = append(predicates, tender.ContractFormIsNil())
	}
	if i.ContractFormNotNil {
		predicates = append(predicates, tender.ContractFormNotNil())
	}
	if i.ContractFormEqualFold != nil {
		predicates = append(predicates, tender.ContractFormEqualFold(*i.ContractFormEqualFold))
	}
	if i.ContractFormContainsFold != nil {
		predicates = append(predicates, tender.ContractFormContainsFold(*i.ContractFormContainsFold))
	}
	if i.ManagementCompany != nil {
		predicates = append(predicates, tender.ManagementCompanyEQ(*i.ManagementCompany))
	}
	if i.ManagementCompanyNEQ != nil {
		predicates = append(predicates, tender.ManagementCompanyNEQ(*i.ManagementCompanyNEQ))
	}
	if len(i.ManagementCompanyIn) > 0 {
		predicates = append(predicates, tender.ManagementCompanyIn(i.ManagementCompanyIn...))
	}
	if len(i.ManagementCompanyNotIn) > 0 {
		predicates = append(predicates, tender.ManagementCompanyNotIn(i.ManagementCompanyNotIn...))
	}
	if i.ManagementCompanyGT != nil {
		predicates = append(predicates, tender.ManagementCompanyGT(*i.ManagementCompanyGT))
	}
	if i.ManagementCompanyGTE != nil {
		predicates = append(predicates, tender.ManagementCompanyGTE(*i.ManagementCompanyGTE))
	}
	if i.ManagementCompanyLT != nil {
		predicates = append(predicates, tender.ManagementCompanyLT(*i.ManagementCompanyLT))
	}
	if i.ManagementCompanyLTE != nil {
		predicates = append(predicates, tender.ManagementCompanyLTE(*i.ManagementCompanyLTE))
	}
	if i.ManagementCompanyContains != nil {
		predicates = append(predicates, tender.ManagementCompanyContains(*i.ManagementCompanyContains))
	}
	if i.ManagementCompanyHasPrefix != nil {
		predicates = append(predicates, tender.ManagementCompanyHasPrefix(*i.ManagementCompanyHasPrefix))
	}
	if i.ManagementCompanyHasSuffix != nil {
		predicates = append(predicates, tender.ManagementCompanyHasSuffix(*i.ManagementCompanyHasSuffix))
	}
	if i.ManagementCompanyIsNil {
		predicates = append(predicates, tender.ManagementCompanyIsNil())
	}
	if i.ManagementCompanyNotNil {
		predicates = append(predicates, tender.ManagementCompanyNotNil())
	}
	if i.ManagementCompanyEqualFold != nil {
		predicates = append(predicates, tender.ManagementCompanyEqualFold(*i.ManagementCompanyEqualFold))
	}
	if i.ManagementCompanyContainsFold != nil {
		predicates = append(predicates, tender.ManagementCompanyContainsFold(*i.ManagementCompanyContainsFold))
	}
	if i.TenderingAgency != nil {
		predicates = append(predicates, tender.TenderingAgencyEQ(*i.TenderingAgency))
	}
	if i.TenderingAgencyNEQ != nil {
		predicates = append(predicates, tender.TenderingAgencyNEQ(*i.TenderingAgencyNEQ))
	}
	if len(i.TenderingAgencyIn) > 0 {
		predicates = append(predicates, tender.TenderingAgencyIn(i.TenderingAgencyIn...))
	}
	if len(i.TenderingAgencyNotIn) > 0 {
		predicates = append(predicates, tender.TenderingAgencyNotIn(i.TenderingAgencyNotIn...))
	}
	if i.TenderingAgencyGT != nil {
		predicates = append(predicates, tender.TenderingAgencyGT(*i.TenderingAgencyGT))
	}
	if i.TenderingAgencyGTE != nil {
		predicates = append(predicates, tender.TenderingAgencyGTE(*i.TenderingAgencyGTE))
	}
	if i.TenderingAgencyLT != nil {
		predicates = append(predicates, tender.TenderingAgencyLT(*i.TenderingAgencyLT))
	}
	if i.TenderingAgencyLTE != nil {
		predicates = append(predicates, tender.TenderingAgencyLTE(*i.TenderingAgencyLTE))
	}
	if i.TenderingAgencyContains != nil {
		predicates = append(predicates, tender.TenderingAgencyContains(*i.TenderingAgencyContains))
	}
	if i.TenderingAgencyHasPrefix != nil {
		predicates = append(predicates, tender.TenderingAgencyHasPrefix(*i.TenderingAgencyHasPrefix))
	}
	if i.TenderingAgencyHasSuffix != nil {
		predicates = append(predicates, tender.TenderingAgencyHasSuffix(*i.TenderingAgencyHasSuffix))
	}
	if i.TenderingAgencyIsNil {
		predicates = append(predicates, tender.TenderingAgencyIsNil())
	}
	if i.TenderingAgencyNotNil {
		predicates = append(predicates, tender.TenderingAgencyNotNil())
	}
	if i.TenderingAgencyEqualFold != nil {
		predicates = append(predicates, tender.TenderingAgencyEqualFold(*i.TenderingAgencyEqualFold))
	}
	if i.TenderingAgencyContainsFold != nil {
		predicates = append(predicates, tender.TenderingAgencyContainsFold(*i.TenderingAgencyContainsFold))
	}
	if i.BiddingDate != nil {
		predicates = append(predicates, tender.BiddingDateEQ(*i.BiddingDate))
	}
	if i.BiddingDateNEQ != nil {
		predicates = append(predicates, tender.BiddingDateNEQ(*i.BiddingDateNEQ))
	}
	if len(i.BiddingDateIn) > 0 {
		predicates = append(predicates, tender.BiddingDateIn(i.BiddingDateIn...))
	}
	if len(i.BiddingDateNotIn) > 0 {
		predicates = append(predicates, tender.BiddingDateNotIn(i.BiddingDateNotIn...))
	}
	if i.BiddingDateGT != nil {
		predicates = append(predicates, tender.BiddingDateGT(*i.BiddingDateGT))
	}
	if i.BiddingDateGTE != nil {
		predicates = append(predicates, tender.BiddingDateGTE(*i.BiddingDateGTE))
	}
	if i.BiddingDateLT != nil {
		predicates = append(predicates, tender.BiddingDateLT(*i.BiddingDateLT))
	}
	if i.BiddingDateLTE != nil {
		predicates = append(predicates, tender.BiddingDateLTE(*i.BiddingDateLTE))
	}
	if i.BiddingDateIsNil {
		predicates = append(predicates, tender.BiddingDateIsNil())
	}
	if i.BiddingDateNotNil {
		predicates = append(predicates, tender.BiddingDateNotNil())
	}
	if i.FacadeConsultant != nil {
		predicates = append(predicates, tender.FacadeConsultantEQ(*i.FacadeConsultant))
	}
	if i.FacadeConsultantNEQ != nil {
		predicates = append(predicates, tender.FacadeConsultantNEQ(*i.FacadeConsultantNEQ))
	}
	if len(i.FacadeConsultantIn) > 0 {
		predicates = append(predicates, tender.FacadeConsultantIn(i.FacadeConsultantIn...))
	}
	if len(i.FacadeConsultantNotIn) > 0 {
		predicates = append(predicates, tender.FacadeConsultantNotIn(i.FacadeConsultantNotIn...))
	}
	if i.FacadeConsultantGT != nil {
		predicates = append(predicates, tender.FacadeConsultantGT(*i.FacadeConsultantGT))
	}
	if i.FacadeConsultantGTE != nil {
		predicates = append(predicates, tender.FacadeConsultantGTE(*i.FacadeConsultantGTE))
	}
	if i.FacadeConsultantLT != nil {
		predicates = append(predicates, tender.FacadeConsultantLT(*i.FacadeConsultantLT))
	}
	if i.FacadeConsultantLTE != nil {
		predicates = append(predicates, tender.FacadeConsultantLTE(*i.FacadeConsultantLTE))
	}
	if i.FacadeConsultantContains != nil {
		predicates = append(predicates, tender.FacadeConsultantContains(*i.FacadeConsultantContains))
	}
	if i.FacadeConsultantHasPrefix != nil {
		predicates = append(predicates, tender.FacadeConsultantHasPrefix(*i.FacadeConsultantHasPrefix))
	}
	if i.FacadeConsultantHasSuffix != nil {
		predicates = append(predicates, tender.FacadeConsultantHasSuffix(*i.FacadeConsultantHasSuffix))
	}
	if i.FacadeConsultantIsNil {
		predicates = append(predicates, tender.FacadeConsultantIsNil())
	}
	if i.FacadeConsultantNotNil {
		predicates = append(predicates, tender.FacadeConsultantNotNil())
	}
	if i.FacadeConsultantEqualFold != nil {
		predicates = append(predicates, tender.FacadeConsultantEqualFold(*i.FacadeConsultantEqualFold))
	}
	if i.FacadeConsultantContainsFold != nil {
		predicates = append(predicates, tender.FacadeConsultantContainsFold(*i.FacadeConsultantContainsFold))
	}
	if i.DesignUnit != nil {
		predicates = append(predicates, tender.DesignUnitEQ(*i.DesignUnit))
	}
	if i.DesignUnitNEQ != nil {
		predicates = append(predicates, tender.DesignUnitNEQ(*i.DesignUnitNEQ))
	}
	if len(i.DesignUnitIn) > 0 {
		predicates = append(predicates, tender.DesignUnitIn(i.DesignUnitIn...))
	}
	if len(i.DesignUnitNotIn) > 0 {
		predicates = append(predicates, tender.DesignUnitNotIn(i.DesignUnitNotIn...))
	}
	if i.DesignUnitGT != nil {
		predicates = append(predicates, tender.DesignUnitGT(*i.DesignUnitGT))
	}
	if i.DesignUnitGTE != nil {
		predicates = append(predicates, tender.DesignUnitGTE(*i.DesignUnitGTE))
	}
	if i.DesignUnitLT != nil {
		predicates = append(predicates, tender.DesignUnitLT(*i.DesignUnitLT))
	}
	if i.DesignUnitLTE != nil {
		predicates = append(predicates, tender.DesignUnitLTE(*i.DesignUnitLTE))
	}
	if i.DesignUnitContains != nil {
		predicates = append(predicates, tender.DesignUnitContains(*i.DesignUnitContains))
	}
	if i.DesignUnitHasPrefix != nil {
		predicates = append(predicates, tender.DesignUnitHasPrefix(*i.DesignUnitHasPrefix))
	}
	if i.DesignUnitHasSuffix != nil {
		predicates = append(predicates, tender.DesignUnitHasSuffix(*i.DesignUnitHasSuffix))
	}
	if i.DesignUnitIsNil {
		predicates = append(predicates, tender.DesignUnitIsNil())
	}
	if i.DesignUnitNotNil {
		predicates = append(predicates, tender.DesignUnitNotNil())
	}
	if i.DesignUnitEqualFold != nil {
		predicates = append(predicates, tender.DesignUnitEqualFold(*i.DesignUnitEqualFold))
	}
	if i.DesignUnitContainsFold != nil {
		predicates = append(predicates, tender.DesignUnitContainsFold(*i.DesignUnitContainsFold))
	}
	if i.ConsultingFirm != nil {
		predicates = append(predicates, tender.ConsultingFirmEQ(*i.ConsultingFirm))
	}
	if i.ConsultingFirmNEQ != nil {
		predicates = append(predicates, tender.ConsultingFirmNEQ(*i.ConsultingFirmNEQ))
	}
	if len(i.ConsultingFirmIn) > 0 {
		predicates = append(predicates, tender.ConsultingFirmIn(i.ConsultingFirmIn...))
	}
	if len(i.ConsultingFirmNotIn) > 0 {
		predicates = append(predicates, tender.ConsultingFirmNotIn(i.ConsultingFirmNotIn...))
	}
	if i.ConsultingFirmGT != nil {
		predicates = append(predicates, tender.ConsultingFirmGT(*i.ConsultingFirmGT))
	}
	if i.ConsultingFirmGTE != nil {
		predicates = append(predicates, tender.ConsultingFirmGTE(*i.ConsultingFirmGTE))
	}
	if i.ConsultingFirmLT != nil {
		predicates = append(predicates, tender.ConsultingFirmLT(*i.ConsultingFirmLT))
	}
	if i.ConsultingFirmLTE != nil {
		predicates = append(predicates, tender.ConsultingFirmLTE(*i.ConsultingFirmLTE))
	}
	if i.ConsultingFirmContains != nil {
		predicates = append(predicates, tender.ConsultingFirmContains(*i.ConsultingFirmContains))
	}
	if i.ConsultingFirmHasPrefix != nil {
		predicates = append(predicates, tender.ConsultingFirmHasPrefix(*i.ConsultingFirmHasPrefix))
	}
	if i.ConsultingFirmHasSuffix != nil {
		predicates = append(predicates, tender.ConsultingFirmHasSuffix(*i.ConsultingFirmHasSuffix))
	}
	if i.ConsultingFirmIsNil {
		predicates = append(predicates, tender.ConsultingFirmIsNil())
	}
	if i.ConsultingFirmNotNil {
		predicates = append(predicates, tender.ConsultingFirmNotNil())
	}
	if i.ConsultingFirmEqualFold != nil {
		predicates = append(predicates, tender.ConsultingFirmEqualFold(*i.ConsultingFirmEqualFold))
	}
	if i.ConsultingFirmContainsFold != nil {
		predicates = append(predicates, tender.ConsultingFirmContainsFold(*i.ConsultingFirmContainsFold))
	}
	if i.KeyProject != nil {
		predicates = append(predicates, tender.KeyProjectEQ(*i.KeyProject))
	}
	if i.KeyProjectNEQ != nil {
		predicates = append(predicates, tender.KeyProjectNEQ(*i.KeyProjectNEQ))
	}
	if i.TenderWinCompany != nil {
		predicates = append(predicates, tender.TenderWinCompanyEQ(*i.TenderWinCompany))
	}
	if i.TenderWinCompanyNEQ != nil {
		predicates = append(predicates, tender.TenderWinCompanyNEQ(*i.TenderWinCompanyNEQ))
	}
	if len(i.TenderWinCompanyIn) > 0 {
		predicates = append(predicates, tender.TenderWinCompanyIn(i.TenderWinCompanyIn...))
	}
	if len(i.TenderWinCompanyNotIn) > 0 {
		predicates = append(predicates, tender.TenderWinCompanyNotIn(i.TenderWinCompanyNotIn...))
	}
	if i.TenderWinCompanyGT != nil {
		predicates = append(predicates, tender.TenderWinCompanyGT(*i.TenderWinCompanyGT))
	}
	if i.TenderWinCompanyGTE != nil {
		predicates = append(predicates, tender.TenderWinCompanyGTE(*i.TenderWinCompanyGTE))
	}
	if i.TenderWinCompanyLT != nil {
		predicates = append(predicates, tender.TenderWinCompanyLT(*i.TenderWinCompanyLT))
	}
	if i.TenderWinCompanyLTE != nil {
		predicates = append(predicates, tender.TenderWinCompanyLTE(*i.TenderWinCompanyLTE))
	}
	if i.TenderWinCompanyContains != nil {
		predicates = append(predicates, tender.TenderWinCompanyContains(*i.TenderWinCompanyContains))
	}
	if i.TenderWinCompanyHasPrefix != nil {
		predicates = append(predicates, tender.TenderWinCompanyHasPrefix(*i.TenderWinCompanyHasPrefix))
	}
	if i.TenderWinCompanyHasSuffix != nil {
		predicates = append(predicates, tender.TenderWinCompanyHasSuffix(*i.TenderWinCompanyHasSuffix))
	}
	if i.TenderWinCompanyIsNil {
		predicates = append(predicates, tender.TenderWinCompanyIsNil())
	}
	if i.TenderWinCompanyNotNil {
		predicates = append(predicates, tender.TenderWinCompanyNotNil())
	}
	if i.TenderWinCompanyEqualFold != nil {
		predicates = append(predicates, tender.TenderWinCompanyEqualFold(*i.TenderWinCompanyEqualFold))
	}
	if i.TenderWinCompanyContainsFold != nil {
		predicates = append(predicates, tender.TenderWinCompanyContainsFold(*i.TenderWinCompanyContainsFold))
	}
	if i.TenderCode != nil {
		predicates = append(predicates, tender.TenderCodeEQ(*i.TenderCode))
	}
	if i.TenderCodeNEQ != nil {
		predicates = append(predicates, tender.TenderCodeNEQ(*i.TenderCodeNEQ))
	}
	if len(i.TenderCodeIn) > 0 {
		predicates = append(predicates, tender.TenderCodeIn(i.TenderCodeIn...))
	}
	if len(i.TenderCodeNotIn) > 0 {
		predicates = append(predicates, tender.TenderCodeNotIn(i.TenderCodeNotIn...))
	}
	if i.TenderCodeGT != nil {
		predicates = append(predicates, tender.TenderCodeGT(*i.TenderCodeGT))
	}
	if i.TenderCodeGTE != nil {
		predicates = append(predicates, tender.TenderCodeGTE(*i.TenderCodeGTE))
	}
	if i.TenderCodeLT != nil {
		predicates = append(predicates, tender.TenderCodeLT(*i.TenderCodeLT))
	}
	if i.TenderCodeLTE != nil {
		predicates = append(predicates, tender.TenderCodeLTE(*i.TenderCodeLTE))
	}
	if i.TenderCodeContains != nil {
		predicates = append(predicates, tender.TenderCodeContains(*i.TenderCodeContains))
	}
	if i.TenderCodeHasPrefix != nil {
		predicates = append(predicates, tender.TenderCodeHasPrefix(*i.TenderCodeHasPrefix))
	}
	if i.TenderCodeHasSuffix != nil {
		predicates = append(predicates, tender.TenderCodeHasSuffix(*i.TenderCodeHasSuffix))
	}
	if i.TenderCodeIsNil {
		predicates = append(predicates, tender.TenderCodeIsNil())
	}
	if i.TenderCodeNotNil {
		predicates = append(predicates, tender.TenderCodeNotNil())
	}
	if i.TenderCodeEqualFold != nil {
		predicates = append(predicates, tender.TenderCodeEqualFold(*i.TenderCodeEqualFold))
	}
	if i.TenderCodeContainsFold != nil {
		predicates = append(predicates, tender.TenderCodeContainsFold(*i.TenderCodeContainsFold))
	}
	if i.Architect != nil {
		predicates = append(predicates, tender.ArchitectEQ(*i.Architect))
	}
	if i.ArchitectNEQ != nil {
		predicates = append(predicates, tender.ArchitectNEQ(*i.ArchitectNEQ))
	}
	if len(i.ArchitectIn) > 0 {
		predicates = append(predicates, tender.ArchitectIn(i.ArchitectIn...))
	}
	if len(i.ArchitectNotIn) > 0 {
		predicates = append(predicates, tender.ArchitectNotIn(i.ArchitectNotIn...))
	}
	if i.ArchitectGT != nil {
		predicates = append(predicates, tender.ArchitectGT(*i.ArchitectGT))
	}
	if i.ArchitectGTE != nil {
		predicates = append(predicates, tender.ArchitectGTE(*i.ArchitectGTE))
	}
	if i.ArchitectLT != nil {
		predicates = append(predicates, tender.ArchitectLT(*i.ArchitectLT))
	}
	if i.ArchitectLTE != nil {
		predicates = append(predicates, tender.ArchitectLTE(*i.ArchitectLTE))
	}
	if i.ArchitectContains != nil {
		predicates = append(predicates, tender.ArchitectContains(*i.ArchitectContains))
	}
	if i.ArchitectHasPrefix != nil {
		predicates = append(predicates, tender.ArchitectHasPrefix(*i.ArchitectHasPrefix))
	}
	if i.ArchitectHasSuffix != nil {
		predicates = append(predicates, tender.ArchitectHasSuffix(*i.ArchitectHasSuffix))
	}
	if i.ArchitectIsNil {
		predicates = append(predicates, tender.ArchitectIsNil())
	}
	if i.ArchitectNotNil {
		predicates = append(predicates, tender.ArchitectNotNil())
	}
	if i.ArchitectEqualFold != nil {
		predicates = append(predicates, tender.ArchitectEqualFold(*i.ArchitectEqualFold))
	}
	if i.ArchitectContainsFold != nil {
		predicates = append(predicates, tender.ArchitectContainsFold(*i.ArchitectContainsFold))
	}
	if i.Developer != nil {
		predicates = append(predicates, tender.DeveloperEQ(*i.Developer))
	}
	if i.DeveloperNEQ != nil {
		predicates = append(predicates, tender.DeveloperNEQ(*i.DeveloperNEQ))
	}
	if len(i.DeveloperIn) > 0 {
		predicates = append(predicates, tender.DeveloperIn(i.DeveloperIn...))
	}
	if len(i.DeveloperNotIn) > 0 {
		predicates = append(predicates, tender.DeveloperNotIn(i.DeveloperNotIn...))
	}
	if i.DeveloperGT != nil {
		predicates = append(predicates, tender.DeveloperGT(*i.DeveloperGT))
	}
	if i.DeveloperGTE != nil {
		predicates = append(predicates, tender.DeveloperGTE(*i.DeveloperGTE))
	}
	if i.DeveloperLT != nil {
		predicates = append(predicates, tender.DeveloperLT(*i.DeveloperLT))
	}
	if i.DeveloperLTE != nil {
		predicates = append(predicates, tender.DeveloperLTE(*i.DeveloperLTE))
	}
	if i.DeveloperContains != nil {
		predicates = append(predicates, tender.DeveloperContains(*i.DeveloperContains))
	}
	if i.DeveloperHasPrefix != nil {
		predicates = append(predicates, tender.DeveloperHasPrefix(*i.DeveloperHasPrefix))
	}
	if i.DeveloperHasSuffix != nil {
		predicates = append(predicates, tender.DeveloperHasSuffix(*i.DeveloperHasSuffix))
	}
	if i.DeveloperIsNil {
		predicates = append(predicates, tender.DeveloperIsNil())
	}
	if i.DeveloperNotNil {
		predicates = append(predicates, tender.DeveloperNotNil())
	}
	if i.DeveloperEqualFold != nil {
		predicates = append(predicates, tender.DeveloperEqualFold(*i.DeveloperEqualFold))
	}
	if i.DeveloperContainsFold != nil {
		predicates = append(predicates, tender.DeveloperContainsFold(*i.DeveloperContainsFold))
	}
	if i.TenderClosingDate != nil {
		predicates = append(predicates, tender.TenderClosingDateEQ(*i.TenderClosingDate))
	}
	if i.TenderClosingDateNEQ != nil {
		predicates = append(predicates, tender.TenderClosingDateNEQ(*i.TenderClosingDateNEQ))
	}
	if len(i.TenderClosingDateIn) > 0 {
		predicates = append(predicates, tender.TenderClosingDateIn(i.TenderClosingDateIn...))
	}
	if len(i.TenderClosingDateNotIn) > 0 {
		predicates = append(predicates, tender.TenderClosingDateNotIn(i.TenderClosingDateNotIn...))
	}
	if i.TenderClosingDateGT != nil {
		predicates = append(predicates, tender.TenderClosingDateGT(*i.TenderClosingDateGT))
	}
	if i.TenderClosingDateGTE != nil {
		predicates = append(predicates, tender.TenderClosingDateGTE(*i.TenderClosingDateGTE))
	}
	if i.TenderClosingDateLT != nil {
		predicates = append(predicates, tender.TenderClosingDateLT(*i.TenderClosingDateLT))
	}
	if i.TenderClosingDateLTE != nil {
		predicates = append(predicates, tender.TenderClosingDateLTE(*i.TenderClosingDateLTE))
	}
	if i.TenderClosingDateIsNil {
		predicates = append(predicates, tender.TenderClosingDateIsNil())
	}
	if i.TenderClosingDateNotNil {
		predicates = append(predicates, tender.TenderClosingDateNotNil())
	}
	if i.ConstructionArea != nil {
		predicates = append(predicates, tender.ConstructionAreaEQ(*i.ConstructionArea))
	}
	if i.ConstructionAreaNEQ != nil {
		predicates = append(predicates, tender.ConstructionAreaNEQ(*i.ConstructionAreaNEQ))
	}
	if len(i.ConstructionAreaIn) > 0 {
		predicates = append(predicates, tender.ConstructionAreaIn(i.ConstructionAreaIn...))
	}
	if len(i.ConstructionAreaNotIn) > 0 {
		predicates = append(predicates, tender.ConstructionAreaNotIn(i.ConstructionAreaNotIn...))
	}
	if i.ConstructionAreaGT != nil {
		predicates = append(predicates, tender.ConstructionAreaGT(*i.ConstructionAreaGT))
	}
	if i.ConstructionAreaGTE != nil {
		predicates = append(predicates, tender.ConstructionAreaGTE(*i.ConstructionAreaGTE))
	}
	if i.ConstructionAreaLT != nil {
		predicates = append(predicates, tender.ConstructionAreaLT(*i.ConstructionAreaLT))
	}
	if i.ConstructionAreaLTE != nil {
		predicates = append(predicates, tender.ConstructionAreaLTE(*i.ConstructionAreaLTE))
	}
	if i.ConstructionAreaContains != nil {
		predicates = append(predicates, tender.ConstructionAreaContains(*i.ConstructionAreaContains))
	}
	if i.ConstructionAreaHasPrefix != nil {
		predicates = append(predicates, tender.ConstructionAreaHasPrefix(*i.ConstructionAreaHasPrefix))
	}
	if i.ConstructionAreaHasSuffix != nil {
		predicates = append(predicates, tender.ConstructionAreaHasSuffix(*i.ConstructionAreaHasSuffix))
	}
	if i.ConstructionAreaIsNil {
		predicates = append(predicates, tender.ConstructionAreaIsNil())
	}
	if i.ConstructionAreaNotNil {
		predicates = append(predicates, tender.ConstructionAreaNotNil())
	}
	if i.ConstructionAreaEqualFold != nil {
		predicates = append(predicates, tender.ConstructionAreaEqualFold(*i.ConstructionAreaEqualFold))
	}
	if i.ConstructionAreaContainsFold != nil {
		predicates = append(predicates, tender.ConstructionAreaContainsFold(*i.ConstructionAreaContainsFold))
	}
	if i.TenderWinDate != nil {
		predicates = append(predicates, tender.TenderWinDateEQ(*i.TenderWinDate))
	}
	if i.TenderWinDateNEQ != nil {
		predicates = append(predicates, tender.TenderWinDateNEQ(*i.TenderWinDateNEQ))
	}
	if len(i.TenderWinDateIn) > 0 {
		predicates = append(predicates, tender.TenderWinDateIn(i.TenderWinDateIn...))
	}
	if len(i.TenderWinDateNotIn) > 0 {
		predicates = append(predicates, tender.TenderWinDateNotIn(i.TenderWinDateNotIn...))
	}
	if i.TenderWinDateGT != nil {
		predicates = append(predicates, tender.TenderWinDateGT(*i.TenderWinDateGT))
	}
	if i.TenderWinDateGTE != nil {
		predicates = append(predicates, tender.TenderWinDateGTE(*i.TenderWinDateGTE))
	}
	if i.TenderWinDateLT != nil {
		predicates = append(predicates, tender.TenderWinDateLT(*i.TenderWinDateLT))
	}
	if i.TenderWinDateLTE != nil {
		predicates = append(predicates, tender.TenderWinDateLTE(*i.TenderWinDateLTE))
	}
	if i.TenderWinDateIsNil {
		predicates = append(predicates, tender.TenderWinDateIsNil())
	}
	if i.TenderWinDateNotNil {
		predicates = append(predicates, tender.TenderWinDateNotNil())
	}
	if i.TenderWinAmount != nil {
		predicates = append(predicates, tender.TenderWinAmountEQ(*i.TenderWinAmount))
	}
	if i.TenderWinAmountNEQ != nil {
		predicates = append(predicates, tender.TenderWinAmountNEQ(*i.TenderWinAmountNEQ))
	}
	if len(i.TenderWinAmountIn) > 0 {
		predicates = append(predicates, tender.TenderWinAmountIn(i.TenderWinAmountIn...))
	}
	if len(i.TenderWinAmountNotIn) > 0 {
		predicates = append(predicates, tender.TenderWinAmountNotIn(i.TenderWinAmountNotIn...))
	}
	if i.TenderWinAmountGT != nil {
		predicates = append(predicates, tender.TenderWinAmountGT(*i.TenderWinAmountGT))
	}
	if i.TenderWinAmountGTE != nil {
		predicates = append(predicates, tender.TenderWinAmountGTE(*i.TenderWinAmountGTE))
	}
	if i.TenderWinAmountLT != nil {
		predicates = append(predicates, tender.TenderWinAmountLT(*i.TenderWinAmountLT))
	}
	if i.TenderWinAmountLTE != nil {
		predicates = append(predicates, tender.TenderWinAmountLTE(*i.TenderWinAmountLTE))
	}
	if i.TenderWinAmountIsNil {
		predicates = append(predicates, tender.TenderWinAmountIsNil())
	}
	if i.TenderWinAmountNotNil {
		predicates = append(predicates, tender.TenderWinAmountNotNil())
	}
	if i.LastTenderAmount != nil {
		predicates = append(predicates, tender.LastTenderAmountEQ(*i.LastTenderAmount))
	}
	if i.LastTenderAmountNEQ != nil {
		predicates = append(predicates, tender.LastTenderAmountNEQ(*i.LastTenderAmountNEQ))
	}
	if len(i.LastTenderAmountIn) > 0 {
		predicates = append(predicates, tender.LastTenderAmountIn(i.LastTenderAmountIn...))
	}
	if len(i.LastTenderAmountNotIn) > 0 {
		predicates = append(predicates, tender.LastTenderAmountNotIn(i.LastTenderAmountNotIn...))
	}
	if i.LastTenderAmountGT != nil {
		predicates = append(predicates, tender.LastTenderAmountGT(*i.LastTenderAmountGT))
	}
	if i.LastTenderAmountGTE != nil {
		predicates = append(predicates, tender.LastTenderAmountGTE(*i.LastTenderAmountGTE))
	}
	if i.LastTenderAmountLT != nil {
		predicates = append(predicates, tender.LastTenderAmountLT(*i.LastTenderAmountLT))
	}
	if i.LastTenderAmountLTE != nil {
		predicates = append(predicates, tender.LastTenderAmountLTE(*i.LastTenderAmountLTE))
	}
	if i.LastTenderAmountIsNil {
		predicates = append(predicates, tender.LastTenderAmountIsNil())
	}
	if i.LastTenderAmountNotNil {
		predicates = append(predicates, tender.LastTenderAmountNotNil())
	}
	if i.AreaID != nil {
		predicates = append(predicates, tender.AreaIDEQ(*i.AreaID))
	}
	if i.AreaIDNEQ != nil {
		predicates = append(predicates, tender.AreaIDNEQ(*i.AreaIDNEQ))
	}
	if len(i.AreaIDIn) > 0 {
		predicates = append(predicates, tender.AreaIDIn(i.AreaIDIn...))
	}
	if len(i.AreaIDNotIn) > 0 {
		predicates = append(predicates, tender.AreaIDNotIn(i.AreaIDNotIn...))
	}
	if i.AreaIDGT != nil {
		predicates = append(predicates, tender.AreaIDGT(*i.AreaIDGT))
	}
	if i.AreaIDGTE != nil {
		predicates = append(predicates, tender.AreaIDGTE(*i.AreaIDGTE))
	}
	if i.AreaIDLT != nil {
		predicates = append(predicates, tender.AreaIDLT(*i.AreaIDLT))
	}
	if i.AreaIDLTE != nil {
		predicates = append(predicates, tender.AreaIDLTE(*i.AreaIDLTE))
	}
	if i.AreaIDContains != nil {
		predicates = append(predicates, tender.AreaIDContains(*i.AreaIDContains))
	}
	if i.AreaIDHasPrefix != nil {
		predicates = append(predicates, tender.AreaIDHasPrefix(*i.AreaIDHasPrefix))
	}
	if i.AreaIDHasSuffix != nil {
		predicates = append(predicates, tender.AreaIDHasSuffix(*i.AreaIDHasSuffix))
	}
	if i.AreaIDEqualFold != nil {
		predicates = append(predicates, tender.AreaIDEqualFold(*i.AreaIDEqualFold))
	}
	if i.AreaIDContainsFold != nil {
		predicates = append(predicates, tender.AreaIDContainsFold(*i.AreaIDContainsFold))
	}
	if i.ProvinceID != nil {
		predicates = append(predicates, tender.ProvinceIDEQ(*i.ProvinceID))
	}
	if i.ProvinceIDNEQ != nil {
		predicates = append(predicates, tender.ProvinceIDNEQ(*i.ProvinceIDNEQ))
	}
	if len(i.ProvinceIDIn) > 0 {
		predicates = append(predicates, tender.ProvinceIDIn(i.ProvinceIDIn...))
	}
	if len(i.ProvinceIDNotIn) > 0 {
		predicates = append(predicates, tender.ProvinceIDNotIn(i.ProvinceIDNotIn...))
	}
	if i.ProvinceIDGT != nil {
		predicates = append(predicates, tender.ProvinceIDGT(*i.ProvinceIDGT))
	}
	if i.ProvinceIDGTE != nil {
		predicates = append(predicates, tender.ProvinceIDGTE(*i.ProvinceIDGTE))
	}
	if i.ProvinceIDLT != nil {
		predicates = append(predicates, tender.ProvinceIDLT(*i.ProvinceIDLT))
	}
	if i.ProvinceIDLTE != nil {
		predicates = append(predicates, tender.ProvinceIDLTE(*i.ProvinceIDLTE))
	}
	if i.ProvinceIDContains != nil {
		predicates = append(predicates, tender.ProvinceIDContains(*i.ProvinceIDContains))
	}
	if i.ProvinceIDHasPrefix != nil {
		predicates = append(predicates, tender.ProvinceIDHasPrefix(*i.ProvinceIDHasPrefix))
	}
	if i.ProvinceIDHasSuffix != nil {
		predicates = append(predicates, tender.ProvinceIDHasSuffix(*i.ProvinceIDHasSuffix))
	}
	if i.ProvinceIDIsNil {
		predicates = append(predicates, tender.ProvinceIDIsNil())
	}
	if i.ProvinceIDNotNil {
		predicates = append(predicates, tender.ProvinceIDNotNil())
	}
	if i.ProvinceIDEqualFold != nil {
		predicates = append(predicates, tender.ProvinceIDEqualFold(*i.ProvinceIDEqualFold))
	}
	if i.ProvinceIDContainsFold != nil {
		predicates = append(predicates, tender.ProvinceIDContainsFold(*i.ProvinceIDContainsFold))
	}
	if i.CityID != nil {
		predicates = append(predicates, tender.CityIDEQ(*i.CityID))
	}
	if i.CityIDNEQ != nil {
		predicates = append(predicates, tender.CityIDNEQ(*i.CityIDNEQ))
	}
	if len(i.CityIDIn) > 0 {
		predicates = append(predicates, tender.CityIDIn(i.CityIDIn...))
	}
	if len(i.CityIDNotIn) > 0 {
		predicates = append(predicates, tender.CityIDNotIn(i.CityIDNotIn...))
	}
	if i.CityIDGT != nil {
		predicates = append(predicates, tender.CityIDGT(*i.CityIDGT))
	}
	if i.CityIDGTE != nil {
		predicates = append(predicates, tender.CityIDGTE(*i.CityIDGTE))
	}
	if i.CityIDLT != nil {
		predicates = append(predicates, tender.CityIDLT(*i.CityIDLT))
	}
	if i.CityIDLTE != nil {
		predicates = append(predicates, tender.CityIDLTE(*i.CityIDLTE))
	}
	if i.CityIDContains != nil {
		predicates = append(predicates, tender.CityIDContains(*i.CityIDContains))
	}
	if i.CityIDHasPrefix != nil {
		predicates = append(predicates, tender.CityIDHasPrefix(*i.CityIDHasPrefix))
	}
	if i.CityIDHasSuffix != nil {
		predicates = append(predicates, tender.CityIDHasSuffix(*i.CityIDHasSuffix))
	}
	if i.CityIDIsNil {
		predicates = append(predicates, tender.CityIDIsNil())
	}
	if i.CityIDNotNil {
		predicates = append(predicates, tender.CityIDNotNil())
	}
	if i.CityIDEqualFold != nil {
		predicates = append(predicates, tender.CityIDEqualFold(*i.CityIDEqualFold))
	}
	if i.CityIDContainsFold != nil {
		predicates = append(predicates, tender.CityIDContainsFold(*i.CityIDContainsFold))
	}
	if i.DistrictID != nil {
		predicates = append(predicates, tender.DistrictIDEQ(*i.DistrictID))
	}
	if i.DistrictIDNEQ != nil {
		predicates = append(predicates, tender.DistrictIDNEQ(*i.DistrictIDNEQ))
	}
	if len(i.DistrictIDIn) > 0 {
		predicates = append(predicates, tender.DistrictIDIn(i.DistrictIDIn...))
	}
	if len(i.DistrictIDNotIn) > 0 {
		predicates = append(predicates, tender.DistrictIDNotIn(i.DistrictIDNotIn...))
	}
	if i.DistrictIDGT != nil {
		predicates = append(predicates, tender.DistrictIDGT(*i.DistrictIDGT))
	}
	if i.DistrictIDGTE != nil {
		predicates = append(predicates, tender.DistrictIDGTE(*i.DistrictIDGTE))
	}
	if i.DistrictIDLT != nil {
		predicates = append(predicates, tender.DistrictIDLT(*i.DistrictIDLT))
	}
	if i.DistrictIDLTE != nil {
		predicates = append(predicates, tender.DistrictIDLTE(*i.DistrictIDLTE))
	}
	if i.DistrictIDContains != nil {
		predicates = append(predicates, tender.DistrictIDContains(*i.DistrictIDContains))
	}
	if i.DistrictIDHasPrefix != nil {
		predicates = append(predicates, tender.DistrictIDHasPrefix(*i.DistrictIDHasPrefix))
	}
	if i.DistrictIDHasSuffix != nil {
		predicates = append(predicates, tender.DistrictIDHasSuffix(*i.DistrictIDHasSuffix))
	}
	if i.DistrictIDIsNil {
		predicates = append(predicates, tender.DistrictIDIsNil())
	}
	if i.DistrictIDNotNil {
		predicates = append(predicates, tender.DistrictIDNotNil())
	}
	if i.DistrictIDEqualFold != nil {
		predicates = append(predicates, tender.DistrictIDEqualFold(*i.DistrictIDEqualFold))
	}
	if i.DistrictIDContainsFold != nil {
		predicates = append(predicates, tender.DistrictIDContainsFold(*i.DistrictIDContainsFold))
	}
	if i.CustomerID != nil {
		predicates = append(predicates, tender.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, tender.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, tender.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, tender.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDGT != nil {
		predicates = append(predicates, tender.CustomerIDGT(*i.CustomerIDGT))
	}
	if i.CustomerIDGTE != nil {
		predicates = append(predicates, tender.CustomerIDGTE(*i.CustomerIDGTE))
	}
	if i.CustomerIDLT != nil {
		predicates = append(predicates, tender.CustomerIDLT(*i.CustomerIDLT))
	}
	if i.CustomerIDLTE != nil {
		predicates = append(predicates, tender.CustomerIDLTE(*i.CustomerIDLTE))
	}
	if i.CustomerIDContains != nil {
		predicates = append(predicates, tender.CustomerIDContains(*i.CustomerIDContains))
	}
	if i.CustomerIDHasPrefix != nil {
		predicates = append(predicates, tender.CustomerIDHasPrefix(*i.CustomerIDHasPrefix))
	}
	if i.CustomerIDHasSuffix != nil {
		predicates = append(predicates, tender.CustomerIDHasSuffix(*i.CustomerIDHasSuffix))
	}
	if i.CustomerIDIsNil {
		predicates = append(predicates, tender.CustomerIDIsNil())
	}
	if i.CustomerIDNotNil {
		predicates = append(predicates, tender.CustomerIDNotNil())
	}
	if i.CustomerIDEqualFold != nil {
		predicates = append(predicates, tender.CustomerIDEqualFold(*i.CustomerIDEqualFold))
	}
	if i.CustomerIDContainsFold != nil {
		predicates = append(predicates, tender.CustomerIDContainsFold(*i.CustomerIDContainsFold))
	}
	if i.FinderID != nil {
		predicates = append(predicates, tender.FinderIDEQ(*i.FinderID))
	}
	if i.FinderIDNEQ != nil {
		predicates = append(predicates, tender.FinderIDNEQ(*i.FinderIDNEQ))
	}
	if len(i.FinderIDIn) > 0 {
		predicates = append(predicates, tender.FinderIDIn(i.FinderIDIn...))
	}
	if len(i.FinderIDNotIn) > 0 {
		predicates = append(predicates, tender.FinderIDNotIn(i.FinderIDNotIn...))
	}
	if i.FinderIDGT != nil {
		predicates = append(predicates, tender.FinderIDGT(*i.FinderIDGT))
	}
	if i.FinderIDGTE != nil {
		predicates = append(predicates, tender.FinderIDGTE(*i.FinderIDGTE))
	}
	if i.FinderIDLT != nil {
		predicates = append(predicates, tender.FinderIDLT(*i.FinderIDLT))
	}
	if i.FinderIDLTE != nil {
		predicates = append(predicates, tender.FinderIDLTE(*i.FinderIDLTE))
	}
	if i.FinderIDContains != nil {
		predicates = append(predicates, tender.FinderIDContains(*i.FinderIDContains))
	}
	if i.FinderIDHasPrefix != nil {
		predicates = append(predicates, tender.FinderIDHasPrefix(*i.FinderIDHasPrefix))
	}
	if i.FinderIDHasSuffix != nil {
		predicates = append(predicates, tender.FinderIDHasSuffix(*i.FinderIDHasSuffix))
	}
	if i.FinderIDEqualFold != nil {
		predicates = append(predicates, tender.FinderIDEqualFold(*i.FinderIDEqualFold))
	}
	if i.FinderIDContainsFold != nil {
		predicates = append(predicates, tender.FinderIDContainsFold(*i.FinderIDContainsFold))
	}
	if i.CreatedByID != nil {
		predicates = append(predicates, tender.CreatedByIDEQ(*i.CreatedByID))
	}
	if i.CreatedByIDNEQ != nil {
		predicates = append(predicates, tender.CreatedByIDNEQ(*i.CreatedByIDNEQ))
	}
	if len(i.CreatedByIDIn) > 0 {
		predicates = append(predicates, tender.CreatedByIDIn(i.CreatedByIDIn...))
	}
	if len(i.CreatedByIDNotIn) > 0 {
		predicates = append(predicates, tender.CreatedByIDNotIn(i.CreatedByIDNotIn...))
	}
	if i.CreatedByIDGT != nil {
		predicates = append(predicates, tender.CreatedByIDGT(*i.CreatedByIDGT))
	}
	if i.CreatedByIDGTE != nil {
		predicates = append(predicates, tender.CreatedByIDGTE(*i.CreatedByIDGTE))
	}
	if i.CreatedByIDLT != nil {
		predicates = append(predicates, tender.CreatedByIDLT(*i.CreatedByIDLT))
	}
	if i.CreatedByIDLTE != nil {
		predicates = append(predicates, tender.CreatedByIDLTE(*i.CreatedByIDLTE))
	}
	if i.CreatedByIDContains != nil {
		predicates = append(predicates, tender.CreatedByIDContains(*i.CreatedByIDContains))
	}
	if i.CreatedByIDHasPrefix != nil {
		predicates = append(predicates, tender.CreatedByIDHasPrefix(*i.CreatedByIDHasPrefix))
	}
	if i.CreatedByIDHasSuffix != nil {
		predicates = append(predicates, tender.CreatedByIDHasSuffix(*i.CreatedByIDHasSuffix))
	}
	if i.CreatedByIDEqualFold != nil {
		predicates = append(predicates, tender.CreatedByIDEqualFold(*i.CreatedByIDEqualFold))
	}
	if i.CreatedByIDContainsFold != nil {
		predicates = append(predicates, tender.CreatedByIDContainsFold(*i.CreatedByIDContainsFold))
	}

	if i.HasArea != nil {
		p := tender.HasArea()
		if !*i.HasArea {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAreaWith) > 0 {
		with := make([]predicate.Area, 0, len(i.HasAreaWith))
		for _, w := range i.HasAreaWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAreaWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasAreaWith(with...))
	}
	if i.HasCustomer != nil {
		p := tender.HasCustomer()
		if !*i.HasCustomer {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasCustomerWith(with...))
	}
	if i.HasFinder != nil {
		p := tender.HasFinder()
		if !*i.HasFinder {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFinderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasFinderWith))
		for _, w := range i.HasFinderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFinderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasFinderWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := tender.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasCreatedByWith(with...))
	}
	if i.HasFollowingSales != nil {
		p := tender.HasFollowingSales()
		if !*i.HasFollowingSales {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFollowingSalesWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasFollowingSalesWith))
		for _, w := range i.HasFollowingSalesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFollowingSalesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasFollowingSalesWith(with...))
	}
	if i.HasProvince != nil {
		p := tender.HasProvince()
		if !*i.HasProvince {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProvinceWith) > 0 {
		with := make([]predicate.Province, 0, len(i.HasProvinceWith))
		for _, w := range i.HasProvinceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProvinceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasProvinceWith(with...))
	}
	if i.HasCity != nil {
		p := tender.HasCity()
		if !*i.HasCity {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCityWith) > 0 {
		with := make([]predicate.City, 0, len(i.HasCityWith))
		for _, w := range i.HasCityWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCityWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasCityWith(with...))
	}
	if i.HasDistrict != nil {
		p := tender.HasDistrict()
		if !*i.HasDistrict {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDistrictWith) > 0 {
		with := make([]predicate.District, 0, len(i.HasDistrictWith))
		for _, w := range i.HasDistrictWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDistrictWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasDistrictWith(with...))
	}
	if i.HasVisitRecords != nil {
		p := tender.HasVisitRecords()
		if !*i.HasVisitRecords {
			p = tender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVisitRecordsWith) > 0 {
		with := make([]predicate.VisitRecord, 0, len(i.HasVisitRecordsWith))
		for _, w := range i.HasVisitRecordsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVisitRecordsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tender.HasVisitRecordsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTenderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tender.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "open_id" field predicates.
	OpenID             *string  `json:"openID,omitempty"`
	OpenIDNEQ          *string  `json:"openIDNEQ,omitempty"`
	OpenIDIn           []string `json:"openIDIn,omitempty"`
	OpenIDNotIn        []string `json:"openIDNotIn,omitempty"`
	OpenIDGT           *string  `json:"openIDGT,omitempty"`
	OpenIDGTE          *string  `json:"openIDGTE,omitempty"`
	OpenIDLT           *string  `json:"openIDLT,omitempty"`
	OpenIDLTE          *string  `json:"openIDLTE,omitempty"`
	OpenIDContains     *string  `json:"openIDContains,omitempty"`
	OpenIDHasPrefix    *string  `json:"openIDHasPrefix,omitempty"`
	OpenIDHasSuffix    *string  `json:"openIDHasSuffix,omitempty"`
	OpenIDIsNil        bool     `json:"openIDIsNil,omitempty"`
	OpenIDNotNil       bool     `json:"openIDNotNil,omitempty"`
	OpenIDEqualFold    *string  `json:"openIDEqualFold,omitempty"`
	OpenIDContainsFold *string  `json:"openIDContainsFold,omitempty"`

	// "avatar_url" field predicates.
	AvatarURL             *string  `json:"avatarURL,omitempty"`
	AvatarURLNEQ          *string  `json:"avatarURLNEQ,omitempty"`
	AvatarURLIn           []string `json:"avatarURLIn,omitempty"`
	AvatarURLNotIn        []string `json:"avatarURLNotIn,omitempty"`
	AvatarURLGT           *string  `json:"avatarURLGT,omitempty"`
	AvatarURLGTE          *string  `json:"avatarURLGTE,omitempty"`
	AvatarURLLT           *string  `json:"avatarURLLT,omitempty"`
	AvatarURLLTE          *string  `json:"avatarURLLTE,omitempty"`
	AvatarURLContains     *string  `json:"avatarURLContains,omitempty"`
	AvatarURLHasPrefix    *string  `json:"avatarURLHasPrefix,omitempty"`
	AvatarURLHasSuffix    *string  `json:"avatarURLHasSuffix,omitempty"`
	AvatarURLIsNil        bool     `json:"avatarURLIsNil,omitempty"`
	AvatarURLNotNil       bool     `json:"avatarURLNotNil,omitempty"`
	AvatarURLEqualFold    *string  `json:"avatarURLEqualFold,omitempty"`
	AvatarURLContainsFold *string  `json:"avatarURLContainsFold,omitempty"`

	// "disabled" field predicates.
	Disabled    *bool `json:"disabled,omitempty"`
	DisabledNEQ *bool `json:"disabledNEQ,omitempty"`

	// "is_sales" field predicates.
	IsSales    *bool `json:"isSales,omitempty"`
	IsSalesNEQ *bool `json:"isSalesNEQ,omitempty"`

	// "is_admin" field predicates.
	IsAdmin    *bool `json:"isAdmin,omitempty"`
	IsAdminNEQ *bool `json:"isAdminNEQ,omitempty"`

	// "is_leader" field predicates.
	IsLeader    *bool `json:"isLeader,omitempty"`
	IsLeaderNEQ *bool `json:"isLeaderNEQ,omitempty"`

	// "is_super_admin" field predicates.
	IsSuperAdmin    *bool `json:"isSuperAdmin,omitempty"`
	IsSuperAdminNEQ *bool `json:"isSuperAdminNEQ,omitempty"`

	// "has_map_access" field predicates.
	HasMapAccess    *bool `json:"hasMapAccess,omitempty"`
	HasMapAccessNEQ *bool `json:"hasMapAccessNEQ,omitempty"`

	// "has_edit_access" field predicates.
	HasEditAccess    *bool `json:"hasEditAccess,omitempty"`
	HasEditAccessNEQ *bool `json:"hasEditAccessNEQ,omitempty"`

	// "leader_id" field predicates.
	LeaderID             *xid.ID  `json:"leaderID,omitempty"`
	LeaderIDNEQ          *xid.ID  `json:"leaderIDNEQ,omitempty"`
	LeaderIDIn           []xid.ID `json:"leaderIDIn,omitempty"`
	LeaderIDNotIn        []xid.ID `json:"leaderIDNotIn,omitempty"`
	LeaderIDGT           *xid.ID  `json:"leaderIDGT,omitempty"`
	LeaderIDGTE          *xid.ID  `json:"leaderIDGTE,omitempty"`
	LeaderIDLT           *xid.ID  `json:"leaderIDLT,omitempty"`
	LeaderIDLTE          *xid.ID  `json:"leaderIDLTE,omitempty"`
	LeaderIDContains     *xid.ID  `json:"leaderIDContains,omitempty"`
	LeaderIDHasPrefix    *xid.ID  `json:"leaderIDHasPrefix,omitempty"`
	LeaderIDHasSuffix    *xid.ID  `json:"leaderIDHasSuffix,omitempty"`
	LeaderIDIsNil        bool     `json:"leaderIDIsNil,omitempty"`
	LeaderIDNotNil       bool     `json:"leaderIDNotNil,omitempty"`
	LeaderIDEqualFold    *xid.ID  `json:"leaderIDEqualFold,omitempty"`
	LeaderIDContainsFold *xid.ID  `json:"leaderIDContainsFold,omitempty"`

	// "areas" edge predicates.
	HasAreas     *bool             `json:"hasAreas,omitempty"`
	HasAreasWith []*AreaWhereInput `json:"hasAreasWith,omitempty"`

	// "customers" edge predicates.
	HasCustomers     *bool                 `json:"hasCustomers,omitempty"`
	HasCustomersWith []*CustomerWhereInput `json:"hasCustomersWith,omitempty"`

	// "leader" edge predicates.
	HasLeader     *bool             `json:"hasLeader,omitempty"`
	HasLeaderWith []*UserWhereInput `json:"hasLeaderWith,omitempty"`

	// "team_members" edge predicates.
	HasTeamMembers     *bool             `json:"hasTeamMembers,omitempty"`
	HasTeamMembersWith []*UserWhereInput `json:"hasTeamMembersWith,omitempty"`

	// "tenders" edge predicates.
	HasTenders     *bool               `json:"hasTenders,omitempty"`
	HasTendersWith []*TenderWhereInput `json:"hasTendersWith,omitempty"`

	// "visit_records" edge predicates.
	HasVisitRecords     *bool                    `json:"hasVisitRecords,omitempty"`
	HasVisitRecordsWith []*VisitRecordWhereInput `json:"hasVisitRecordsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.OpenID != nil {
		predicates = append(predicates, user.OpenIDEQ(*i.OpenID))
	}
	if i.OpenIDNEQ != nil {
		predicates = append(predicates, user.OpenIDNEQ(*i.OpenIDNEQ))
	}
	if len(i.OpenIDIn) > 0 {
		predicates = append(predicates, user.OpenIDIn(i.OpenIDIn...))
	}
	if len(i.OpenIDNotIn) > 0 {
		predicates = append(predicates, user.OpenIDNotIn(i.OpenIDNotIn...))
	}
	if i.OpenIDGT != nil {
		predicates = append(predicates, user.OpenIDGT(*i.OpenIDGT))
	}
	if i.OpenIDGTE != nil {
		predicates = append(predicates, user.OpenIDGTE(*i.OpenIDGTE))
	}
	if i.OpenIDLT != nil {
		predicates = append(predicates, user.OpenIDLT(*i.OpenIDLT))
	}
	if i.OpenIDLTE != nil {
		predicates = append(predicates, user.OpenIDLTE(*i.OpenIDLTE))
	}
	if i.OpenIDContains != nil {
		predicates = append(predicates, user.OpenIDContains(*i.OpenIDContains))
	}
	if i.OpenIDHasPrefix != nil {
		predicates = append(predicates, user.OpenIDHasPrefix(*i.OpenIDHasPrefix))
	}
	if i.OpenIDHasSuffix != nil {
		predicates = append(predicates, user.OpenIDHasSuffix(*i.OpenIDHasSuffix))
	}
	if i.OpenIDIsNil {
		predicates = append(predicates, user.OpenIDIsNil())
	}
	if i.OpenIDNotNil {
		predicates = append(predicates, user.OpenIDNotNil())
	}
	if i.OpenIDEqualFold != nil {
		predicates = append(predicates, user.OpenIDEqualFold(*i.OpenIDEqualFold))
	}
	if i.OpenIDContainsFold != nil {
		predicates = append(predicates, user.OpenIDContainsFold(*i.OpenIDContainsFold))
	}
	if i.AvatarURL != nil {
		predicates = append(predicates, user.AvatarURLEQ(*i.AvatarURL))
	}
	if i.AvatarURLNEQ != nil {
		predicates = append(predicates, user.AvatarURLNEQ(*i.AvatarURLNEQ))
	}
	if len(i.AvatarURLIn) > 0 {
		predicates = append(predicates, user.AvatarURLIn(i.AvatarURLIn...))
	}
	if len(i.AvatarURLNotIn) > 0 {
		predicates = append(predicates, user.AvatarURLNotIn(i.AvatarURLNotIn...))
	}
	if i.AvatarURLGT != nil {
		predicates = append(predicates, user.AvatarURLGT(*i.AvatarURLGT))
	}
	if i.AvatarURLGTE != nil {
		predicates = append(predicates, user.AvatarURLGTE(*i.AvatarURLGTE))
	}
	if i.AvatarURLLT != nil {
		predicates = append(predicates, user.AvatarURLLT(*i.AvatarURLLT))
	}
	if i.AvatarURLLTE != nil {
		predicates = append(predicates, user.AvatarURLLTE(*i.AvatarURLLTE))
	}
	if i.AvatarURLContains != nil {
		predicates = append(predicates, user.AvatarURLContains(*i.AvatarURLContains))
	}
	if i.AvatarURLHasPrefix != nil {
		predicates = append(predicates, user.AvatarURLHasPrefix(*i.AvatarURLHasPrefix))
	}
	if i.AvatarURLHasSuffix != nil {
		predicates = append(predicates, user.AvatarURLHasSuffix(*i.AvatarURLHasSuffix))
	}
	if i.AvatarURLIsNil {
		predicates = append(predicates, user.AvatarURLIsNil())
	}
	if i.AvatarURLNotNil {
		predicates = append(predicates, user.AvatarURLNotNil())
	}
	if i.AvatarURLEqualFold != nil {
		predicates = append(predicates, user.AvatarURLEqualFold(*i.AvatarURLEqualFold))
	}
	if i.AvatarURLContainsFold != nil {
		predicates = append(predicates, user.AvatarURLContainsFold(*i.AvatarURLContainsFold))
	}
	if i.Disabled != nil {
		predicates = append(predicates, user.DisabledEQ(*i.Disabled))
	}
	if i.DisabledNEQ != nil {
		predicates = append(predicates, user.DisabledNEQ(*i.DisabledNEQ))
	}
	if i.IsSales != nil {
		predicates = append(predicates, user.IsSalesEQ(*i.IsSales))
	}
	if i.IsSalesNEQ != nil {
		predicates = append(predicates, user.IsSalesNEQ(*i.IsSalesNEQ))
	}
	if i.IsAdmin != nil {
		predicates = append(predicates, user.IsAdminEQ(*i.IsAdmin))
	}
	if i.IsAdminNEQ != nil {
		predicates = append(predicates, user.IsAdminNEQ(*i.IsAdminNEQ))
	}
	if i.IsLeader != nil {
		predicates = append(predicates, user.IsLeaderEQ(*i.IsLeader))
	}
	if i.IsLeaderNEQ != nil {
		predicates = append(predicates, user.IsLeaderNEQ(*i.IsLeaderNEQ))
	}
	if i.IsSuperAdmin != nil {
		predicates = append(predicates, user.IsSuperAdminEQ(*i.IsSuperAdmin))
	}
	if i.IsSuperAdminNEQ != nil {
		predicates = append(predicates, user.IsSuperAdminNEQ(*i.IsSuperAdminNEQ))
	}
	if i.HasMapAccess != nil {
		predicates = append(predicates, user.HasMapAccessEQ(*i.HasMapAccess))
	}
	if i.HasMapAccessNEQ != nil {
		predicates = append(predicates, user.HasMapAccessNEQ(*i.HasMapAccessNEQ))
	}
	if i.HasEditAccess != nil {
		predicates = append(predicates, user.HasEditAccessEQ(*i.HasEditAccess))
	}
	if i.HasEditAccessNEQ != nil {
		predicates = append(predicates, user.HasEditAccessNEQ(*i.HasEditAccessNEQ))
	}
	if i.LeaderID != nil {
		predicates = append(predicates, user.LeaderIDEQ(*i.LeaderID))
	}
	if i.LeaderIDNEQ != nil {
		predicates = append(predicates, user.LeaderIDNEQ(*i.LeaderIDNEQ))
	}
	if len(i.LeaderIDIn) > 0 {
		predicates = append(predicates, user.LeaderIDIn(i.LeaderIDIn...))
	}
	if len(i.LeaderIDNotIn) > 0 {
		predicates = append(predicates, user.LeaderIDNotIn(i.LeaderIDNotIn...))
	}
	if i.LeaderIDGT != nil {
		predicates = append(predicates, user.LeaderIDGT(*i.LeaderIDGT))
	}
	if i.LeaderIDGTE != nil {
		predicates = append(predicates, user.LeaderIDGTE(*i.LeaderIDGTE))
	}
	if i.LeaderIDLT != nil {
		predicates = append(predicates, user.LeaderIDLT(*i.LeaderIDLT))
	}
	if i.LeaderIDLTE != nil {
		predicates = append(predicates, user.LeaderIDLTE(*i.LeaderIDLTE))
	}
	if i.LeaderIDContains != nil {
		predicates = append(predicates, user.LeaderIDContains(*i.LeaderIDContains))
	}
	if i.LeaderIDHasPrefix != nil {
		predicates = append(predicates, user.LeaderIDHasPrefix(*i.LeaderIDHasPrefix))
	}
	if i.LeaderIDHasSuffix != nil {
		predicates = append(predicates, user.LeaderIDHasSuffix(*i.LeaderIDHasSuffix))
	}
	if i.LeaderIDIsNil {
		predicates = append(predicates, user.LeaderIDIsNil())
	}
	if i.LeaderIDNotNil {
		predicates = append(predicates, user.LeaderIDNotNil())
	}
	if i.LeaderIDEqualFold != nil {
		predicates = append(predicates, user.LeaderIDEqualFold(*i.LeaderIDEqualFold))
	}
	if i.LeaderIDContainsFold != nil {
		predicates = append(predicates, user.LeaderIDContainsFold(*i.LeaderIDContainsFold))
	}

	if i.HasAreas != nil {
		p := user.HasAreas()
		if !*i.HasAreas {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAreasWith) > 0 {
		with := make([]predicate.Area, 0, len(i.HasAreasWith))
		for _, w := range i.HasAreasWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAreasWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAreasWith(with...))
	}
	if i.HasCustomers != nil {
		p := user.HasCustomers()
		if !*i.HasCustomers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomersWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomersWith))
		for _, w := range i.HasCustomersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCustomersWith(with...))
	}
	if i.HasLeader != nil {
		p := user.HasLeader()
		if !*i.HasLeader {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLeaderWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasLeaderWith))
		for _, w := range i.HasLeaderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLeaderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLeaderWith(with...))
	}
	if i.HasTeamMembers != nil {
		p := user.HasTeamMembers()
		if !*i.HasTeamMembers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTeamMembersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasTeamMembersWith))
		for _, w := range i.HasTeamMembersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTeamMembersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTeamMembersWith(with...))
	}
	if i.HasTenders != nil {
		p := user.HasTenders()
		if !*i.HasTenders {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTendersWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTendersWith))
		for _, w := range i.HasTendersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTendersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTendersWith(with...))
	}
	if i.HasVisitRecords != nil {
		p := user.HasVisitRecords()
		if !*i.HasVisitRecords {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVisitRecordsWith) > 0 {
		with := make([]predicate.VisitRecord, 0, len(i.HasVisitRecordsWith))
		for _, w := range i.HasVisitRecordsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVisitRecordsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasVisitRecordsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// VisitRecordWhereInput represents a where input for filtering VisitRecord queries.
type VisitRecordWhereInput struct {
	Predicates []predicate.VisitRecord  `json:"-"`
	Not        *VisitRecordWhereInput   `json:"not,omitempty"`
	Or         []*VisitRecordWhereInput `json:"or,omitempty"`
	And        []*VisitRecordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *xid.ID  `json:"id,omitempty"`
	IDNEQ   *xid.ID  `json:"idNEQ,omitempty"`
	IDIn    []xid.ID `json:"idIn,omitempty"`
	IDNotIn []xid.ID `json:"idNotIn,omitempty"`
	IDGT    *xid.ID  `json:"idGT,omitempty"`
	IDGTE   *xid.ID  `json:"idGTE,omitempty"`
	IDLT    *xid.ID  `json:"idLT,omitempty"`
	IDLTE   *xid.ID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "visit_type" field predicates.
	VisitType      *int  `json:"visitType,omitempty"`
	VisitTypeNEQ   *int  `json:"visitTypeNEQ,omitempty"`
	VisitTypeIn    []int `json:"visitTypeIn,omitempty"`
	VisitTypeNotIn []int `json:"visitTypeNotIn,omitempty"`
	VisitTypeGT    *int  `json:"visitTypeGT,omitempty"`
	VisitTypeGTE   *int  `json:"visitTypeGTE,omitempty"`
	VisitTypeLT    *int  `json:"visitTypeLT,omitempty"`
	VisitTypeLTE   *int  `json:"visitTypeLTE,omitempty"`

	// "comm_people" field predicates.
	CommPeople             *string  `json:"commPeople,omitempty"`
	CommPeopleNEQ          *string  `json:"commPeopleNEQ,omitempty"`
	CommPeopleIn           []string `json:"commPeopleIn,omitempty"`
	CommPeopleNotIn        []string `json:"commPeopleNotIn,omitempty"`
	CommPeopleGT           *string  `json:"commPeopleGT,omitempty"`
	CommPeopleGTE          *string  `json:"commPeopleGTE,omitempty"`
	CommPeopleLT           *string  `json:"commPeopleLT,omitempty"`
	CommPeopleLTE          *string  `json:"commPeopleLTE,omitempty"`
	CommPeopleContains     *string  `json:"commPeopleContains,omitempty"`
	CommPeopleHasPrefix    *string  `json:"commPeopleHasPrefix,omitempty"`
	CommPeopleHasSuffix    *string  `json:"commPeopleHasSuffix,omitempty"`
	CommPeopleEqualFold    *string  `json:"commPeopleEqualFold,omitempty"`
	CommPeopleContainsFold *string  `json:"commPeopleContainsFold,omitempty"`

	// "comm_content" field predicates.
	CommContent             *string  `json:"commContent,omitempty"`
	CommContentNEQ          *string  `json:"commContentNEQ,omitempty"`
	CommContentIn           []string `json:"commContentIn,omitempty"`
	CommContentNotIn        []string `json:"commContentNotIn,omitempty"`
	CommContentGT           *string  `json:"commContentGT,omitempty"`
	CommContentGTE          *string  `json:"commContentGTE,omitempty"`
	CommContentLT           *string  `json:"commContentLT,omitempty"`
	CommContentLTE          *string  `json:"commContentLTE,omitempty"`
	CommContentContains     *string  `json:"commContentContains,omitempty"`
	CommContentHasPrefix    *string  `json:"commContentHasPrefix,omitempty"`
	CommContentHasSuffix    *string  `json:"commContentHasSuffix,omitempty"`
	CommContentEqualFold    *string  `json:"commContentEqualFold,omitempty"`
	CommContentContainsFold *string  `json:"commContentContainsFold,omitempty"`

	// "next_step" field predicates.
	NextStep             *string  `json:"nextStep,omitempty"`
	NextStepNEQ          *string  `json:"nextStepNEQ,omitempty"`
	NextStepIn           []string `json:"nextStepIn,omitempty"`
	NextStepNotIn        []string `json:"nextStepNotIn,omitempty"`
	NextStepGT           *string  `json:"nextStepGT,omitempty"`
	NextStepGTE          *string  `json:"nextStepGTE,omitempty"`
	NextStepLT           *string  `json:"nextStepLT,omitempty"`
	NextStepLTE          *string  `json:"nextStepLTE,omitempty"`
	NextStepContains     *string  `json:"nextStepContains,omitempty"`
	NextStepHasPrefix    *string  `json:"nextStepHasPrefix,omitempty"`
	NextStepHasSuffix    *string  `json:"nextStepHasSuffix,omitempty"`
	NextStepIsNil        bool     `json:"nextStepIsNil,omitempty"`
	NextStepNotNil       bool     `json:"nextStepNotNil,omitempty"`
	NextStepEqualFold    *string  `json:"nextStepEqualFold,omitempty"`
	NextStepContainsFold *string  `json:"nextStepContainsFold,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "tender_id" field predicates.
	TenderID             *xid.ID  `json:"tenderID,omitempty"`
	TenderIDNEQ          *xid.ID  `json:"tenderIDNEQ,omitempty"`
	TenderIDIn           []xid.ID `json:"tenderIDIn,omitempty"`
	TenderIDNotIn        []xid.ID `json:"tenderIDNotIn,omitempty"`
	TenderIDGT           *xid.ID  `json:"tenderIDGT,omitempty"`
	TenderIDGTE          *xid.ID  `json:"tenderIDGTE,omitempty"`
	TenderIDLT           *xid.ID  `json:"tenderIDLT,omitempty"`
	TenderIDLTE          *xid.ID  `json:"tenderIDLTE,omitempty"`
	TenderIDContains     *xid.ID  `json:"tenderIDContains,omitempty"`
	TenderIDHasPrefix    *xid.ID  `json:"tenderIDHasPrefix,omitempty"`
	TenderIDHasSuffix    *xid.ID  `json:"tenderIDHasSuffix,omitempty"`
	TenderIDIsNil        bool     `json:"tenderIDIsNil,omitempty"`
	TenderIDNotNil       bool     `json:"tenderIDNotNil,omitempty"`
	TenderIDEqualFold    *xid.ID  `json:"tenderIDEqualFold,omitempty"`
	TenderIDContainsFold *xid.ID  `json:"tenderIDContainsFold,omitempty"`

	// "customer_id" field predicates.
	CustomerID             *xid.ID  `json:"customerID,omitempty"`
	CustomerIDNEQ          *xid.ID  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn           []xid.ID `json:"customerIDIn,omitempty"`
	CustomerIDNotIn        []xid.ID `json:"customerIDNotIn,omitempty"`
	CustomerIDGT           *xid.ID  `json:"customerIDGT,omitempty"`
	CustomerIDGTE          *xid.ID  `json:"customerIDGTE,omitempty"`
	CustomerIDLT           *xid.ID  `json:"customerIDLT,omitempty"`
	CustomerIDLTE          *xid.ID  `json:"customerIDLTE,omitempty"`
	CustomerIDContains     *xid.ID  `json:"customerIDContains,omitempty"`
	CustomerIDHasPrefix    *xid.ID  `json:"customerIDHasPrefix,omitempty"`
	CustomerIDHasSuffix    *xid.ID  `json:"customerIDHasSuffix,omitempty"`
	CustomerIDIsNil        bool     `json:"customerIDIsNil,omitempty"`
	CustomerIDNotNil       bool     `json:"customerIDNotNil,omitempty"`
	CustomerIDEqualFold    *xid.ID  `json:"customerIDEqualFold,omitempty"`
	CustomerIDContainsFold *xid.ID  `json:"customerIDContainsFold,omitempty"`

	// "tender" edge predicates.
	HasTender     *bool               `json:"hasTender,omitempty"`
	HasTenderWith []*TenderWhereInput `json:"hasTenderWith,omitempty"`

	// "customer" edge predicates.
	HasCustomer     *bool                 `json:"hasCustomer,omitempty"`
	HasCustomerWith []*CustomerWhereInput `json:"hasCustomerWith,omitempty"`

	// "followUpBys" edge predicates.
	HasFollowUpBys     *bool             `json:"hasFollowUpBys,omitempty"`
	HasFollowUpBysWith []*UserWhereInput `json:"hasFollowUpBysWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *VisitRecordWhereInput) AddPredicates(predicates ...predicate.VisitRecord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the VisitRecordWhereInput filter on the VisitRecordQuery builder.
func (i *VisitRecordWhereInput) Filter(q *VisitRecordQuery) (*VisitRecordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyVisitRecordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyVisitRecordWhereInput is returned in case the VisitRecordWhereInput is empty.
var ErrEmptyVisitRecordWhereInput = errors.New("ent: empty predicate VisitRecordWhereInput")

// P returns a predicate for filtering visitrecords.
// An error is returned if the input is empty or invalid.
func (i *VisitRecordWhereInput) P() (predicate.VisitRecord, error) {
	var predicates []predicate.VisitRecord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, visitrecord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.VisitRecord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, visitrecord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.VisitRecord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, visitrecord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, visitrecord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, visitrecord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, visitrecord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, visitrecord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, visitrecord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, visitrecord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, visitrecord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, visitrecord.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, visitrecord.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, visitrecord.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, visitrecord.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, visitrecord.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, visitrecord.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, visitrecord.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, visitrecord.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, visitrecord.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, visitrecord.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, visitrecord.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, visitrecord.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, visitrecord.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, visitrecord.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, visitrecord.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, visitrecord.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, visitrecord.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.VisitType != nil {
		predicates = append(predicates, visitrecord.VisitTypeEQ(*i.VisitType))
	}
	if i.VisitTypeNEQ != nil {
		predicates = append(predicates, visitrecord.VisitTypeNEQ(*i.VisitTypeNEQ))
	}
	if len(i.VisitTypeIn) > 0 {
		predicates = append(predicates, visitrecord.VisitTypeIn(i.VisitTypeIn...))
	}
	if len(i.VisitTypeNotIn) > 0 {
		predicates = append(predicates, visitrecord.VisitTypeNotIn(i.VisitTypeNotIn...))
	}
	if i.VisitTypeGT != nil {
		predicates = append(predicates, visitrecord.VisitTypeGT(*i.VisitTypeGT))
	}
	if i.VisitTypeGTE != nil {
		predicates = append(predicates, visitrecord.VisitTypeGTE(*i.VisitTypeGTE))
	}
	if i.VisitTypeLT != nil {
		predicates = append(predicates, visitrecord.VisitTypeLT(*i.VisitTypeLT))
	}
	if i.VisitTypeLTE != nil {
		predicates = append(predicates, visitrecord.VisitTypeLTE(*i.VisitTypeLTE))
	}
	if i.CommPeople != nil {
		predicates = append(predicates, visitrecord.CommPeopleEQ(*i.CommPeople))
	}
	if i.CommPeopleNEQ != nil {
		predicates = append(predicates, visitrecord.CommPeopleNEQ(*i.CommPeopleNEQ))
	}
	if len(i.CommPeopleIn) > 0 {
		predicates = append(predicates, visitrecord.CommPeopleIn(i.CommPeopleIn...))
	}
	if len(i.CommPeopleNotIn) > 0 {
		predicates = append(predicates, visitrecord.CommPeopleNotIn(i.CommPeopleNotIn...))
	}
	if i.CommPeopleGT != nil {
		predicates = append(predicates, visitrecord.CommPeopleGT(*i.CommPeopleGT))
	}
	if i.CommPeopleGTE != nil {
		predicates = append(predicates, visitrecord.CommPeopleGTE(*i.CommPeopleGTE))
	}
	if i.CommPeopleLT != nil {
		predicates = append(predicates, visitrecord.CommPeopleLT(*i.CommPeopleLT))
	}
	if i.CommPeopleLTE != nil {
		predicates = append(predicates, visitrecord.CommPeopleLTE(*i.CommPeopleLTE))
	}
	if i.CommPeopleContains != nil {
		predicates = append(predicates, visitrecord.CommPeopleContains(*i.CommPeopleContains))
	}
	if i.CommPeopleHasPrefix != nil {
		predicates = append(predicates, visitrecord.CommPeopleHasPrefix(*i.CommPeopleHasPrefix))
	}
	if i.CommPeopleHasSuffix != nil {
		predicates = append(predicates, visitrecord.CommPeopleHasSuffix(*i.CommPeopleHasSuffix))
	}
	if i.CommPeopleEqualFold != nil {
		predicates = append(predicates, visitrecord.CommPeopleEqualFold(*i.CommPeopleEqualFold))
	}
	if i.CommPeopleContainsFold != nil {
		predicates = append(predicates, visitrecord.CommPeopleContainsFold(*i.CommPeopleContainsFold))
	}
	if i.CommContent != nil {
		predicates = append(predicates, visitrecord.CommContentEQ(*i.CommContent))
	}
	if i.CommContentNEQ != nil {
		predicates = append(predicates, visitrecord.CommContentNEQ(*i.CommContentNEQ))
	}
	if len(i.CommContentIn) > 0 {
		predicates = append(predicates, visitrecord.CommContentIn(i.CommContentIn...))
	}
	if len(i.CommContentNotIn) > 0 {
		predicates = append(predicates, visitrecord.CommContentNotIn(i.CommContentNotIn...))
	}
	if i.CommContentGT != nil {
		predicates = append(predicates, visitrecord.CommContentGT(*i.CommContentGT))
	}
	if i.CommContentGTE != nil {
		predicates = append(predicates, visitrecord.CommContentGTE(*i.CommContentGTE))
	}
	if i.CommContentLT != nil {
		predicates = append(predicates, visitrecord.CommContentLT(*i.CommContentLT))
	}
	if i.CommContentLTE != nil {
		predicates = append(predicates, visitrecord.CommContentLTE(*i.CommContentLTE))
	}
	if i.CommContentContains != nil {
		predicates = append(predicates, visitrecord.CommContentContains(*i.CommContentContains))
	}
	if i.CommContentHasPrefix != nil {
		predicates = append(predicates, visitrecord.CommContentHasPrefix(*i.CommContentHasPrefix))
	}
	if i.CommContentHasSuffix != nil {
		predicates = append(predicates, visitrecord.CommContentHasSuffix(*i.CommContentHasSuffix))
	}
	if i.CommContentEqualFold != nil {
		predicates = append(predicates, visitrecord.CommContentEqualFold(*i.CommContentEqualFold))
	}
	if i.CommContentContainsFold != nil {
		predicates = append(predicates, visitrecord.CommContentContainsFold(*i.CommContentContainsFold))
	}
	if i.NextStep != nil {
		predicates = append(predicates, visitrecord.NextStepEQ(*i.NextStep))
	}
	if i.NextStepNEQ != nil {
		predicates = append(predicates, visitrecord.NextStepNEQ(*i.NextStepNEQ))
	}
	if len(i.NextStepIn) > 0 {
		predicates = append(predicates, visitrecord.NextStepIn(i.NextStepIn...))
	}
	if len(i.NextStepNotIn) > 0 {
		predicates = append(predicates, visitrecord.NextStepNotIn(i.NextStepNotIn...))
	}
	if i.NextStepGT != nil {
		predicates = append(predicates, visitrecord.NextStepGT(*i.NextStepGT))
	}
	if i.NextStepGTE != nil {
		predicates = append(predicates, visitrecord.NextStepGTE(*i.NextStepGTE))
	}
	if i.NextStepLT != nil {
		predicates = append(predicates, visitrecord.NextStepLT(*i.NextStepLT))
	}
	if i.NextStepLTE != nil {
		predicates = append(predicates, visitrecord.NextStepLTE(*i.NextStepLTE))
	}
	if i.NextStepContains != nil {
		predicates = append(predicates, visitrecord.NextStepContains(*i.NextStepContains))
	}
	if i.NextStepHasPrefix != nil {
		predicates = append(predicates, visitrecord.NextStepHasPrefix(*i.NextStepHasPrefix))
	}
	if i.NextStepHasSuffix != nil {
		predicates = append(predicates, visitrecord.NextStepHasSuffix(*i.NextStepHasSuffix))
	}
	if i.NextStepIsNil {
		predicates = append(predicates, visitrecord.NextStepIsNil())
	}
	if i.NextStepNotNil {
		predicates = append(predicates, visitrecord.NextStepNotNil())
	}
	if i.NextStepEqualFold != nil {
		predicates = append(predicates, visitrecord.NextStepEqualFold(*i.NextStepEqualFold))
	}
	if i.NextStepContainsFold != nil {
		predicates = append(predicates, visitrecord.NextStepContainsFold(*i.NextStepContainsFold))
	}
	if i.Date != nil {
		predicates = append(predicates, visitrecord.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, visitrecord.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, visitrecord.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, visitrecord.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, visitrecord.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, visitrecord.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, visitrecord.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, visitrecord.DateLTE(*i.DateLTE))
	}
	if i.TenderID != nil {
		predicates = append(predicates, visitrecord.TenderIDEQ(*i.TenderID))
	}
	if i.TenderIDNEQ != nil {
		predicates = append(predicates, visitrecord.TenderIDNEQ(*i.TenderIDNEQ))
	}
	if len(i.TenderIDIn) > 0 {
		predicates = append(predicates, visitrecord.TenderIDIn(i.TenderIDIn...))
	}
	if len(i.TenderIDNotIn) > 0 {
		predicates = append(predicates, visitrecord.TenderIDNotIn(i.TenderIDNotIn...))
	}
	if i.TenderIDGT != nil {
		predicates = append(predicates, visitrecord.TenderIDGT(*i.TenderIDGT))
	}
	if i.TenderIDGTE != nil {
		predicates = append(predicates, visitrecord.TenderIDGTE(*i.TenderIDGTE))
	}
	if i.TenderIDLT != nil {
		predicates = append(predicates, visitrecord.TenderIDLT(*i.TenderIDLT))
	}
	if i.TenderIDLTE != nil {
		predicates = append(predicates, visitrecord.TenderIDLTE(*i.TenderIDLTE))
	}
	if i.TenderIDContains != nil {
		predicates = append(predicates, visitrecord.TenderIDContains(*i.TenderIDContains))
	}
	if i.TenderIDHasPrefix != nil {
		predicates = append(predicates, visitrecord.TenderIDHasPrefix(*i.TenderIDHasPrefix))
	}
	if i.TenderIDHasSuffix != nil {
		predicates = append(predicates, visitrecord.TenderIDHasSuffix(*i.TenderIDHasSuffix))
	}
	if i.TenderIDIsNil {
		predicates = append(predicates, visitrecord.TenderIDIsNil())
	}
	if i.TenderIDNotNil {
		predicates = append(predicates, visitrecord.TenderIDNotNil())
	}
	if i.TenderIDEqualFold != nil {
		predicates = append(predicates, visitrecord.TenderIDEqualFold(*i.TenderIDEqualFold))
	}
	if i.TenderIDContainsFold != nil {
		predicates = append(predicates, visitrecord.TenderIDContainsFold(*i.TenderIDContainsFold))
	}
	if i.CustomerID != nil {
		predicates = append(predicates, visitrecord.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, visitrecord.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, visitrecord.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, visitrecord.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDGT != nil {
		predicates = append(predicates, visitrecord.CustomerIDGT(*i.CustomerIDGT))
	}
	if i.CustomerIDGTE != nil {
		predicates = append(predicates, visitrecord.CustomerIDGTE(*i.CustomerIDGTE))
	}
	if i.CustomerIDLT != nil {
		predicates = append(predicates, visitrecord.CustomerIDLT(*i.CustomerIDLT))
	}
	if i.CustomerIDLTE != nil {
		predicates = append(predicates, visitrecord.CustomerIDLTE(*i.CustomerIDLTE))
	}
	if i.CustomerIDContains != nil {
		predicates = append(predicates, visitrecord.CustomerIDContains(*i.CustomerIDContains))
	}
	if i.CustomerIDHasPrefix != nil {
		predicates = append(predicates, visitrecord.CustomerIDHasPrefix(*i.CustomerIDHasPrefix))
	}
	if i.CustomerIDHasSuffix != nil {
		predicates = append(predicates, visitrecord.CustomerIDHasSuffix(*i.CustomerIDHasSuffix))
	}
	if i.CustomerIDIsNil {
		predicates = append(predicates, visitrecord.CustomerIDIsNil())
	}
	if i.CustomerIDNotNil {
		predicates = append(predicates, visitrecord.CustomerIDNotNil())
	}
	if i.CustomerIDEqualFold != nil {
		predicates = append(predicates, visitrecord.CustomerIDEqualFold(*i.CustomerIDEqualFold))
	}
	if i.CustomerIDContainsFold != nil {
		predicates = append(predicates, visitrecord.CustomerIDContainsFold(*i.CustomerIDContainsFold))
	}

	if i.HasTender != nil {
		p := visitrecord.HasTender()
		if !*i.HasTender {
			p = visitrecord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenderWith) > 0 {
		with := make([]predicate.Tender, 0, len(i.HasTenderWith))
		for _, w := range i.HasTenderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, visitrecord.HasTenderWith(with...))
	}
	if i.HasCustomer != nil {
		p := visitrecord.HasCustomer()
		if !*i.HasCustomer {
			p = visitrecord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasCustomerWith))
		for _, w := range i.HasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, visitrecord.HasCustomerWith(with...))
	}
	if i.HasFollowUpBys != nil {
		p := visitrecord.HasFollowUpBys()
		if !*i.HasFollowUpBys {
			p = visitrecord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFollowUpBysWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasFollowUpBysWith))
		for _, w := range i.HasFollowUpBysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFollowUpBysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, visitrecord.HasFollowUpBysWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyVisitRecordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return visitrecord.And(predicates...), nil
	}
}
