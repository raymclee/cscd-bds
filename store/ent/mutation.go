// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"cscd-bds/store/ent/area"
	"cscd-bds/store/ent/city"
	"cscd-bds/store/ent/country"
	"cscd-bds/store/ent/customer"
	"cscd-bds/store/ent/district"
	"cscd-bds/store/ent/plot"
	"cscd-bds/store/ent/predicate"
	"cscd-bds/store/ent/province"
	"cscd-bds/store/ent/schema/geo"
	"cscd-bds/store/ent/schema/xid"
	"cscd-bds/store/ent/schema/zht"
	"cscd-bds/store/ent/tender"
	"cscd-bds/store/ent/user"
	"cscd-bds/store/ent/visitrecord"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArea        = "Area"
	TypeCity        = "City"
	TypeCountry     = "Country"
	TypeCustomer    = "Customer"
	TypeDistrict    = "District"
	TypePlot        = "Plot"
	TypeProvince    = "Province"
	TypeTender      = "Tender"
	TypeUser        = "User"
	TypeVisitRecord = "VisitRecord"
)

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	code             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	customers        map[xid.ID]struct{}
	removedcustomers map[xid.ID]struct{}
	clearedcustomers bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	sales            map[xid.ID]struct{}
	removedsales     map[xid.ID]struct{}
	clearedsales     bool
	provinces        map[xid.ID]struct{}
	removedprovinces map[xid.ID]struct{}
	clearedprovinces bool
	done             bool
	oldValue         func(context.Context) (*Area, error)
	predicates       []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id xid.ID) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Area entities.
func (m *AreaMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AreaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AreaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AreaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AreaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AreaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AreaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *AreaMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AreaMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AreaMutation) ResetCode() {
	m.code = nil
}

// SetCenter sets the "center" field.
func (m *AreaMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *AreaMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *AreaMutation) ResetCenter() {
	m.center = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *AreaMutation) AddCustomerIDs(ids ...xid.ID) {
	if m.customers == nil {
		m.customers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *AreaMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *AreaMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *AreaMutation) RemoveCustomerIDs(ids ...xid.ID) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *AreaMutation) RemovedCustomersIDs() (ids []xid.ID) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *AreaMutation) CustomersIDs() (ids []xid.ID) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *AreaMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *AreaMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *AreaMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *AreaMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *AreaMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *AreaMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *AreaMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *AreaMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddSaleIDs adds the "sales" edge to the User entity by ids.
func (m *AreaMutation) AddSaleIDs(ids ...xid.ID) {
	if m.sales == nil {
		m.sales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the User entity.
func (m *AreaMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the User entity was cleared.
func (m *AreaMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the User entity by IDs.
func (m *AreaMutation) RemoveSaleIDs(ids ...xid.ID) {
	if m.removedsales == nil {
		m.removedsales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the User entity.
func (m *AreaMutation) RemovedSalesIDs() (ids []xid.ID) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *AreaMutation) SalesIDs() (ids []xid.ID) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *AreaMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// AddProvinceIDs adds the "provinces" edge to the Province entity by ids.
func (m *AreaMutation) AddProvinceIDs(ids ...xid.ID) {
	if m.provinces == nil {
		m.provinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.provinces[ids[i]] = struct{}{}
	}
}

// ClearProvinces clears the "provinces" edge to the Province entity.
func (m *AreaMutation) ClearProvinces() {
	m.clearedprovinces = true
}

// ProvincesCleared reports if the "provinces" edge to the Province entity was cleared.
func (m *AreaMutation) ProvincesCleared() bool {
	return m.clearedprovinces
}

// RemoveProvinceIDs removes the "provinces" edge to the Province entity by IDs.
func (m *AreaMutation) RemoveProvinceIDs(ids ...xid.ID) {
	if m.removedprovinces == nil {
		m.removedprovinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.provinces, ids[i])
		m.removedprovinces[ids[i]] = struct{}{}
	}
}

// RemovedProvinces returns the removed IDs of the "provinces" edge to the Province entity.
func (m *AreaMutation) RemovedProvincesIDs() (ids []xid.ID) {
	for id := range m.removedprovinces {
		ids = append(ids, id)
	}
	return
}

// ProvincesIDs returns the "provinces" edge IDs in the mutation.
func (m *AreaMutation) ProvincesIDs() (ids []xid.ID) {
	for id := range m.provinces {
		ids = append(ids, id)
	}
	return
}

// ResetProvinces resets all changes to the "provinces" edge.
func (m *AreaMutation) ResetProvinces() {
	m.provinces = nil
	m.clearedprovinces = false
	m.removedprovinces = nil
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Area, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, area.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, area.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.code != nil {
		fields = append(fields, area.FieldCode)
	}
	if m.center != nil {
		fields = append(fields, area.FieldCenter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldCreatedAt:
		return m.CreatedAt()
	case area.FieldUpdatedAt:
		return m.UpdatedAt()
	case area.FieldName:
		return m.Name()
	case area.FieldCode:
		return m.Code()
	case area.FieldCenter:
		return m.Center()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case area.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldCode:
		return m.OldCode(ctx)
	case area.FieldCenter:
		return m.OldCenter(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case area.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case area.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case area.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldCode:
		m.ResetCode()
		return nil
	case area.FieldCenter:
		m.ResetCenter()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customers != nil {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.tenders != nil {
		edges = append(edges, area.EdgeTenders)
	}
	if m.sales != nil {
		edges = append(edges, area.EdgeSales)
	}
	if m.provinces != nil {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.provinces))
		for id := range m.provinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcustomers != nil {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.removedtenders != nil {
		edges = append(edges, area.EdgeTenders)
	}
	if m.removedsales != nil {
		edges = append(edges, area.EdgeSales)
	}
	if m.removedprovinces != nil {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.removedprovinces))
		for id := range m.removedprovinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomers {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.clearedtenders {
		edges = append(edges, area.EdgeTenders)
	}
	if m.clearedsales {
		edges = append(edges, area.EdgeSales)
	}
	if m.clearedprovinces {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	switch name {
	case area.EdgeCustomers:
		return m.clearedcustomers
	case area.EdgeTenders:
		return m.clearedtenders
	case area.EdgeSales:
		return m.clearedsales
	case area.EdgeProvinces:
		return m.clearedprovinces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	switch name {
	case area.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case area.EdgeTenders:
		m.ResetTenders()
		return nil
	case area.EdgeSales:
		m.ResetSales()
		return nil
	case area.EdgeProvinces:
		m.ResetProvinces()
		return nil
	}
	return fmt.Errorf("unknown Area edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	prov_code        *int
	addprov_code     *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	districts        map[xid.ID]struct{}
	removeddistricts map[xid.ID]struct{}
	cleareddistricts bool
	province         *xid.ID
	clearedprovince  bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	done             bool
	oldValue         func(context.Context) (*City, error)
	predicates       []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id xid.ID) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *CityMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *CityMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *CityMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *CityMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *CityMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetProvCode sets the "prov_code" field.
func (m *CityMutation) SetProvCode(i int) {
	m.prov_code = &i
	m.addprov_code = nil
}

// ProvCode returns the value of the "prov_code" field in the mutation.
func (m *CityMutation) ProvCode() (r int, exists bool) {
	v := m.prov_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvCode returns the old "prov_code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldProvCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvCode: %w", err)
	}
	return oldValue.ProvCode, nil
}

// AddProvCode adds i to the "prov_code" field.
func (m *CityMutation) AddProvCode(i int) {
	if m.addprov_code != nil {
		*m.addprov_code += i
	} else {
		m.addprov_code = &i
	}
}

// AddedProvCode returns the value that was added to the "prov_code" field in this mutation.
func (m *CityMutation) AddedProvCode() (r int, exists bool) {
	v := m.addprov_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvCode resets all changes to the "prov_code" field.
func (m *CityMutation) ResetProvCode() {
	m.prov_code = nil
	m.addprov_code = nil
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *CityMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *CityMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *CityMutation) ResetCenter() {
	m.center = nil
}

// SetProvinceID sets the "province_id" field.
func (m *CityMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *CityMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldProvinceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *CityMutation) ResetProvinceID() {
	m.province = nil
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *CityMutation) AddDistrictIDs(ids ...xid.ID) {
	if m.districts == nil {
		m.districts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *CityMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *CityMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *CityMutation) RemoveDistrictIDs(ids ...xid.ID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *CityMutation) RemovedDistrictsIDs() (ids []xid.ID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *CityMutation) DistrictsIDs() (ids []xid.ID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *CityMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *CityMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[city.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *CityMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *CityMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *CityMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *CityMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *CityMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *CityMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *CityMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *CityMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *CityMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, city.FieldAdcode)
	}
	if m.prov_code != nil {
		fields = append(fields, city.FieldProvCode)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.center != nil {
		fields = append(fields, city.FieldCenter)
	}
	if m.province != nil {
		fields = append(fields, city.FieldProvinceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldAdcode:
		return m.Adcode()
	case city.FieldProvCode:
		return m.ProvCode()
	case city.FieldName:
		return m.Name()
	case city.FieldCenter:
		return m.Center()
	case city.FieldProvinceID:
		return m.ProvinceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldAdcode:
		return m.OldAdcode(ctx)
	case city.FieldProvCode:
		return m.OldProvCode(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldCenter:
		return m.OldCenter(ctx)
	case city.FieldProvinceID:
		return m.OldProvinceID(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case city.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvCode(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case city.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, city.FieldAdcode)
	}
	if m.addprov_code != nil {
		fields = append(fields, city.FieldProvCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldAdcode:
		return m.AddedAdcode()
	case city.FieldProvCode:
		return m.AddedProvCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	case city.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvCode(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldAdcode:
		m.ResetAdcode()
		return nil
	case city.FieldProvCode:
		m.ResetProvCode()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldCenter:
		m.ResetCenter()
		return nil
	case city.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.districts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.province != nil {
		edges = append(edges, city.EdgeProvince)
	}
	if m.tenders != nil {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddistricts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.removedtenders != nil {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddistricts {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.clearedprovince {
		edges = append(edges, city.EdgeProvince)
	}
	if m.clearedtenders {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeDistricts:
		return m.cleareddistricts
	case city.EdgeProvince:
		return m.clearedprovince
	case city.EdgeTenders:
		return m.clearedtenders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeProvince:
		m.ClearProvince()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case city.EdgeProvince:
		m.ResetProvince()
		return nil
	case city.EdgeTenders:
		m.ResetTenders()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	provinces        map[xid.ID]struct{}
	removedprovinces map[xid.ID]struct{}
	clearedprovinces bool
	done             bool
	oldValue         func(context.Context) (*Country, error)
	predicates       []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id xid.ID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CountryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CountryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CountryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CountryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CountryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CountryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *CountryMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *CountryMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *CountryMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *CountryMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *CountryMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *CountryMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *CountryMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *CountryMutation) ResetCenter() {
	m.center = nil
}

// AddProvinceIDs adds the "provinces" edge to the Province entity by ids.
func (m *CountryMutation) AddProvinceIDs(ids ...xid.ID) {
	if m.provinces == nil {
		m.provinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.provinces[ids[i]] = struct{}{}
	}
}

// ClearProvinces clears the "provinces" edge to the Province entity.
func (m *CountryMutation) ClearProvinces() {
	m.clearedprovinces = true
}

// ProvincesCleared reports if the "provinces" edge to the Province entity was cleared.
func (m *CountryMutation) ProvincesCleared() bool {
	return m.clearedprovinces
}

// RemoveProvinceIDs removes the "provinces" edge to the Province entity by IDs.
func (m *CountryMutation) RemoveProvinceIDs(ids ...xid.ID) {
	if m.removedprovinces == nil {
		m.removedprovinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.provinces, ids[i])
		m.removedprovinces[ids[i]] = struct{}{}
	}
}

// RemovedProvinces returns the removed IDs of the "provinces" edge to the Province entity.
func (m *CountryMutation) RemovedProvincesIDs() (ids []xid.ID) {
	for id := range m.removedprovinces {
		ids = append(ids, id)
	}
	return
}

// ProvincesIDs returns the "provinces" edge IDs in the mutation.
func (m *CountryMutation) ProvincesIDs() (ids []xid.ID) {
	for id := range m.provinces {
		ids = append(ids, id)
	}
	return
}

// ResetProvinces resets all changes to the "provinces" edge.
func (m *CountryMutation) ResetProvinces() {
	m.provinces = nil
	m.clearedprovinces = false
	m.removedprovinces = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, country.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, country.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, country.FieldAdcode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.center != nil {
		fields = append(fields, country.FieldCenter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCreatedAt:
		return m.CreatedAt()
	case country.FieldUpdatedAt:
		return m.UpdatedAt()
	case country.FieldAdcode:
		return m.Adcode()
	case country.FieldName:
		return m.Name()
	case country.FieldCenter:
		return m.Center()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case country.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case country.FieldAdcode:
		return m.OldAdcode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldCenter:
		return m.OldCenter(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case country.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case country.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, country.FieldAdcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country.FieldAdcode:
		return m.AddedAdcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case country.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case country.FieldAdcode:
		m.ResetAdcode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldCenter:
		m.ResetCenter()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.provinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.provinces))
		for id := range m.provinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprovinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.removedprovinces))
		for id := range m.removedprovinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprovinces {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeProvinces:
		return m.clearedprovinces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeProvinces:
		m.ResetProvinces()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *xid.ID
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	owner_type              *int
	addowner_type           *int
	industry                *int
	addindustry             *int
	size                    *int
	addsize                 *int
	contact_person          *string
	contact_person_position *string
	contact_person_phone    *string
	contact_person_email    *string
	feishu_group            **zht.Group
	clearedFields           map[string]struct{}
	area                    *xid.ID
	clearedarea             bool
	tenders                 map[xid.ID]struct{}
	removedtenders          map[xid.ID]struct{}
	clearedtenders          bool
	sales                   *xid.ID
	clearedsales            bool
	created_by              *xid.ID
	clearedcreated_by       bool
	visit_records           map[xid.ID]struct{}
	removedvisit_records    map[xid.ID]struct{}
	clearedvisit_records    bool
	done                    bool
	oldValue                func(context.Context) (*Customer, error)
	predicates              []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id xid.ID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *CustomerMutation) SetOwnerType(i int) {
	m.owner_type = &i
	m.addowner_type = nil
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *CustomerMutation) OwnerType() (r int, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOwnerType(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// AddOwnerType adds i to the "owner_type" field.
func (m *CustomerMutation) AddOwnerType(i int) {
	if m.addowner_type != nil {
		*m.addowner_type += i
	} else {
		m.addowner_type = &i
	}
}

// AddedOwnerType returns the value that was added to the "owner_type" field in this mutation.
func (m *CustomerMutation) AddedOwnerType() (r int, exists bool) {
	v := m.addowner_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerType clears the value of the "owner_type" field.
func (m *CustomerMutation) ClearOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	m.clearedFields[customer.FieldOwnerType] = struct{}{}
}

// OwnerTypeCleared returns if the "owner_type" field was cleared in this mutation.
func (m *CustomerMutation) OwnerTypeCleared() bool {
	_, ok := m.clearedFields[customer.FieldOwnerType]
	return ok
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *CustomerMutation) ResetOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	delete(m.clearedFields, customer.FieldOwnerType)
}

// SetIndustry sets the "industry" field.
func (m *CustomerMutation) SetIndustry(i int) {
	m.industry = &i
	m.addindustry = nil
}

// Industry returns the value of the "industry" field in the mutation.
func (m *CustomerMutation) Industry() (r int, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIndustry(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// AddIndustry adds i to the "industry" field.
func (m *CustomerMutation) AddIndustry(i int) {
	if m.addindustry != nil {
		*m.addindustry += i
	} else {
		m.addindustry = &i
	}
}

// AddedIndustry returns the value that was added to the "industry" field in this mutation.
func (m *CustomerMutation) AddedIndustry() (r int, exists bool) {
	v := m.addindustry
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndustry resets all changes to the "industry" field.
func (m *CustomerMutation) ResetIndustry() {
	m.industry = nil
	m.addindustry = nil
}

// SetSize sets the "size" field.
func (m *CustomerMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CustomerMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldSize(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CustomerMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CustomerMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *CustomerMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[customer.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *CustomerMutation) SizeCleared() bool {
	_, ok := m.clearedFields[customer.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *CustomerMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, customer.FieldSize)
}

// SetContactPerson sets the "contact_person" field.
func (m *CustomerMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *CustomerMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPerson(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *CustomerMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[customer.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *CustomerMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, customer.FieldContactPerson)
}

// SetContactPersonPosition sets the "contact_person_position" field.
func (m *CustomerMutation) SetContactPersonPosition(s string) {
	m.contact_person_position = &s
}

// ContactPersonPosition returns the value of the "contact_person_position" field in the mutation.
func (m *CustomerMutation) ContactPersonPosition() (r string, exists bool) {
	v := m.contact_person_position
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPosition returns the old "contact_person_position" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPosition: %w", err)
	}
	return oldValue.ContactPersonPosition, nil
}

// ClearContactPersonPosition clears the value of the "contact_person_position" field.
func (m *CustomerMutation) ClearContactPersonPosition() {
	m.contact_person_position = nil
	m.clearedFields[customer.FieldContactPersonPosition] = struct{}{}
}

// ContactPersonPositionCleared returns if the "contact_person_position" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonPositionCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonPosition]
	return ok
}

// ResetContactPersonPosition resets all changes to the "contact_person_position" field.
func (m *CustomerMutation) ResetContactPersonPosition() {
	m.contact_person_position = nil
	delete(m.clearedFields, customer.FieldContactPersonPosition)
}

// SetContactPersonPhone sets the "contact_person_phone" field.
func (m *CustomerMutation) SetContactPersonPhone(s string) {
	m.contact_person_phone = &s
}

// ContactPersonPhone returns the value of the "contact_person_phone" field in the mutation.
func (m *CustomerMutation) ContactPersonPhone() (r string, exists bool) {
	v := m.contact_person_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPhone returns the old "contact_person_phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPhone: %w", err)
	}
	return oldValue.ContactPersonPhone, nil
}

// ClearContactPersonPhone clears the value of the "contact_person_phone" field.
func (m *CustomerMutation) ClearContactPersonPhone() {
	m.contact_person_phone = nil
	m.clearedFields[customer.FieldContactPersonPhone] = struct{}{}
}

// ContactPersonPhoneCleared returns if the "contact_person_phone" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonPhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonPhone]
	return ok
}

// ResetContactPersonPhone resets all changes to the "contact_person_phone" field.
func (m *CustomerMutation) ResetContactPersonPhone() {
	m.contact_person_phone = nil
	delete(m.clearedFields, customer.FieldContactPersonPhone)
}

// SetContactPersonEmail sets the "contact_person_email" field.
func (m *CustomerMutation) SetContactPersonEmail(s string) {
	m.contact_person_email = &s
}

// ContactPersonEmail returns the value of the "contact_person_email" field in the mutation.
func (m *CustomerMutation) ContactPersonEmail() (r string, exists bool) {
	v := m.contact_person_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonEmail returns the old "contact_person_email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonEmail: %w", err)
	}
	return oldValue.ContactPersonEmail, nil
}

// ClearContactPersonEmail clears the value of the "contact_person_email" field.
func (m *CustomerMutation) ClearContactPersonEmail() {
	m.contact_person_email = nil
	m.clearedFields[customer.FieldContactPersonEmail] = struct{}{}
}

// ContactPersonEmailCleared returns if the "contact_person_email" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonEmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonEmail]
	return ok
}

// ResetContactPersonEmail resets all changes to the "contact_person_email" field.
func (m *CustomerMutation) ResetContactPersonEmail() {
	m.contact_person_email = nil
	delete(m.clearedFields, customer.FieldContactPersonEmail)
}

// SetFeishuGroup sets the "feishu_group" field.
func (m *CustomerMutation) SetFeishuGroup(z *zht.Group) {
	m.feishu_group = &z
}

// FeishuGroup returns the value of the "feishu_group" field in the mutation.
func (m *CustomerMutation) FeishuGroup() (r *zht.Group, exists bool) {
	v := m.feishu_group
	if v == nil {
		return
	}
	return *v, true
}

// OldFeishuGroup returns the old "feishu_group" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFeishuGroup(ctx context.Context) (v *zht.Group, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeishuGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeishuGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeishuGroup: %w", err)
	}
	return oldValue.FeishuGroup, nil
}

// ClearFeishuGroup clears the value of the "feishu_group" field.
func (m *CustomerMutation) ClearFeishuGroup() {
	m.feishu_group = nil
	m.clearedFields[customer.FieldFeishuGroup] = struct{}{}
}

// FeishuGroupCleared returns if the "feishu_group" field was cleared in this mutation.
func (m *CustomerMutation) FeishuGroupCleared() bool {
	_, ok := m.clearedFields[customer.FieldFeishuGroup]
	return ok
}

// ResetFeishuGroup resets all changes to the "feishu_group" field.
func (m *CustomerMutation) ResetFeishuGroup() {
	m.feishu_group = nil
	delete(m.clearedFields, customer.FieldFeishuGroup)
}

// SetAreaID sets the "area_id" field.
func (m *CustomerMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *CustomerMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAreaID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *CustomerMutation) ResetAreaID() {
	m.area = nil
}

// SetSalesID sets the "sales_id" field.
func (m *CustomerMutation) SetSalesID(x xid.ID) {
	m.sales = &x
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *CustomerMutation) SalesID() (r xid.ID, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldSalesID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *CustomerMutation) ClearSalesID() {
	m.sales = nil
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *CustomerMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *CustomerMutation) ResetSalesID() {
	m.sales = nil
	delete(m.clearedFields, customer.FieldSalesID)
}

// SetCreatedByID sets the "created_by_id" field.
func (m *CustomerMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *CustomerMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedByID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *CustomerMutation) ResetCreatedByID() {
	m.created_by = nil
}

// ClearArea clears the "area" edge to the Area entity.
func (m *CustomerMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[customer.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *CustomerMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *CustomerMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *CustomerMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *CustomerMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *CustomerMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *CustomerMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *CustomerMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *CustomerMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *CustomerMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// ClearSales clears the "sales" edge to the User entity.
func (m *CustomerMutation) ClearSales() {
	m.clearedsales = true
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesCleared reports if the "sales" edge to the User entity was cleared.
func (m *CustomerMutation) SalesCleared() bool {
	return m.SalesIDCleared() || m.clearedsales
}

// SalesIDs returns the "sales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) SalesIDs() (ids []xid.ID) {
	if id := m.sales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *CustomerMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *CustomerMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[customer.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *CustomerMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *CustomerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *CustomerMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *CustomerMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *CustomerMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *CustomerMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *CustomerMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *CustomerMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *CustomerMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.owner_type != nil {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.industry != nil {
		fields = append(fields, customer.FieldIndustry)
	}
	if m.size != nil {
		fields = append(fields, customer.FieldSize)
	}
	if m.contact_person != nil {
		fields = append(fields, customer.FieldContactPerson)
	}
	if m.contact_person_position != nil {
		fields = append(fields, customer.FieldContactPersonPosition)
	}
	if m.contact_person_phone != nil {
		fields = append(fields, customer.FieldContactPersonPhone)
	}
	if m.contact_person_email != nil {
		fields = append(fields, customer.FieldContactPersonEmail)
	}
	if m.feishu_group != nil {
		fields = append(fields, customer.FieldFeishuGroup)
	}
	if m.area != nil {
		fields = append(fields, customer.FieldAreaID)
	}
	if m.sales != nil {
		fields = append(fields, customer.FieldSalesID)
	}
	if m.created_by != nil {
		fields = append(fields, customer.FieldCreatedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldName:
		return m.Name()
	case customer.FieldOwnerType:
		return m.OwnerType()
	case customer.FieldIndustry:
		return m.Industry()
	case customer.FieldSize:
		return m.Size()
	case customer.FieldContactPerson:
		return m.ContactPerson()
	case customer.FieldContactPersonPosition:
		return m.ContactPersonPosition()
	case customer.FieldContactPersonPhone:
		return m.ContactPersonPhone()
	case customer.FieldContactPersonEmail:
		return m.ContactPersonEmail()
	case customer.FieldFeishuGroup:
		return m.FeishuGroup()
	case customer.FieldAreaID:
		return m.AreaID()
	case customer.FieldSalesID:
		return m.SalesID()
	case customer.FieldCreatedByID:
		return m.CreatedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case customer.FieldIndustry:
		return m.OldIndustry(ctx)
	case customer.FieldSize:
		return m.OldSize(ctx)
	case customer.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case customer.FieldContactPersonPosition:
		return m.OldContactPersonPosition(ctx)
	case customer.FieldContactPersonPhone:
		return m.OldContactPersonPhone(ctx)
	case customer.FieldContactPersonEmail:
		return m.OldContactPersonEmail(ctx)
	case customer.FieldFeishuGroup:
		return m.OldFeishuGroup(ctx)
	case customer.FieldAreaID:
		return m.OldAreaID(ctx)
	case customer.FieldSalesID:
		return m.OldSalesID(ctx)
	case customer.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case customer.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case customer.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case customer.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case customer.FieldContactPersonPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPosition(v)
		return nil
	case customer.FieldContactPersonPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPhone(v)
		return nil
	case customer.FieldContactPersonEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonEmail(v)
		return nil
	case customer.FieldFeishuGroup:
		v, ok := value.(*zht.Group)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeishuGroup(v)
		return nil
	case customer.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case customer.FieldSalesID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case customer.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	if m.addowner_type != nil {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.addindustry != nil {
		fields = append(fields, customer.FieldIndustry)
	}
	if m.addsize != nil {
		fields = append(fields, customer.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldOwnerType:
		return m.AddedOwnerType()
	case customer.FieldIndustry:
		return m.AddedIndustry()
	case customer.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customer.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerType(v)
		return nil
	case customer.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndustry(v)
		return nil
	case customer.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldOwnerType) {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.FieldCleared(customer.FieldSize) {
		fields = append(fields, customer.FieldSize)
	}
	if m.FieldCleared(customer.FieldContactPerson) {
		fields = append(fields, customer.FieldContactPerson)
	}
	if m.FieldCleared(customer.FieldContactPersonPosition) {
		fields = append(fields, customer.FieldContactPersonPosition)
	}
	if m.FieldCleared(customer.FieldContactPersonPhone) {
		fields = append(fields, customer.FieldContactPersonPhone)
	}
	if m.FieldCleared(customer.FieldContactPersonEmail) {
		fields = append(fields, customer.FieldContactPersonEmail)
	}
	if m.FieldCleared(customer.FieldFeishuGroup) {
		fields = append(fields, customer.FieldFeishuGroup)
	}
	if m.FieldCleared(customer.FieldSalesID) {
		fields = append(fields, customer.FieldSalesID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldOwnerType:
		m.ClearOwnerType()
		return nil
	case customer.FieldSize:
		m.ClearSize()
		return nil
	case customer.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case customer.FieldContactPersonPosition:
		m.ClearContactPersonPosition()
		return nil
	case customer.FieldContactPersonPhone:
		m.ClearContactPersonPhone()
		return nil
	case customer.FieldContactPersonEmail:
		m.ClearContactPersonEmail()
		return nil
	case customer.FieldFeishuGroup:
		m.ClearFeishuGroup()
		return nil
	case customer.FieldSalesID:
		m.ClearSalesID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case customer.FieldIndustry:
		m.ResetIndustry()
		return nil
	case customer.FieldSize:
		m.ResetSize()
		return nil
	case customer.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case customer.FieldContactPersonPosition:
		m.ResetContactPersonPosition()
		return nil
	case customer.FieldContactPersonPhone:
		m.ResetContactPersonPhone()
		return nil
	case customer.FieldContactPersonEmail:
		m.ResetContactPersonEmail()
		return nil
	case customer.FieldFeishuGroup:
		m.ResetFeishuGroup()
		return nil
	case customer.FieldAreaID:
		m.ResetAreaID()
		return nil
	case customer.FieldSalesID:
		m.ResetSalesID()
		return nil
	case customer.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.area != nil {
		edges = append(edges, customer.EdgeArea)
	}
	if m.tenders != nil {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.sales != nil {
		edges = append(edges, customer.EdgeSales)
	}
	if m.created_by != nil {
		edges = append(edges, customer.EdgeCreatedBy)
	}
	if m.visit_records != nil {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSales:
		if id := m.sales; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtenders != nil {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedarea {
		edges = append(edges, customer.EdgeArea)
	}
	if m.clearedtenders {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.clearedsales {
		edges = append(edges, customer.EdgeSales)
	}
	if m.clearedcreated_by {
		edges = append(edges, customer.EdgeCreatedBy)
	}
	if m.clearedvisit_records {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeArea:
		return m.clearedarea
	case customer.EdgeTenders:
		return m.clearedtenders
	case customer.EdgeSales:
		return m.clearedsales
	case customer.EdgeCreatedBy:
		return m.clearedcreated_by
	case customer.EdgeVisitRecords:
		return m.clearedvisit_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeArea:
		m.ClearArea()
		return nil
	case customer.EdgeSales:
		m.ClearSales()
		return nil
	case customer.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeArea:
		m.ResetArea()
		return nil
	case customer.EdgeTenders:
		m.ResetTenders()
		return nil
	case customer.EdgeSales:
		m.ResetSales()
		return nil
	case customer.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case customer.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	updated_at      *time.Time
	adcode          *int
	addadcode       *int
	prov_code       *int
	addprov_code    *int
	city_code       *int
	addcity_code    *int
	name            *string
	center          **geo.GeoJson
	clearedFields   map[string]struct{}
	province        *xid.ID
	clearedprovince bool
	city            *xid.ID
	clearedcity     bool
	tenders         map[xid.ID]struct{}
	removedtenders  map[xid.ID]struct{}
	clearedtenders  bool
	plots           map[xid.ID]struct{}
	removedplots    map[xid.ID]struct{}
	clearedplots    bool
	done            bool
	oldValue        func(context.Context) (*District, error)
	predicates      []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id xid.ID) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of District entities.
func (m *DistrictMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DistrictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DistrictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DistrictMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DistrictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DistrictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DistrictMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *DistrictMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *DistrictMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *DistrictMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *DistrictMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *DistrictMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetProvCode sets the "prov_code" field.
func (m *DistrictMutation) SetProvCode(i int) {
	m.prov_code = &i
	m.addprov_code = nil
}

// ProvCode returns the value of the "prov_code" field in the mutation.
func (m *DistrictMutation) ProvCode() (r int, exists bool) {
	v := m.prov_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvCode returns the old "prov_code" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldProvCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvCode: %w", err)
	}
	return oldValue.ProvCode, nil
}

// AddProvCode adds i to the "prov_code" field.
func (m *DistrictMutation) AddProvCode(i int) {
	if m.addprov_code != nil {
		*m.addprov_code += i
	} else {
		m.addprov_code = &i
	}
}

// AddedProvCode returns the value that was added to the "prov_code" field in this mutation.
func (m *DistrictMutation) AddedProvCode() (r int, exists bool) {
	v := m.addprov_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvCode resets all changes to the "prov_code" field.
func (m *DistrictMutation) ResetProvCode() {
	m.prov_code = nil
	m.addprov_code = nil
}

// SetCityCode sets the "city_code" field.
func (m *DistrictMutation) SetCityCode(i int) {
	m.city_code = &i
	m.addcity_code = nil
}

// CityCode returns the value of the "city_code" field in the mutation.
func (m *DistrictMutation) CityCode() (r int, exists bool) {
	v := m.city_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCityCode returns the old "city_code" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCityCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityCode: %w", err)
	}
	return oldValue.CityCode, nil
}

// AddCityCode adds i to the "city_code" field.
func (m *DistrictMutation) AddCityCode(i int) {
	if m.addcity_code != nil {
		*m.addcity_code += i
	} else {
		m.addcity_code = &i
	}
}

// AddedCityCode returns the value that was added to the "city_code" field in this mutation.
func (m *DistrictMutation) AddedCityCode() (r int, exists bool) {
	v := m.addcity_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetCityCode resets all changes to the "city_code" field.
func (m *DistrictMutation) ResetCityCode() {
	m.city_code = nil
	m.addcity_code = nil
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *DistrictMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *DistrictMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *DistrictMutation) ResetCenter() {
	m.center = nil
}

// SetProvinceID sets the "province_id" field.
func (m *DistrictMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *DistrictMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldProvinceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *DistrictMutation) ResetProvinceID() {
	m.province = nil
}

// SetCityID sets the "city_id" field.
func (m *DistrictMutation) SetCityID(x xid.ID) {
	m.city = &x
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *DistrictMutation) CityID() (r xid.ID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCityID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *DistrictMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[district.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *DistrictMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[district.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *DistrictMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, district.FieldCityID)
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *DistrictMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[district.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *DistrictMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *DistrictMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *DistrictMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[district.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *DistrictMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) CityIDs() (ids []xid.ID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *DistrictMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *DistrictMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *DistrictMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *DistrictMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *DistrictMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *DistrictMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *DistrictMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *DistrictMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddPlotIDs adds the "plots" edge to the Plot entity by ids.
func (m *DistrictMutation) AddPlotIDs(ids ...xid.ID) {
	if m.plots == nil {
		m.plots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.plots[ids[i]] = struct{}{}
	}
}

// ClearPlots clears the "plots" edge to the Plot entity.
func (m *DistrictMutation) ClearPlots() {
	m.clearedplots = true
}

// PlotsCleared reports if the "plots" edge to the Plot entity was cleared.
func (m *DistrictMutation) PlotsCleared() bool {
	return m.clearedplots
}

// RemovePlotIDs removes the "plots" edge to the Plot entity by IDs.
func (m *DistrictMutation) RemovePlotIDs(ids ...xid.ID) {
	if m.removedplots == nil {
		m.removedplots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.plots, ids[i])
		m.removedplots[ids[i]] = struct{}{}
	}
}

// RemovedPlots returns the removed IDs of the "plots" edge to the Plot entity.
func (m *DistrictMutation) RemovedPlotsIDs() (ids []xid.ID) {
	for id := range m.removedplots {
		ids = append(ids, id)
	}
	return
}

// PlotsIDs returns the "plots" edge IDs in the mutation.
func (m *DistrictMutation) PlotsIDs() (ids []xid.ID) {
	for id := range m.plots {
		ids = append(ids, id)
	}
	return
}

// ResetPlots resets all changes to the "plots" edge.
func (m *DistrictMutation) ResetPlots() {
	m.plots = nil
	m.clearedplots = false
	m.removedplots = nil
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, district.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, district.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, district.FieldAdcode)
	}
	if m.prov_code != nil {
		fields = append(fields, district.FieldProvCode)
	}
	if m.city_code != nil {
		fields = append(fields, district.FieldCityCode)
	}
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	if m.center != nil {
		fields = append(fields, district.FieldCenter)
	}
	if m.province != nil {
		fields = append(fields, district.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, district.FieldCityID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldCreatedAt:
		return m.CreatedAt()
	case district.FieldUpdatedAt:
		return m.UpdatedAt()
	case district.FieldAdcode:
		return m.Adcode()
	case district.FieldProvCode:
		return m.ProvCode()
	case district.FieldCityCode:
		return m.CityCode()
	case district.FieldName:
		return m.Name()
	case district.FieldCenter:
		return m.Center()
	case district.FieldProvinceID:
		return m.ProvinceID()
	case district.FieldCityID:
		return m.CityID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case district.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case district.FieldAdcode:
		return m.OldAdcode(ctx)
	case district.FieldProvCode:
		return m.OldProvCode(ctx)
	case district.FieldCityCode:
		return m.OldCityCode(ctx)
	case district.FieldName:
		return m.OldName(ctx)
	case district.FieldCenter:
		return m.OldCenter(ctx)
	case district.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case district.FieldCityID:
		return m.OldCityID(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case district.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case district.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case district.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvCode(v)
		return nil
	case district.FieldCityCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityCode(v)
		return nil
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case district.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case district.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case district.FieldCityID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, district.FieldAdcode)
	}
	if m.addprov_code != nil {
		fields = append(fields, district.FieldProvCode)
	}
	if m.addcity_code != nil {
		fields = append(fields, district.FieldCityCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case district.FieldAdcode:
		return m.AddedAdcode()
	case district.FieldProvCode:
		return m.AddedProvCode()
	case district.FieldCityCode:
		return m.AddedCityCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case district.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	case district.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvCode(v)
		return nil
	case district.FieldCityCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCityCode(v)
		return nil
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(district.FieldCityID) {
		fields = append(fields, district.FieldCityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	switch name {
	case district.FieldCityID:
		m.ClearCityID()
		return nil
	}
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case district.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case district.FieldAdcode:
		m.ResetAdcode()
		return nil
	case district.FieldProvCode:
		m.ResetProvCode()
		return nil
	case district.FieldCityCode:
		m.ResetCityCode()
		return nil
	case district.FieldName:
		m.ResetName()
		return nil
	case district.FieldCenter:
		m.ResetCenter()
		return nil
	case district.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case district.FieldCityID:
		m.ResetCityID()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.province != nil {
		edges = append(edges, district.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, district.EdgeCity)
	}
	if m.tenders != nil {
		edges = append(edges, district.EdgeTenders)
	}
	if m.plots != nil {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case district.EdgePlots:
		ids := make([]ent.Value, 0, len(m.plots))
		for id := range m.plots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtenders != nil {
		edges = append(edges, district.EdgeTenders)
	}
	if m.removedplots != nil {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case district.EdgePlots:
		ids := make([]ent.Value, 0, len(m.removedplots))
		for id := range m.removedplots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprovince {
		edges = append(edges, district.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, district.EdgeCity)
	}
	if m.clearedtenders {
		edges = append(edges, district.EdgeTenders)
	}
	if m.clearedplots {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeProvince:
		return m.clearedprovince
	case district.EdgeCity:
		return m.clearedcity
	case district.EdgeTenders:
		return m.clearedtenders
	case district.EdgePlots:
		return m.clearedplots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeProvince:
		m.ClearProvince()
		return nil
	case district.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeProvince:
		m.ResetProvince()
		return nil
	case district.EdgeCity:
		m.ResetCity()
		return nil
	case district.EdgeTenders:
		m.ResetTenders()
		return nil
	case district.EdgePlots:
		m.ResetPlots()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// PlotMutation represents an operation that mutates the Plot nodes in the graph.
type PlotMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	color_hex        *string
	geo_bounds       *[][]float64
	appendgeo_bounds [][]float64
	clearedFields    map[string]struct{}
	district         *xid.ID
	cleareddistrict  bool
	done             bool
	oldValue         func(context.Context) (*Plot, error)
	predicates       []predicate.Plot
}

var _ ent.Mutation = (*PlotMutation)(nil)

// plotOption allows management of the mutation configuration using functional options.
type plotOption func(*PlotMutation)

// newPlotMutation creates new mutation for the Plot entity.
func newPlotMutation(c config, op Op, opts ...plotOption) *PlotMutation {
	m := &PlotMutation{
		config:        c,
		op:            op,
		typ:           TypePlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlotID sets the ID field of the mutation.
func withPlotID(id xid.ID) plotOption {
	return func(m *PlotMutation) {
		var (
			err   error
			once  sync.Once
			value *Plot
		)
		m.oldValue = func(ctx context.Context) (*Plot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlot sets the old Plot of the mutation.
func withPlot(node *Plot) plotOption {
	return func(m *PlotMutation) {
		m.oldValue = func(context.Context) (*Plot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plot entities.
func (m *PlotMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlotMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlotMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PlotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlotMutation) ResetName() {
	m.name = nil
}

// SetColorHex sets the "color_hex" field.
func (m *PlotMutation) SetColorHex(s string) {
	m.color_hex = &s
}

// ColorHex returns the value of the "color_hex" field in the mutation.
func (m *PlotMutation) ColorHex() (r string, exists bool) {
	v := m.color_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldColorHex returns the old "color_hex" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldColorHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorHex: %w", err)
	}
	return oldValue.ColorHex, nil
}

// ResetColorHex resets all changes to the "color_hex" field.
func (m *PlotMutation) ResetColorHex() {
	m.color_hex = nil
}

// SetGeoBounds sets the "geo_bounds" field.
func (m *PlotMutation) SetGeoBounds(f [][]float64) {
	m.geo_bounds = &f
	m.appendgeo_bounds = nil
}

// GeoBounds returns the value of the "geo_bounds" field in the mutation.
func (m *PlotMutation) GeoBounds() (r [][]float64, exists bool) {
	v := m.geo_bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoBounds returns the old "geo_bounds" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldGeoBounds(ctx context.Context) (v [][]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoBounds: %w", err)
	}
	return oldValue.GeoBounds, nil
}

// AppendGeoBounds adds f to the "geo_bounds" field.
func (m *PlotMutation) AppendGeoBounds(f [][]float64) {
	m.appendgeo_bounds = append(m.appendgeo_bounds, f...)
}

// AppendedGeoBounds returns the list of values that were appended to the "geo_bounds" field in this mutation.
func (m *PlotMutation) AppendedGeoBounds() ([][]float64, bool) {
	if len(m.appendgeo_bounds) == 0 {
		return nil, false
	}
	return m.appendgeo_bounds, true
}

// ClearGeoBounds clears the value of the "geo_bounds" field.
func (m *PlotMutation) ClearGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	m.clearedFields[plot.FieldGeoBounds] = struct{}{}
}

// GeoBoundsCleared returns if the "geo_bounds" field was cleared in this mutation.
func (m *PlotMutation) GeoBoundsCleared() bool {
	_, ok := m.clearedFields[plot.FieldGeoBounds]
	return ok
}

// ResetGeoBounds resets all changes to the "geo_bounds" field.
func (m *PlotMutation) ResetGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	delete(m.clearedFields, plot.FieldGeoBounds)
}

// SetDistrictID sets the "district_id" field.
func (m *PlotMutation) SetDistrictID(x xid.ID) {
	m.district = &x
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *PlotMutation) DistrictID() (r xid.ID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldDistrictID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *PlotMutation) ResetDistrictID() {
	m.district = nil
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *PlotMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[plot.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *PlotMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *PlotMutation) DistrictIDs() (ids []xid.ID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *PlotMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Where appends a list predicates to the PlotMutation builder.
func (m *PlotMutation) Where(ps ...predicate.Plot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plot).
func (m *PlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, plot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plot.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, plot.FieldName)
	}
	if m.color_hex != nil {
		fields = append(fields, plot.FieldColorHex)
	}
	if m.geo_bounds != nil {
		fields = append(fields, plot.FieldGeoBounds)
	}
	if m.district != nil {
		fields = append(fields, plot.FieldDistrictID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plot.FieldCreatedAt:
		return m.CreatedAt()
	case plot.FieldUpdatedAt:
		return m.UpdatedAt()
	case plot.FieldName:
		return m.Name()
	case plot.FieldColorHex:
		return m.ColorHex()
	case plot.FieldGeoBounds:
		return m.GeoBounds()
	case plot.FieldDistrictID:
		return m.DistrictID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plot.FieldName:
		return m.OldName(ctx)
	case plot.FieldColorHex:
		return m.OldColorHex(ctx)
	case plot.FieldGeoBounds:
		return m.OldGeoBounds(ctx)
	case plot.FieldDistrictID:
		return m.OldDistrictID(ctx)
	}
	return nil, fmt.Errorf("unknown Plot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plot.FieldColorHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorHex(v)
		return nil
	case plot.FieldGeoBounds:
		v, ok := value.([][]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoBounds(v)
		return nil
	case plot.FieldDistrictID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	}
	return fmt.Errorf("unknown Plot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Plot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plot.FieldGeoBounds) {
		fields = append(fields, plot.FieldGeoBounds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlotMutation) ClearField(name string) error {
	switch name {
	case plot.FieldGeoBounds:
		m.ClearGeoBounds()
		return nil
	}
	return fmt.Errorf("unknown Plot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlotMutation) ResetField(name string) error {
	switch name {
	case plot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plot.FieldName:
		m.ResetName()
		return nil
	case plot.FieldColorHex:
		m.ResetColorHex()
		return nil
	case plot.FieldGeoBounds:
		m.ResetGeoBounds()
		return nil
	case plot.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	}
	return fmt.Errorf("unknown Plot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.district != nil {
		edges = append(edges, plot.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plot.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddistrict {
		edges = append(edges, plot.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlotMutation) EdgeCleared(name string) bool {
	switch name {
	case plot.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlotMutation) ClearEdge(name string) error {
	switch name {
	case plot.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Plot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlotMutation) ResetEdge(name string) error {
	switch name {
	case plot.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Plot edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	districts        map[xid.ID]struct{}
	removeddistricts map[xid.ID]struct{}
	cleareddistricts bool
	cities           map[xid.ID]struct{}
	removedcities    map[xid.ID]struct{}
	clearedcities    bool
	country          *xid.ID
	clearedcountry   bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	area             *xid.ID
	clearedarea      bool
	done             bool
	oldValue         func(context.Context) (*Province, error)
	predicates       []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id xid.ID) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Province entities.
func (m *ProvinceMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvinceMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvinceMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Province.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProvinceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProvinceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProvinceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProvinceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProvinceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProvinceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *ProvinceMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *ProvinceMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *ProvinceMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *ProvinceMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *ProvinceMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *ProvinceMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *ProvinceMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *ProvinceMutation) ResetCenter() {
	m.center = nil
}

// SetCountryID sets the "country_id" field.
func (m *ProvinceMutation) SetCountryID(x xid.ID) {
	m.country = &x
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *ProvinceMutation) CountryID() (r xid.ID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCountryID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *ProvinceMutation) ResetCountryID() {
	m.country = nil
}

// SetAreaID sets the "area_id" field.
func (m *ProvinceMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *ProvinceMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldAreaID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ClearAreaID clears the value of the "area_id" field.
func (m *ProvinceMutation) ClearAreaID() {
	m.area = nil
	m.clearedFields[province.FieldAreaID] = struct{}{}
}

// AreaIDCleared returns if the "area_id" field was cleared in this mutation.
func (m *ProvinceMutation) AreaIDCleared() bool {
	_, ok := m.clearedFields[province.FieldAreaID]
	return ok
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *ProvinceMutation) ResetAreaID() {
	m.area = nil
	delete(m.clearedFields, province.FieldAreaID)
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *ProvinceMutation) AddDistrictIDs(ids ...xid.ID) {
	if m.districts == nil {
		m.districts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *ProvinceMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *ProvinceMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *ProvinceMutation) RemoveDistrictIDs(ids ...xid.ID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *ProvinceMutation) RemovedDistrictsIDs() (ids []xid.ID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *ProvinceMutation) DistrictsIDs() (ids []xid.ID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *ProvinceMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *ProvinceMutation) AddCityIDs(ids ...xid.ID) {
	if m.cities == nil {
		m.cities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *ProvinceMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *ProvinceMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *ProvinceMutation) RemoveCityIDs(ids ...xid.ID) {
	if m.removedcities == nil {
		m.removedcities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *ProvinceMutation) RemovedCitiesIDs() (ids []xid.ID) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *ProvinceMutation) CitiesIDs() (ids []xid.ID) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *ProvinceMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ProvinceMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[province.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ProvinceMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) CountryIDs() (ids []xid.ID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ProvinceMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *ProvinceMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *ProvinceMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *ProvinceMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *ProvinceMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *ProvinceMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *ProvinceMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *ProvinceMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// ClearArea clears the "area" edge to the Area entity.
func (m *ProvinceMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[province.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *ProvinceMutation) AreaCleared() bool {
	return m.AreaIDCleared() || m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *ProvinceMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// Where appends a list predicates to the ProvinceMutation builder.
func (m *ProvinceMutation) Where(ps ...predicate.Province) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvinceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvinceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Province, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvinceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, province.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, province.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, province.FieldAdcode)
	}
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	if m.center != nil {
		fields = append(fields, province.FieldCenter)
	}
	if m.country != nil {
		fields = append(fields, province.FieldCountryID)
	}
	if m.area != nil {
		fields = append(fields, province.FieldAreaID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldCreatedAt:
		return m.CreatedAt()
	case province.FieldUpdatedAt:
		return m.UpdatedAt()
	case province.FieldAdcode:
		return m.Adcode()
	case province.FieldName:
		return m.Name()
	case province.FieldCenter:
		return m.Center()
	case province.FieldCountryID:
		return m.CountryID()
	case province.FieldAreaID:
		return m.AreaID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case province.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case province.FieldAdcode:
		return m.OldAdcode(ctx)
	case province.FieldName:
		return m.OldName(ctx)
	case province.FieldCenter:
		return m.OldCenter(ctx)
	case province.FieldCountryID:
		return m.OldCountryID(ctx)
	case province.FieldAreaID:
		return m.OldAreaID(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case province.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case province.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case province.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case province.FieldCountryID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case province.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, province.FieldAdcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case province.FieldAdcode:
		return m.AddedAdcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case province.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(province.FieldAreaID) {
		fields = append(fields, province.FieldAreaID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	switch name {
	case province.FieldAreaID:
		m.ClearAreaID()
		return nil
	}
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case province.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case province.FieldAdcode:
		m.ResetAdcode()
		return nil
	case province.FieldName:
		m.ResetName()
		return nil
	case province.FieldCenter:
		m.ResetCenter()
		return nil
	case province.FieldCountryID:
		m.ResetCountryID()
		return nil
	case province.FieldAreaID:
		m.ResetAreaID()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.districts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.cities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.country != nil {
		edges = append(edges, province.EdgeCountry)
	}
	if m.tenders != nil {
		edges = append(edges, province.EdgeTenders)
	}
	if m.area != nil {
		edges = append(edges, province.EdgeArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddistricts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.removedcities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.removedtenders != nil {
		edges = append(edges, province.EdgeTenders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddistricts {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.clearedcities {
		edges = append(edges, province.EdgeCities)
	}
	if m.clearedcountry {
		edges = append(edges, province.EdgeCountry)
	}
	if m.clearedtenders {
		edges = append(edges, province.EdgeTenders)
	}
	if m.clearedarea {
		edges = append(edges, province.EdgeArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeDistricts:
		return m.cleareddistricts
	case province.EdgeCities:
		return m.clearedcities
	case province.EdgeCountry:
		return m.clearedcountry
	case province.EdgeTenders:
		return m.clearedtenders
	case province.EdgeArea:
		return m.clearedarea
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	case province.EdgeCountry:
		m.ClearCountry()
		return nil
	case province.EdgeArea:
		m.ClearArea()
		return nil
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case province.EdgeCities:
		m.ResetCities()
		return nil
	case province.EdgeCountry:
		m.ResetCountry()
		return nil
	case province.EdgeTenders:
		m.ResetTenders()
		return nil
	case province.EdgeArea:
		m.ResetArea()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// TenderMutation represents an operation that mutates the Tender nodes in the graph.
type TenderMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *xid.ID
	created_at                              *time.Time
	updated_at                              *time.Time
	code                                    *string
	status                                  *int
	addstatus                               *int
	name                                    *string
	estimated_amount                        *float64
	addestimated_amount                     *float64
	tender_date                             *time.Time
	discovery_date                          *time.Time
	address                                 *string
	full_address                            *string
	contractor                              *string
	size_and_value_rating                   *int
	addsize_and_value_rating                *int
	size_and_value_rating_overview          *string
	credit_and_payment_rating               *int
	addcredit_and_payment_rating            *int
	credit_and_payment_rating_overview      *string
	time_limit_rating                       *int
	addtime_limit_rating                    *int
	time_limit_rating_overview              *string
	customer_relationship_rating            *int
	addcustomer_relationship_rating         *int
	customer_relationship_rating_overview   *string
	competitive_partnership_rating          *int
	addcompetitive_partnership_rating       *int
	competitive_partnership_rating_overview *string
	prepare_to_bid                          *bool
	project_code                            *string
	project_definition                      *string
	estimated_project_start_date            *time.Time
	estimated_project_end_date              *time.Time
	project_type                            *string
	attachements                            *[]string
	appendattachements                      []string
	geo_coordinate                          **geo.GeoJson
	geo_bounds                              *[][]float64
	appendgeo_bounds                        [][]float64
	remark                                  *string
	images                                  *[]string
	appendimages                            []string
	tender_situations                       *string
	owner_situations                        *string
	bidding_instructions                    *string
	competitor_situations                   *string
	cost_engineer                           *string
	tender_form                             *string
	contract_form                           *string
	management_company                      *string
	tendering_agency                        *string
	bidding_date                            *time.Time
	facade_consultant                       *string
	design_unit                             *string
	consulting_firm                         *string
	key_project                             *bool
	tender_code                             *string
	architect                               *string
	tender_closing_date                     *string
	construction_area                       *string
	tender_win_date                         *time.Time
	tender_win_amount                       *string
	last_tender_amount                      *float64
	addlast_tender_amount                   *float64
	clearedFields                           map[string]struct{}
	area                                    *xid.ID
	clearedarea                             bool
	customer                                *xid.ID
	clearedcustomer                         bool
	finder                                  *xid.ID
	clearedfinder                           bool
	created_by                              *xid.ID
	clearedcreated_by                       bool
	following_sales                         map[xid.ID]struct{}
	removedfollowing_sales                  map[xid.ID]struct{}
	clearedfollowing_sales                  bool
	province                                *xid.ID
	clearedprovince                         bool
	city                                    *xid.ID
	clearedcity                             bool
	district                                *xid.ID
	cleareddistrict                         bool
	visit_records                           map[xid.ID]struct{}
	removedvisit_records                    map[xid.ID]struct{}
	clearedvisit_records                    bool
	done                                    bool
	oldValue                                func(context.Context) (*Tender, error)
	predicates                              []predicate.Tender
}

var _ ent.Mutation = (*TenderMutation)(nil)

// tenderOption allows management of the mutation configuration using functional options.
type tenderOption func(*TenderMutation)

// newTenderMutation creates new mutation for the Tender entity.
func newTenderMutation(c config, op Op, opts ...tenderOption) *TenderMutation {
	m := &TenderMutation{
		config:        c,
		op:            op,
		typ:           TypeTender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenderID sets the ID field of the mutation.
func withTenderID(id xid.ID) tenderOption {
	return func(m *TenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Tender
		)
		m.oldValue = func(ctx context.Context) (*Tender, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTender sets the old Tender of the mutation.
func withTender(node *Tender) tenderOption {
	return func(m *TenderMutation) {
		m.oldValue = func(context.Context) (*Tender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tender entities.
func (m *TenderMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenderMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenderMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tender.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *TenderMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenderMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenderMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *TenderMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TenderMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TenderMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TenderMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TenderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *TenderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenderMutation) ResetName() {
	m.name = nil
}

// SetEstimatedAmount sets the "estimated_amount" field.
func (m *TenderMutation) SetEstimatedAmount(f float64) {
	m.estimated_amount = &f
	m.addestimated_amount = nil
}

// EstimatedAmount returns the value of the "estimated_amount" field in the mutation.
func (m *TenderMutation) EstimatedAmount() (r float64, exists bool) {
	v := m.estimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedAmount returns the old "estimated_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedAmount: %w", err)
	}
	return oldValue.EstimatedAmount, nil
}

// AddEstimatedAmount adds f to the "estimated_amount" field.
func (m *TenderMutation) AddEstimatedAmount(f float64) {
	if m.addestimated_amount != nil {
		*m.addestimated_amount += f
	} else {
		m.addestimated_amount = &f
	}
}

// AddedEstimatedAmount returns the value that was added to the "estimated_amount" field in this mutation.
func (m *TenderMutation) AddedEstimatedAmount() (r float64, exists bool) {
	v := m.addestimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedAmount clears the value of the "estimated_amount" field.
func (m *TenderMutation) ClearEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	m.clearedFields[tender.FieldEstimatedAmount] = struct{}{}
}

// EstimatedAmountCleared returns if the "estimated_amount" field was cleared in this mutation.
func (m *TenderMutation) EstimatedAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedAmount]
	return ok
}

// ResetEstimatedAmount resets all changes to the "estimated_amount" field.
func (m *TenderMutation) ResetEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	delete(m.clearedFields, tender.FieldEstimatedAmount)
}

// SetTenderDate sets the "tender_date" field.
func (m *TenderMutation) SetTenderDate(t time.Time) {
	m.tender_date = &t
}

// TenderDate returns the value of the "tender_date" field in the mutation.
func (m *TenderMutation) TenderDate() (r time.Time, exists bool) {
	v := m.tender_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderDate returns the old "tender_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderDate: %w", err)
	}
	return oldValue.TenderDate, nil
}

// ClearTenderDate clears the value of the "tender_date" field.
func (m *TenderMutation) ClearTenderDate() {
	m.tender_date = nil
	m.clearedFields[tender.FieldTenderDate] = struct{}{}
}

// TenderDateCleared returns if the "tender_date" field was cleared in this mutation.
func (m *TenderMutation) TenderDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderDate]
	return ok
}

// ResetTenderDate resets all changes to the "tender_date" field.
func (m *TenderMutation) ResetTenderDate() {
	m.tender_date = nil
	delete(m.clearedFields, tender.FieldTenderDate)
}

// SetDiscoveryDate sets the "discovery_date" field.
func (m *TenderMutation) SetDiscoveryDate(t time.Time) {
	m.discovery_date = &t
}

// DiscoveryDate returns the value of the "discovery_date" field in the mutation.
func (m *TenderMutation) DiscoveryDate() (r time.Time, exists bool) {
	v := m.discovery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryDate returns the old "discovery_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDiscoveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryDate: %w", err)
	}
	return oldValue.DiscoveryDate, nil
}

// ResetDiscoveryDate resets all changes to the "discovery_date" field.
func (m *TenderMutation) ResetDiscoveryDate() {
	m.discovery_date = nil
}

// SetAddress sets the "address" field.
func (m *TenderMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TenderMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *TenderMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[tender.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *TenderMutation) AddressCleared() bool {
	_, ok := m.clearedFields[tender.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *TenderMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, tender.FieldAddress)
}

// SetFullAddress sets the "full_address" field.
func (m *TenderMutation) SetFullAddress(s string) {
	m.full_address = &s
}

// FullAddress returns the value of the "full_address" field in the mutation.
func (m *TenderMutation) FullAddress() (r string, exists bool) {
	v := m.full_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFullAddress returns the old "full_address" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFullAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullAddress: %w", err)
	}
	return oldValue.FullAddress, nil
}

// ClearFullAddress clears the value of the "full_address" field.
func (m *TenderMutation) ClearFullAddress() {
	m.full_address = nil
	m.clearedFields[tender.FieldFullAddress] = struct{}{}
}

// FullAddressCleared returns if the "full_address" field was cleared in this mutation.
func (m *TenderMutation) FullAddressCleared() bool {
	_, ok := m.clearedFields[tender.FieldFullAddress]
	return ok
}

// ResetFullAddress resets all changes to the "full_address" field.
func (m *TenderMutation) ResetFullAddress() {
	m.full_address = nil
	delete(m.clearedFields, tender.FieldFullAddress)
}

// SetContractor sets the "contractor" field.
func (m *TenderMutation) SetContractor(s string) {
	m.contractor = &s
}

// Contractor returns the value of the "contractor" field in the mutation.
func (m *TenderMutation) Contractor() (r string, exists bool) {
	v := m.contractor
	if v == nil {
		return
	}
	return *v, true
}

// OldContractor returns the old "contractor" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldContractor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractor: %w", err)
	}
	return oldValue.Contractor, nil
}

// ClearContractor clears the value of the "contractor" field.
func (m *TenderMutation) ClearContractor() {
	m.contractor = nil
	m.clearedFields[tender.FieldContractor] = struct{}{}
}

// ContractorCleared returns if the "contractor" field was cleared in this mutation.
func (m *TenderMutation) ContractorCleared() bool {
	_, ok := m.clearedFields[tender.FieldContractor]
	return ok
}

// ResetContractor resets all changes to the "contractor" field.
func (m *TenderMutation) ResetContractor() {
	m.contractor = nil
	delete(m.clearedFields, tender.FieldContractor)
}

// SetSizeAndValueRating sets the "size_and_value_rating" field.
func (m *TenderMutation) SetSizeAndValueRating(i int) {
	m.size_and_value_rating = &i
	m.addsize_and_value_rating = nil
}

// SizeAndValueRating returns the value of the "size_and_value_rating" field in the mutation.
func (m *TenderMutation) SizeAndValueRating() (r int, exists bool) {
	v := m.size_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRating returns the old "size_and_value_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldSizeAndValueRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRating: %w", err)
	}
	return oldValue.SizeAndValueRating, nil
}

// AddSizeAndValueRating adds i to the "size_and_value_rating" field.
func (m *TenderMutation) AddSizeAndValueRating(i int) {
	if m.addsize_and_value_rating != nil {
		*m.addsize_and_value_rating += i
	} else {
		m.addsize_and_value_rating = &i
	}
}

// AddedSizeAndValueRating returns the value that was added to the "size_and_value_rating" field in this mutation.
func (m *TenderMutation) AddedSizeAndValueRating() (r int, exists bool) {
	v := m.addsize_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeAndValueRating clears the value of the "size_and_value_rating" field.
func (m *TenderMutation) ClearSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	m.clearedFields[tender.FieldSizeAndValueRating] = struct{}{}
}

// SizeAndValueRatingCleared returns if the "size_and_value_rating" field was cleared in this mutation.
func (m *TenderMutation) SizeAndValueRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldSizeAndValueRating]
	return ok
}

// ResetSizeAndValueRating resets all changes to the "size_and_value_rating" field.
func (m *TenderMutation) ResetSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	delete(m.clearedFields, tender.FieldSizeAndValueRating)
}

// SetSizeAndValueRatingOverview sets the "size_and_value_rating_overview" field.
func (m *TenderMutation) SetSizeAndValueRatingOverview(s string) {
	m.size_and_value_rating_overview = &s
}

// SizeAndValueRatingOverview returns the value of the "size_and_value_rating_overview" field in the mutation.
func (m *TenderMutation) SizeAndValueRatingOverview() (r string, exists bool) {
	v := m.size_and_value_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRatingOverview returns the old "size_and_value_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldSizeAndValueRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRatingOverview: %w", err)
	}
	return oldValue.SizeAndValueRatingOverview, nil
}

// ClearSizeAndValueRatingOverview clears the value of the "size_and_value_rating_overview" field.
func (m *TenderMutation) ClearSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	m.clearedFields[tender.FieldSizeAndValueRatingOverview] = struct{}{}
}

// SizeAndValueRatingOverviewCleared returns if the "size_and_value_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) SizeAndValueRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldSizeAndValueRatingOverview]
	return ok
}

// ResetSizeAndValueRatingOverview resets all changes to the "size_and_value_rating_overview" field.
func (m *TenderMutation) ResetSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	delete(m.clearedFields, tender.FieldSizeAndValueRatingOverview)
}

// SetCreditAndPaymentRating sets the "credit_and_payment_rating" field.
func (m *TenderMutation) SetCreditAndPaymentRating(i int) {
	m.credit_and_payment_rating = &i
	m.addcredit_and_payment_rating = nil
}

// CreditAndPaymentRating returns the value of the "credit_and_payment_rating" field in the mutation.
func (m *TenderMutation) CreditAndPaymentRating() (r int, exists bool) {
	v := m.credit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRating returns the old "credit_and_payment_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreditAndPaymentRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRating: %w", err)
	}
	return oldValue.CreditAndPaymentRating, nil
}

// AddCreditAndPaymentRating adds i to the "credit_and_payment_rating" field.
func (m *TenderMutation) AddCreditAndPaymentRating(i int) {
	if m.addcredit_and_payment_rating != nil {
		*m.addcredit_and_payment_rating += i
	} else {
		m.addcredit_and_payment_rating = &i
	}
}

// AddedCreditAndPaymentRating returns the value that was added to the "credit_and_payment_rating" field in this mutation.
func (m *TenderMutation) AddedCreditAndPaymentRating() (r int, exists bool) {
	v := m.addcredit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditAndPaymentRating clears the value of the "credit_and_payment_rating" field.
func (m *TenderMutation) ClearCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	m.clearedFields[tender.FieldCreditAndPaymentRating] = struct{}{}
}

// CreditAndPaymentRatingCleared returns if the "credit_and_payment_rating" field was cleared in this mutation.
func (m *TenderMutation) CreditAndPaymentRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCreditAndPaymentRating]
	return ok
}

// ResetCreditAndPaymentRating resets all changes to the "credit_and_payment_rating" field.
func (m *TenderMutation) ResetCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	delete(m.clearedFields, tender.FieldCreditAndPaymentRating)
}

// SetCreditAndPaymentRatingOverview sets the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) SetCreditAndPaymentRatingOverview(s string) {
	m.credit_and_payment_rating_overview = &s
}

// CreditAndPaymentRatingOverview returns the value of the "credit_and_payment_rating_overview" field in the mutation.
func (m *TenderMutation) CreditAndPaymentRatingOverview() (r string, exists bool) {
	v := m.credit_and_payment_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRatingOverview returns the old "credit_and_payment_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreditAndPaymentRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRatingOverview: %w", err)
	}
	return oldValue.CreditAndPaymentRatingOverview, nil
}

// ClearCreditAndPaymentRatingOverview clears the value of the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) ClearCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	m.clearedFields[tender.FieldCreditAndPaymentRatingOverview] = struct{}{}
}

// CreditAndPaymentRatingOverviewCleared returns if the "credit_and_payment_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CreditAndPaymentRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCreditAndPaymentRatingOverview]
	return ok
}

// ResetCreditAndPaymentRatingOverview resets all changes to the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) ResetCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	delete(m.clearedFields, tender.FieldCreditAndPaymentRatingOverview)
}

// SetTimeLimitRating sets the "time_limit_rating" field.
func (m *TenderMutation) SetTimeLimitRating(i int) {
	m.time_limit_rating = &i
	m.addtime_limit_rating = nil
}

// TimeLimitRating returns the value of the "time_limit_rating" field in the mutation.
func (m *TenderMutation) TimeLimitRating() (r int, exists bool) {
	v := m.time_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRating returns the old "time_limit_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTimeLimitRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRating: %w", err)
	}
	return oldValue.TimeLimitRating, nil
}

// AddTimeLimitRating adds i to the "time_limit_rating" field.
func (m *TenderMutation) AddTimeLimitRating(i int) {
	if m.addtime_limit_rating != nil {
		*m.addtime_limit_rating += i
	} else {
		m.addtime_limit_rating = &i
	}
}

// AddedTimeLimitRating returns the value that was added to the "time_limit_rating" field in this mutation.
func (m *TenderMutation) AddedTimeLimitRating() (r int, exists bool) {
	v := m.addtime_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeLimitRating clears the value of the "time_limit_rating" field.
func (m *TenderMutation) ClearTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	m.clearedFields[tender.FieldTimeLimitRating] = struct{}{}
}

// TimeLimitRatingCleared returns if the "time_limit_rating" field was cleared in this mutation.
func (m *TenderMutation) TimeLimitRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldTimeLimitRating]
	return ok
}

// ResetTimeLimitRating resets all changes to the "time_limit_rating" field.
func (m *TenderMutation) ResetTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	delete(m.clearedFields, tender.FieldTimeLimitRating)
}

// SetTimeLimitRatingOverview sets the "time_limit_rating_overview" field.
func (m *TenderMutation) SetTimeLimitRatingOverview(s string) {
	m.time_limit_rating_overview = &s
}

// TimeLimitRatingOverview returns the value of the "time_limit_rating_overview" field in the mutation.
func (m *TenderMutation) TimeLimitRatingOverview() (r string, exists bool) {
	v := m.time_limit_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRatingOverview returns the old "time_limit_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTimeLimitRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRatingOverview: %w", err)
	}
	return oldValue.TimeLimitRatingOverview, nil
}

// ClearTimeLimitRatingOverview clears the value of the "time_limit_rating_overview" field.
func (m *TenderMutation) ClearTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	m.clearedFields[tender.FieldTimeLimitRatingOverview] = struct{}{}
}

// TimeLimitRatingOverviewCleared returns if the "time_limit_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) TimeLimitRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldTimeLimitRatingOverview]
	return ok
}

// ResetTimeLimitRatingOverview resets all changes to the "time_limit_rating_overview" field.
func (m *TenderMutation) ResetTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	delete(m.clearedFields, tender.FieldTimeLimitRatingOverview)
}

// SetCustomerRelationshipRating sets the "customer_relationship_rating" field.
func (m *TenderMutation) SetCustomerRelationshipRating(i int) {
	m.customer_relationship_rating = &i
	m.addcustomer_relationship_rating = nil
}

// CustomerRelationshipRating returns the value of the "customer_relationship_rating" field in the mutation.
func (m *TenderMutation) CustomerRelationshipRating() (r int, exists bool) {
	v := m.customer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRating returns the old "customer_relationship_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerRelationshipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRating: %w", err)
	}
	return oldValue.CustomerRelationshipRating, nil
}

// AddCustomerRelationshipRating adds i to the "customer_relationship_rating" field.
func (m *TenderMutation) AddCustomerRelationshipRating(i int) {
	if m.addcustomer_relationship_rating != nil {
		*m.addcustomer_relationship_rating += i
	} else {
		m.addcustomer_relationship_rating = &i
	}
}

// AddedCustomerRelationshipRating returns the value that was added to the "customer_relationship_rating" field in this mutation.
func (m *TenderMutation) AddedCustomerRelationshipRating() (r int, exists bool) {
	v := m.addcustomer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerRelationshipRating clears the value of the "customer_relationship_rating" field.
func (m *TenderMutation) ClearCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	m.clearedFields[tender.FieldCustomerRelationshipRating] = struct{}{}
}

// CustomerRelationshipRatingCleared returns if the "customer_relationship_rating" field was cleared in this mutation.
func (m *TenderMutation) CustomerRelationshipRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCustomerRelationshipRating]
	return ok
}

// ResetCustomerRelationshipRating resets all changes to the "customer_relationship_rating" field.
func (m *TenderMutation) ResetCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	delete(m.clearedFields, tender.FieldCustomerRelationshipRating)
}

// SetCustomerRelationshipRatingOverview sets the "customer_relationship_rating_overview" field.
func (m *TenderMutation) SetCustomerRelationshipRatingOverview(s string) {
	m.customer_relationship_rating_overview = &s
}

// CustomerRelationshipRatingOverview returns the value of the "customer_relationship_rating_overview" field in the mutation.
func (m *TenderMutation) CustomerRelationshipRatingOverview() (r string, exists bool) {
	v := m.customer_relationship_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRatingOverview returns the old "customer_relationship_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerRelationshipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRatingOverview: %w", err)
	}
	return oldValue.CustomerRelationshipRatingOverview, nil
}

// ClearCustomerRelationshipRatingOverview clears the value of the "customer_relationship_rating_overview" field.
func (m *TenderMutation) ClearCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	m.clearedFields[tender.FieldCustomerRelationshipRatingOverview] = struct{}{}
}

// CustomerRelationshipRatingOverviewCleared returns if the "customer_relationship_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CustomerRelationshipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCustomerRelationshipRatingOverview]
	return ok
}

// ResetCustomerRelationshipRatingOverview resets all changes to the "customer_relationship_rating_overview" field.
func (m *TenderMutation) ResetCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	delete(m.clearedFields, tender.FieldCustomerRelationshipRatingOverview)
}

// SetCompetitivePartnershipRating sets the "competitive_partnership_rating" field.
func (m *TenderMutation) SetCompetitivePartnershipRating(i int) {
	m.competitive_partnership_rating = &i
	m.addcompetitive_partnership_rating = nil
}

// CompetitivePartnershipRating returns the value of the "competitive_partnership_rating" field in the mutation.
func (m *TenderMutation) CompetitivePartnershipRating() (r int, exists bool) {
	v := m.competitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRating returns the old "competitive_partnership_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitivePartnershipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRating: %w", err)
	}
	return oldValue.CompetitivePartnershipRating, nil
}

// AddCompetitivePartnershipRating adds i to the "competitive_partnership_rating" field.
func (m *TenderMutation) AddCompetitivePartnershipRating(i int) {
	if m.addcompetitive_partnership_rating != nil {
		*m.addcompetitive_partnership_rating += i
	} else {
		m.addcompetitive_partnership_rating = &i
	}
}

// AddedCompetitivePartnershipRating returns the value that was added to the "competitive_partnership_rating" field in this mutation.
func (m *TenderMutation) AddedCompetitivePartnershipRating() (r int, exists bool) {
	v := m.addcompetitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompetitivePartnershipRating clears the value of the "competitive_partnership_rating" field.
func (m *TenderMutation) ClearCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	m.clearedFields[tender.FieldCompetitivePartnershipRating] = struct{}{}
}

// CompetitivePartnershipRatingCleared returns if the "competitive_partnership_rating" field was cleared in this mutation.
func (m *TenderMutation) CompetitivePartnershipRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitivePartnershipRating]
	return ok
}

// ResetCompetitivePartnershipRating resets all changes to the "competitive_partnership_rating" field.
func (m *TenderMutation) ResetCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	delete(m.clearedFields, tender.FieldCompetitivePartnershipRating)
}

// SetCompetitivePartnershipRatingOverview sets the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) SetCompetitivePartnershipRatingOverview(s string) {
	m.competitive_partnership_rating_overview = &s
}

// CompetitivePartnershipRatingOverview returns the value of the "competitive_partnership_rating_overview" field in the mutation.
func (m *TenderMutation) CompetitivePartnershipRatingOverview() (r string, exists bool) {
	v := m.competitive_partnership_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRatingOverview returns the old "competitive_partnership_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitivePartnershipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRatingOverview: %w", err)
	}
	return oldValue.CompetitivePartnershipRatingOverview, nil
}

// ClearCompetitivePartnershipRatingOverview clears the value of the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) ClearCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	m.clearedFields[tender.FieldCompetitivePartnershipRatingOverview] = struct{}{}
}

// CompetitivePartnershipRatingOverviewCleared returns if the "competitive_partnership_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CompetitivePartnershipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitivePartnershipRatingOverview]
	return ok
}

// ResetCompetitivePartnershipRatingOverview resets all changes to the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) ResetCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	delete(m.clearedFields, tender.FieldCompetitivePartnershipRatingOverview)
}

// SetPrepareToBid sets the "prepare_to_bid" field.
func (m *TenderMutation) SetPrepareToBid(b bool) {
	m.prepare_to_bid = &b
}

// PrepareToBid returns the value of the "prepare_to_bid" field in the mutation.
func (m *TenderMutation) PrepareToBid() (r bool, exists bool) {
	v := m.prepare_to_bid
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepareToBid returns the old "prepare_to_bid" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldPrepareToBid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepareToBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepareToBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepareToBid: %w", err)
	}
	return oldValue.PrepareToBid, nil
}

// ResetPrepareToBid resets all changes to the "prepare_to_bid" field.
func (m *TenderMutation) ResetPrepareToBid() {
	m.prepare_to_bid = nil
}

// SetProjectCode sets the "project_code" field.
func (m *TenderMutation) SetProjectCode(s string) {
	m.project_code = &s
}

// ProjectCode returns the value of the "project_code" field in the mutation.
func (m *TenderMutation) ProjectCode() (r string, exists bool) {
	v := m.project_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectCode returns the old "project_code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectCode: %w", err)
	}
	return oldValue.ProjectCode, nil
}

// ClearProjectCode clears the value of the "project_code" field.
func (m *TenderMutation) ClearProjectCode() {
	m.project_code = nil
	m.clearedFields[tender.FieldProjectCode] = struct{}{}
}

// ProjectCodeCleared returns if the "project_code" field was cleared in this mutation.
func (m *TenderMutation) ProjectCodeCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectCode]
	return ok
}

// ResetProjectCode resets all changes to the "project_code" field.
func (m *TenderMutation) ResetProjectCode() {
	m.project_code = nil
	delete(m.clearedFields, tender.FieldProjectCode)
}

// SetProjectDefinition sets the "project_definition" field.
func (m *TenderMutation) SetProjectDefinition(s string) {
	m.project_definition = &s
}

// ProjectDefinition returns the value of the "project_definition" field in the mutation.
func (m *TenderMutation) ProjectDefinition() (r string, exists bool) {
	v := m.project_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectDefinition returns the old "project_definition" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectDefinition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectDefinition: %w", err)
	}
	return oldValue.ProjectDefinition, nil
}

// ClearProjectDefinition clears the value of the "project_definition" field.
func (m *TenderMutation) ClearProjectDefinition() {
	m.project_definition = nil
	m.clearedFields[tender.FieldProjectDefinition] = struct{}{}
}

// ProjectDefinitionCleared returns if the "project_definition" field was cleared in this mutation.
func (m *TenderMutation) ProjectDefinitionCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectDefinition]
	return ok
}

// ResetProjectDefinition resets all changes to the "project_definition" field.
func (m *TenderMutation) ResetProjectDefinition() {
	m.project_definition = nil
	delete(m.clearedFields, tender.FieldProjectDefinition)
}

// SetEstimatedProjectStartDate sets the "estimated_project_start_date" field.
func (m *TenderMutation) SetEstimatedProjectStartDate(t time.Time) {
	m.estimated_project_start_date = &t
}

// EstimatedProjectStartDate returns the value of the "estimated_project_start_date" field in the mutation.
func (m *TenderMutation) EstimatedProjectStartDate() (r time.Time, exists bool) {
	v := m.estimated_project_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectStartDate returns the old "estimated_project_start_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedProjectStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectStartDate: %w", err)
	}
	return oldValue.EstimatedProjectStartDate, nil
}

// ClearEstimatedProjectStartDate clears the value of the "estimated_project_start_date" field.
func (m *TenderMutation) ClearEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	m.clearedFields[tender.FieldEstimatedProjectStartDate] = struct{}{}
}

// EstimatedProjectStartDateCleared returns if the "estimated_project_start_date" field was cleared in this mutation.
func (m *TenderMutation) EstimatedProjectStartDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedProjectStartDate]
	return ok
}

// ResetEstimatedProjectStartDate resets all changes to the "estimated_project_start_date" field.
func (m *TenderMutation) ResetEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	delete(m.clearedFields, tender.FieldEstimatedProjectStartDate)
}

// SetEstimatedProjectEndDate sets the "estimated_project_end_date" field.
func (m *TenderMutation) SetEstimatedProjectEndDate(t time.Time) {
	m.estimated_project_end_date = &t
}

// EstimatedProjectEndDate returns the value of the "estimated_project_end_date" field in the mutation.
func (m *TenderMutation) EstimatedProjectEndDate() (r time.Time, exists bool) {
	v := m.estimated_project_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectEndDate returns the old "estimated_project_end_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedProjectEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectEndDate: %w", err)
	}
	return oldValue.EstimatedProjectEndDate, nil
}

// ClearEstimatedProjectEndDate clears the value of the "estimated_project_end_date" field.
func (m *TenderMutation) ClearEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	m.clearedFields[tender.FieldEstimatedProjectEndDate] = struct{}{}
}

// EstimatedProjectEndDateCleared returns if the "estimated_project_end_date" field was cleared in this mutation.
func (m *TenderMutation) EstimatedProjectEndDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedProjectEndDate]
	return ok
}

// ResetEstimatedProjectEndDate resets all changes to the "estimated_project_end_date" field.
func (m *TenderMutation) ResetEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	delete(m.clearedFields, tender.FieldEstimatedProjectEndDate)
}

// SetProjectType sets the "project_type" field.
func (m *TenderMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *TenderMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ClearProjectType clears the value of the "project_type" field.
func (m *TenderMutation) ClearProjectType() {
	m.project_type = nil
	m.clearedFields[tender.FieldProjectType] = struct{}{}
}

// ProjectTypeCleared returns if the "project_type" field was cleared in this mutation.
func (m *TenderMutation) ProjectTypeCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectType]
	return ok
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *TenderMutation) ResetProjectType() {
	m.project_type = nil
	delete(m.clearedFields, tender.FieldProjectType)
}

// SetAttachements sets the "attachements" field.
func (m *TenderMutation) SetAttachements(s []string) {
	m.attachements = &s
	m.appendattachements = nil
}

// Attachements returns the value of the "attachements" field in the mutation.
func (m *TenderMutation) Attachements() (r []string, exists bool) {
	v := m.attachements
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachements returns the old "attachements" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAttachements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachements: %w", err)
	}
	return oldValue.Attachements, nil
}

// AppendAttachements adds s to the "attachements" field.
func (m *TenderMutation) AppendAttachements(s []string) {
	m.appendattachements = append(m.appendattachements, s...)
}

// AppendedAttachements returns the list of values that were appended to the "attachements" field in this mutation.
func (m *TenderMutation) AppendedAttachements() ([]string, bool) {
	if len(m.appendattachements) == 0 {
		return nil, false
	}
	return m.appendattachements, true
}

// ClearAttachements clears the value of the "attachements" field.
func (m *TenderMutation) ClearAttachements() {
	m.attachements = nil
	m.appendattachements = nil
	m.clearedFields[tender.FieldAttachements] = struct{}{}
}

// AttachementsCleared returns if the "attachements" field was cleared in this mutation.
func (m *TenderMutation) AttachementsCleared() bool {
	_, ok := m.clearedFields[tender.FieldAttachements]
	return ok
}

// ResetAttachements resets all changes to the "attachements" field.
func (m *TenderMutation) ResetAttachements() {
	m.attachements = nil
	m.appendattachements = nil
	delete(m.clearedFields, tender.FieldAttachements)
}

// SetGeoCoordinate sets the "geo_coordinate" field.
func (m *TenderMutation) SetGeoCoordinate(gj *geo.GeoJson) {
	m.geo_coordinate = &gj
}

// GeoCoordinate returns the value of the "geo_coordinate" field in the mutation.
func (m *TenderMutation) GeoCoordinate() (r *geo.GeoJson, exists bool) {
	v := m.geo_coordinate
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoCoordinate returns the old "geo_coordinate" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldGeoCoordinate(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoCoordinate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoCoordinate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoCoordinate: %w", err)
	}
	return oldValue.GeoCoordinate, nil
}

// ClearGeoCoordinate clears the value of the "geo_coordinate" field.
func (m *TenderMutation) ClearGeoCoordinate() {
	m.geo_coordinate = nil
	m.clearedFields[tender.FieldGeoCoordinate] = struct{}{}
}

// GeoCoordinateCleared returns if the "geo_coordinate" field was cleared in this mutation.
func (m *TenderMutation) GeoCoordinateCleared() bool {
	_, ok := m.clearedFields[tender.FieldGeoCoordinate]
	return ok
}

// ResetGeoCoordinate resets all changes to the "geo_coordinate" field.
func (m *TenderMutation) ResetGeoCoordinate() {
	m.geo_coordinate = nil
	delete(m.clearedFields, tender.FieldGeoCoordinate)
}

// SetGeoBounds sets the "geo_bounds" field.
func (m *TenderMutation) SetGeoBounds(f [][]float64) {
	m.geo_bounds = &f
	m.appendgeo_bounds = nil
}

// GeoBounds returns the value of the "geo_bounds" field in the mutation.
func (m *TenderMutation) GeoBounds() (r [][]float64, exists bool) {
	v := m.geo_bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoBounds returns the old "geo_bounds" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldGeoBounds(ctx context.Context) (v [][]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoBounds: %w", err)
	}
	return oldValue.GeoBounds, nil
}

// AppendGeoBounds adds f to the "geo_bounds" field.
func (m *TenderMutation) AppendGeoBounds(f [][]float64) {
	m.appendgeo_bounds = append(m.appendgeo_bounds, f...)
}

// AppendedGeoBounds returns the list of values that were appended to the "geo_bounds" field in this mutation.
func (m *TenderMutation) AppendedGeoBounds() ([][]float64, bool) {
	if len(m.appendgeo_bounds) == 0 {
		return nil, false
	}
	return m.appendgeo_bounds, true
}

// ClearGeoBounds clears the value of the "geo_bounds" field.
func (m *TenderMutation) ClearGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	m.clearedFields[tender.FieldGeoBounds] = struct{}{}
}

// GeoBoundsCleared returns if the "geo_bounds" field was cleared in this mutation.
func (m *TenderMutation) GeoBoundsCleared() bool {
	_, ok := m.clearedFields[tender.FieldGeoBounds]
	return ok
}

// ResetGeoBounds resets all changes to the "geo_bounds" field.
func (m *TenderMutation) ResetGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	delete(m.clearedFields, tender.FieldGeoBounds)
}

// SetRemark sets the "remark" field.
func (m *TenderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TenderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TenderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[tender.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TenderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[tender.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TenderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, tender.FieldRemark)
}

// SetImages sets the "images" field.
func (m *TenderMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *TenderMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *TenderMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *TenderMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *TenderMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[tender.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *TenderMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[tender.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *TenderMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, tender.FieldImages)
}

// SetTenderSituations sets the "tender_situations" field.
func (m *TenderMutation) SetTenderSituations(s string) {
	m.tender_situations = &s
}

// TenderSituations returns the value of the "tender_situations" field in the mutation.
func (m *TenderMutation) TenderSituations() (r string, exists bool) {
	v := m.tender_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderSituations returns the old "tender_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderSituations: %w", err)
	}
	return oldValue.TenderSituations, nil
}

// ClearTenderSituations clears the value of the "tender_situations" field.
func (m *TenderMutation) ClearTenderSituations() {
	m.tender_situations = nil
	m.clearedFields[tender.FieldTenderSituations] = struct{}{}
}

// TenderSituationsCleared returns if the "tender_situations" field was cleared in this mutation.
func (m *TenderMutation) TenderSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderSituations]
	return ok
}

// ResetTenderSituations resets all changes to the "tender_situations" field.
func (m *TenderMutation) ResetTenderSituations() {
	m.tender_situations = nil
	delete(m.clearedFields, tender.FieldTenderSituations)
}

// SetOwnerSituations sets the "owner_situations" field.
func (m *TenderMutation) SetOwnerSituations(s string) {
	m.owner_situations = &s
}

// OwnerSituations returns the value of the "owner_situations" field in the mutation.
func (m *TenderMutation) OwnerSituations() (r string, exists bool) {
	v := m.owner_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSituations returns the old "owner_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldOwnerSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSituations: %w", err)
	}
	return oldValue.OwnerSituations, nil
}

// ClearOwnerSituations clears the value of the "owner_situations" field.
func (m *TenderMutation) ClearOwnerSituations() {
	m.owner_situations = nil
	m.clearedFields[tender.FieldOwnerSituations] = struct{}{}
}

// OwnerSituationsCleared returns if the "owner_situations" field was cleared in this mutation.
func (m *TenderMutation) OwnerSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldOwnerSituations]
	return ok
}

// ResetOwnerSituations resets all changes to the "owner_situations" field.
func (m *TenderMutation) ResetOwnerSituations() {
	m.owner_situations = nil
	delete(m.clearedFields, tender.FieldOwnerSituations)
}

// SetBiddingInstructions sets the "bidding_instructions" field.
func (m *TenderMutation) SetBiddingInstructions(s string) {
	m.bidding_instructions = &s
}

// BiddingInstructions returns the value of the "bidding_instructions" field in the mutation.
func (m *TenderMutation) BiddingInstructions() (r string, exists bool) {
	v := m.bidding_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingInstructions returns the old "bidding_instructions" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldBiddingInstructions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingInstructions: %w", err)
	}
	return oldValue.BiddingInstructions, nil
}

// ClearBiddingInstructions clears the value of the "bidding_instructions" field.
func (m *TenderMutation) ClearBiddingInstructions() {
	m.bidding_instructions = nil
	m.clearedFields[tender.FieldBiddingInstructions] = struct{}{}
}

// BiddingInstructionsCleared returns if the "bidding_instructions" field was cleared in this mutation.
func (m *TenderMutation) BiddingInstructionsCleared() bool {
	_, ok := m.clearedFields[tender.FieldBiddingInstructions]
	return ok
}

// ResetBiddingInstructions resets all changes to the "bidding_instructions" field.
func (m *TenderMutation) ResetBiddingInstructions() {
	m.bidding_instructions = nil
	delete(m.clearedFields, tender.FieldBiddingInstructions)
}

// SetCompetitorSituations sets the "competitor_situations" field.
func (m *TenderMutation) SetCompetitorSituations(s string) {
	m.competitor_situations = &s
}

// CompetitorSituations returns the value of the "competitor_situations" field in the mutation.
func (m *TenderMutation) CompetitorSituations() (r string, exists bool) {
	v := m.competitor_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitorSituations returns the old "competitor_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitorSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitorSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitorSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitorSituations: %w", err)
	}
	return oldValue.CompetitorSituations, nil
}

// ClearCompetitorSituations clears the value of the "competitor_situations" field.
func (m *TenderMutation) ClearCompetitorSituations() {
	m.competitor_situations = nil
	m.clearedFields[tender.FieldCompetitorSituations] = struct{}{}
}

// CompetitorSituationsCleared returns if the "competitor_situations" field was cleared in this mutation.
func (m *TenderMutation) CompetitorSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitorSituations]
	return ok
}

// ResetCompetitorSituations resets all changes to the "competitor_situations" field.
func (m *TenderMutation) ResetCompetitorSituations() {
	m.competitor_situations = nil
	delete(m.clearedFields, tender.FieldCompetitorSituations)
}

// SetCostEngineer sets the "cost_engineer" field.
func (m *TenderMutation) SetCostEngineer(s string) {
	m.cost_engineer = &s
}

// CostEngineer returns the value of the "cost_engineer" field in the mutation.
func (m *TenderMutation) CostEngineer() (r string, exists bool) {
	v := m.cost_engineer
	if v == nil {
		return
	}
	return *v, true
}

// OldCostEngineer returns the old "cost_engineer" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCostEngineer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostEngineer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostEngineer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostEngineer: %w", err)
	}
	return oldValue.CostEngineer, nil
}

// ClearCostEngineer clears the value of the "cost_engineer" field.
func (m *TenderMutation) ClearCostEngineer() {
	m.cost_engineer = nil
	m.clearedFields[tender.FieldCostEngineer] = struct{}{}
}

// CostEngineerCleared returns if the "cost_engineer" field was cleared in this mutation.
func (m *TenderMutation) CostEngineerCleared() bool {
	_, ok := m.clearedFields[tender.FieldCostEngineer]
	return ok
}

// ResetCostEngineer resets all changes to the "cost_engineer" field.
func (m *TenderMutation) ResetCostEngineer() {
	m.cost_engineer = nil
	delete(m.clearedFields, tender.FieldCostEngineer)
}

// SetTenderForm sets the "tender_form" field.
func (m *TenderMutation) SetTenderForm(s string) {
	m.tender_form = &s
}

// TenderForm returns the value of the "tender_form" field in the mutation.
func (m *TenderMutation) TenderForm() (r string, exists bool) {
	v := m.tender_form
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderForm returns the old "tender_form" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderForm: %w", err)
	}
	return oldValue.TenderForm, nil
}

// ClearTenderForm clears the value of the "tender_form" field.
func (m *TenderMutation) ClearTenderForm() {
	m.tender_form = nil
	m.clearedFields[tender.FieldTenderForm] = struct{}{}
}

// TenderFormCleared returns if the "tender_form" field was cleared in this mutation.
func (m *TenderMutation) TenderFormCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderForm]
	return ok
}

// ResetTenderForm resets all changes to the "tender_form" field.
func (m *TenderMutation) ResetTenderForm() {
	m.tender_form = nil
	delete(m.clearedFields, tender.FieldTenderForm)
}

// SetContractForm sets the "contract_form" field.
func (m *TenderMutation) SetContractForm(s string) {
	m.contract_form = &s
}

// ContractForm returns the value of the "contract_form" field in the mutation.
func (m *TenderMutation) ContractForm() (r string, exists bool) {
	v := m.contract_form
	if v == nil {
		return
	}
	return *v, true
}

// OldContractForm returns the old "contract_form" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldContractForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractForm: %w", err)
	}
	return oldValue.ContractForm, nil
}

// ClearContractForm clears the value of the "contract_form" field.
func (m *TenderMutation) ClearContractForm() {
	m.contract_form = nil
	m.clearedFields[tender.FieldContractForm] = struct{}{}
}

// ContractFormCleared returns if the "contract_form" field was cleared in this mutation.
func (m *TenderMutation) ContractFormCleared() bool {
	_, ok := m.clearedFields[tender.FieldContractForm]
	return ok
}

// ResetContractForm resets all changes to the "contract_form" field.
func (m *TenderMutation) ResetContractForm() {
	m.contract_form = nil
	delete(m.clearedFields, tender.FieldContractForm)
}

// SetManagementCompany sets the "management_company" field.
func (m *TenderMutation) SetManagementCompany(s string) {
	m.management_company = &s
}

// ManagementCompany returns the value of the "management_company" field in the mutation.
func (m *TenderMutation) ManagementCompany() (r string, exists bool) {
	v := m.management_company
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementCompany returns the old "management_company" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldManagementCompany(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementCompany: %w", err)
	}
	return oldValue.ManagementCompany, nil
}

// ClearManagementCompany clears the value of the "management_company" field.
func (m *TenderMutation) ClearManagementCompany() {
	m.management_company = nil
	m.clearedFields[tender.FieldManagementCompany] = struct{}{}
}

// ManagementCompanyCleared returns if the "management_company" field was cleared in this mutation.
func (m *TenderMutation) ManagementCompanyCleared() bool {
	_, ok := m.clearedFields[tender.FieldManagementCompany]
	return ok
}

// ResetManagementCompany resets all changes to the "management_company" field.
func (m *TenderMutation) ResetManagementCompany() {
	m.management_company = nil
	delete(m.clearedFields, tender.FieldManagementCompany)
}

// SetTenderingAgency sets the "tendering_agency" field.
func (m *TenderMutation) SetTenderingAgency(s string) {
	m.tendering_agency = &s
}

// TenderingAgency returns the value of the "tendering_agency" field in the mutation.
func (m *TenderMutation) TenderingAgency() (r string, exists bool) {
	v := m.tendering_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderingAgency returns the old "tendering_agency" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderingAgency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderingAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderingAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderingAgency: %w", err)
	}
	return oldValue.TenderingAgency, nil
}

// ClearTenderingAgency clears the value of the "tendering_agency" field.
func (m *TenderMutation) ClearTenderingAgency() {
	m.tendering_agency = nil
	m.clearedFields[tender.FieldTenderingAgency] = struct{}{}
}

// TenderingAgencyCleared returns if the "tendering_agency" field was cleared in this mutation.
func (m *TenderMutation) TenderingAgencyCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderingAgency]
	return ok
}

// ResetTenderingAgency resets all changes to the "tendering_agency" field.
func (m *TenderMutation) ResetTenderingAgency() {
	m.tendering_agency = nil
	delete(m.clearedFields, tender.FieldTenderingAgency)
}

// SetBiddingDate sets the "bidding_date" field.
func (m *TenderMutation) SetBiddingDate(t time.Time) {
	m.bidding_date = &t
}

// BiddingDate returns the value of the "bidding_date" field in the mutation.
func (m *TenderMutation) BiddingDate() (r time.Time, exists bool) {
	v := m.bidding_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingDate returns the old "bidding_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldBiddingDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingDate: %w", err)
	}
	return oldValue.BiddingDate, nil
}

// ClearBiddingDate clears the value of the "bidding_date" field.
func (m *TenderMutation) ClearBiddingDate() {
	m.bidding_date = nil
	m.clearedFields[tender.FieldBiddingDate] = struct{}{}
}

// BiddingDateCleared returns if the "bidding_date" field was cleared in this mutation.
func (m *TenderMutation) BiddingDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldBiddingDate]
	return ok
}

// ResetBiddingDate resets all changes to the "bidding_date" field.
func (m *TenderMutation) ResetBiddingDate() {
	m.bidding_date = nil
	delete(m.clearedFields, tender.FieldBiddingDate)
}

// SetFacadeConsultant sets the "facade_consultant" field.
func (m *TenderMutation) SetFacadeConsultant(s string) {
	m.facade_consultant = &s
}

// FacadeConsultant returns the value of the "facade_consultant" field in the mutation.
func (m *TenderMutation) FacadeConsultant() (r string, exists bool) {
	v := m.facade_consultant
	if v == nil {
		return
	}
	return *v, true
}

// OldFacadeConsultant returns the old "facade_consultant" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFacadeConsultant(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacadeConsultant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacadeConsultant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacadeConsultant: %w", err)
	}
	return oldValue.FacadeConsultant, nil
}

// ClearFacadeConsultant clears the value of the "facade_consultant" field.
func (m *TenderMutation) ClearFacadeConsultant() {
	m.facade_consultant = nil
	m.clearedFields[tender.FieldFacadeConsultant] = struct{}{}
}

// FacadeConsultantCleared returns if the "facade_consultant" field was cleared in this mutation.
func (m *TenderMutation) FacadeConsultantCleared() bool {
	_, ok := m.clearedFields[tender.FieldFacadeConsultant]
	return ok
}

// ResetFacadeConsultant resets all changes to the "facade_consultant" field.
func (m *TenderMutation) ResetFacadeConsultant() {
	m.facade_consultant = nil
	delete(m.clearedFields, tender.FieldFacadeConsultant)
}

// SetDesignUnit sets the "design_unit" field.
func (m *TenderMutation) SetDesignUnit(s string) {
	m.design_unit = &s
}

// DesignUnit returns the value of the "design_unit" field in the mutation.
func (m *TenderMutation) DesignUnit() (r string, exists bool) {
	v := m.design_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignUnit returns the old "design_unit" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDesignUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignUnit: %w", err)
	}
	return oldValue.DesignUnit, nil
}

// ClearDesignUnit clears the value of the "design_unit" field.
func (m *TenderMutation) ClearDesignUnit() {
	m.design_unit = nil
	m.clearedFields[tender.FieldDesignUnit] = struct{}{}
}

// DesignUnitCleared returns if the "design_unit" field was cleared in this mutation.
func (m *TenderMutation) DesignUnitCleared() bool {
	_, ok := m.clearedFields[tender.FieldDesignUnit]
	return ok
}

// ResetDesignUnit resets all changes to the "design_unit" field.
func (m *TenderMutation) ResetDesignUnit() {
	m.design_unit = nil
	delete(m.clearedFields, tender.FieldDesignUnit)
}

// SetConsultingFirm sets the "consulting_firm" field.
func (m *TenderMutation) SetConsultingFirm(s string) {
	m.consulting_firm = &s
}

// ConsultingFirm returns the value of the "consulting_firm" field in the mutation.
func (m *TenderMutation) ConsultingFirm() (r string, exists bool) {
	v := m.consulting_firm
	if v == nil {
		return
	}
	return *v, true
}

// OldConsultingFirm returns the old "consulting_firm" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldConsultingFirm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsultingFirm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsultingFirm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsultingFirm: %w", err)
	}
	return oldValue.ConsultingFirm, nil
}

// ClearConsultingFirm clears the value of the "consulting_firm" field.
func (m *TenderMutation) ClearConsultingFirm() {
	m.consulting_firm = nil
	m.clearedFields[tender.FieldConsultingFirm] = struct{}{}
}

// ConsultingFirmCleared returns if the "consulting_firm" field was cleared in this mutation.
func (m *TenderMutation) ConsultingFirmCleared() bool {
	_, ok := m.clearedFields[tender.FieldConsultingFirm]
	return ok
}

// ResetConsultingFirm resets all changes to the "consulting_firm" field.
func (m *TenderMutation) ResetConsultingFirm() {
	m.consulting_firm = nil
	delete(m.clearedFields, tender.FieldConsultingFirm)
}

// SetKeyProject sets the "key_project" field.
func (m *TenderMutation) SetKeyProject(b bool) {
	m.key_project = &b
}

// KeyProject returns the value of the "key_project" field in the mutation.
func (m *TenderMutation) KeyProject() (r bool, exists bool) {
	v := m.key_project
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyProject returns the old "key_project" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldKeyProject(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyProject: %w", err)
	}
	return oldValue.KeyProject, nil
}

// ResetKeyProject resets all changes to the "key_project" field.
func (m *TenderMutation) ResetKeyProject() {
	m.key_project = nil
}

// SetTenderCode sets the "tender_code" field.
func (m *TenderMutation) SetTenderCode(s string) {
	m.tender_code = &s
}

// TenderCode returns the value of the "tender_code" field in the mutation.
func (m *TenderMutation) TenderCode() (r string, exists bool) {
	v := m.tender_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderCode returns the old "tender_code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderCode: %w", err)
	}
	return oldValue.TenderCode, nil
}

// ClearTenderCode clears the value of the "tender_code" field.
func (m *TenderMutation) ClearTenderCode() {
	m.tender_code = nil
	m.clearedFields[tender.FieldTenderCode] = struct{}{}
}

// TenderCodeCleared returns if the "tender_code" field was cleared in this mutation.
func (m *TenderMutation) TenderCodeCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderCode]
	return ok
}

// ResetTenderCode resets all changes to the "tender_code" field.
func (m *TenderMutation) ResetTenderCode() {
	m.tender_code = nil
	delete(m.clearedFields, tender.FieldTenderCode)
}

// SetArchitect sets the "architect" field.
func (m *TenderMutation) SetArchitect(s string) {
	m.architect = &s
}

// Architect returns the value of the "architect" field in the mutation.
func (m *TenderMutation) Architect() (r string, exists bool) {
	v := m.architect
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitect returns the old "architect" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldArchitect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitect: %w", err)
	}
	return oldValue.Architect, nil
}

// ClearArchitect clears the value of the "architect" field.
func (m *TenderMutation) ClearArchitect() {
	m.architect = nil
	m.clearedFields[tender.FieldArchitect] = struct{}{}
}

// ArchitectCleared returns if the "architect" field was cleared in this mutation.
func (m *TenderMutation) ArchitectCleared() bool {
	_, ok := m.clearedFields[tender.FieldArchitect]
	return ok
}

// ResetArchitect resets all changes to the "architect" field.
func (m *TenderMutation) ResetArchitect() {
	m.architect = nil
	delete(m.clearedFields, tender.FieldArchitect)
}

// SetTenderClosingDate sets the "tender_closing_date" field.
func (m *TenderMutation) SetTenderClosingDate(s string) {
	m.tender_closing_date = &s
}

// TenderClosingDate returns the value of the "tender_closing_date" field in the mutation.
func (m *TenderMutation) TenderClosingDate() (r string, exists bool) {
	v := m.tender_closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderClosingDate returns the old "tender_closing_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderClosingDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderClosingDate: %w", err)
	}
	return oldValue.TenderClosingDate, nil
}

// ClearTenderClosingDate clears the value of the "tender_closing_date" field.
func (m *TenderMutation) ClearTenderClosingDate() {
	m.tender_closing_date = nil
	m.clearedFields[tender.FieldTenderClosingDate] = struct{}{}
}

// TenderClosingDateCleared returns if the "tender_closing_date" field was cleared in this mutation.
func (m *TenderMutation) TenderClosingDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderClosingDate]
	return ok
}

// ResetTenderClosingDate resets all changes to the "tender_closing_date" field.
func (m *TenderMutation) ResetTenderClosingDate() {
	m.tender_closing_date = nil
	delete(m.clearedFields, tender.FieldTenderClosingDate)
}

// SetConstructionArea sets the "construction_area" field.
func (m *TenderMutation) SetConstructionArea(s string) {
	m.construction_area = &s
}

// ConstructionArea returns the value of the "construction_area" field in the mutation.
func (m *TenderMutation) ConstructionArea() (r string, exists bool) {
	v := m.construction_area
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionArea returns the old "construction_area" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldConstructionArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionArea: %w", err)
	}
	return oldValue.ConstructionArea, nil
}

// ClearConstructionArea clears the value of the "construction_area" field.
func (m *TenderMutation) ClearConstructionArea() {
	m.construction_area = nil
	m.clearedFields[tender.FieldConstructionArea] = struct{}{}
}

// ConstructionAreaCleared returns if the "construction_area" field was cleared in this mutation.
func (m *TenderMutation) ConstructionAreaCleared() bool {
	_, ok := m.clearedFields[tender.FieldConstructionArea]
	return ok
}

// ResetConstructionArea resets all changes to the "construction_area" field.
func (m *TenderMutation) ResetConstructionArea() {
	m.construction_area = nil
	delete(m.clearedFields, tender.FieldConstructionArea)
}

// SetTenderWinDate sets the "tender_win_date" field.
func (m *TenderMutation) SetTenderWinDate(t time.Time) {
	m.tender_win_date = &t
}

// TenderWinDate returns the value of the "tender_win_date" field in the mutation.
func (m *TenderMutation) TenderWinDate() (r time.Time, exists bool) {
	v := m.tender_win_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinDate returns the old "tender_win_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderWinDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinDate: %w", err)
	}
	return oldValue.TenderWinDate, nil
}

// ClearTenderWinDate clears the value of the "tender_win_date" field.
func (m *TenderMutation) ClearTenderWinDate() {
	m.tender_win_date = nil
	m.clearedFields[tender.FieldTenderWinDate] = struct{}{}
}

// TenderWinDateCleared returns if the "tender_win_date" field was cleared in this mutation.
func (m *TenderMutation) TenderWinDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderWinDate]
	return ok
}

// ResetTenderWinDate resets all changes to the "tender_win_date" field.
func (m *TenderMutation) ResetTenderWinDate() {
	m.tender_win_date = nil
	delete(m.clearedFields, tender.FieldTenderWinDate)
}

// SetTenderWinAmount sets the "tender_win_amount" field.
func (m *TenderMutation) SetTenderWinAmount(s string) {
	m.tender_win_amount = &s
}

// TenderWinAmount returns the value of the "tender_win_amount" field in the mutation.
func (m *TenderMutation) TenderWinAmount() (r string, exists bool) {
	v := m.tender_win_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinAmount returns the old "tender_win_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderWinAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinAmount: %w", err)
	}
	return oldValue.TenderWinAmount, nil
}

// ClearTenderWinAmount clears the value of the "tender_win_amount" field.
func (m *TenderMutation) ClearTenderWinAmount() {
	m.tender_win_amount = nil
	m.clearedFields[tender.FieldTenderWinAmount] = struct{}{}
}

// TenderWinAmountCleared returns if the "tender_win_amount" field was cleared in this mutation.
func (m *TenderMutation) TenderWinAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderWinAmount]
	return ok
}

// ResetTenderWinAmount resets all changes to the "tender_win_amount" field.
func (m *TenderMutation) ResetTenderWinAmount() {
	m.tender_win_amount = nil
	delete(m.clearedFields, tender.FieldTenderWinAmount)
}

// SetLastTenderAmount sets the "last_tender_amount" field.
func (m *TenderMutation) SetLastTenderAmount(f float64) {
	m.last_tender_amount = &f
	m.addlast_tender_amount = nil
}

// LastTenderAmount returns the value of the "last_tender_amount" field in the mutation.
func (m *TenderMutation) LastTenderAmount() (r float64, exists bool) {
	v := m.last_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTenderAmount returns the old "last_tender_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldLastTenderAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTenderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTenderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTenderAmount: %w", err)
	}
	return oldValue.LastTenderAmount, nil
}

// AddLastTenderAmount adds f to the "last_tender_amount" field.
func (m *TenderMutation) AddLastTenderAmount(f float64) {
	if m.addlast_tender_amount != nil {
		*m.addlast_tender_amount += f
	} else {
		m.addlast_tender_amount = &f
	}
}

// AddedLastTenderAmount returns the value that was added to the "last_tender_amount" field in this mutation.
func (m *TenderMutation) AddedLastTenderAmount() (r float64, exists bool) {
	v := m.addlast_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastTenderAmount clears the value of the "last_tender_amount" field.
func (m *TenderMutation) ClearLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	m.clearedFields[tender.FieldLastTenderAmount] = struct{}{}
}

// LastTenderAmountCleared returns if the "last_tender_amount" field was cleared in this mutation.
func (m *TenderMutation) LastTenderAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldLastTenderAmount]
	return ok
}

// ResetLastTenderAmount resets all changes to the "last_tender_amount" field.
func (m *TenderMutation) ResetLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	delete(m.clearedFields, tender.FieldLastTenderAmount)
}

// SetAreaID sets the "area_id" field.
func (m *TenderMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *TenderMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAreaID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *TenderMutation) ResetAreaID() {
	m.area = nil
}

// SetProvinceID sets the "province_id" field.
func (m *TenderMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *TenderMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProvinceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *TenderMutation) ResetProvinceID() {
	m.province = nil
}

// SetCityID sets the "city_id" field.
func (m *TenderMutation) SetCityID(x xid.ID) {
	m.city = &x
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *TenderMutation) CityID() (r xid.ID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCityID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *TenderMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[tender.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *TenderMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *TenderMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, tender.FieldCityID)
}

// SetDistrictID sets the "district_id" field.
func (m *TenderMutation) SetDistrictID(x xid.ID) {
	m.district = &x
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *TenderMutation) DistrictID() (r xid.ID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDistrictID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *TenderMutation) ResetDistrictID() {
	m.district = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *TenderMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *TenderMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *TenderMutation) ResetCustomerID() {
	m.customer = nil
}

// SetFinderID sets the "finder_id" field.
func (m *TenderMutation) SetFinderID(x xid.ID) {
	m.finder = &x
}

// FinderID returns the value of the "finder_id" field in the mutation.
func (m *TenderMutation) FinderID() (r xid.ID, exists bool) {
	v := m.finder
	if v == nil {
		return
	}
	return *v, true
}

// OldFinderID returns the old "finder_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFinderID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinderID: %w", err)
	}
	return oldValue.FinderID, nil
}

// ResetFinderID resets all changes to the "finder_id" field.
func (m *TenderMutation) ResetFinderID() {
	m.finder = nil
}

// SetCreatedByID sets the "created_by_id" field.
func (m *TenderMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *TenderMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreatedByID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *TenderMutation) ResetCreatedByID() {
	m.created_by = nil
}

// ClearArea clears the "area" edge to the Area entity.
func (m *TenderMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[tender.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *TenderMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *TenderMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *TenderMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[tender.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *TenderMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *TenderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearFinder clears the "finder" edge to the User entity.
func (m *TenderMutation) ClearFinder() {
	m.clearedfinder = true
	m.clearedFields[tender.FieldFinderID] = struct{}{}
}

// FinderCleared reports if the "finder" edge to the User entity was cleared.
func (m *TenderMutation) FinderCleared() bool {
	return m.clearedfinder
}

// FinderIDs returns the "finder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FinderID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) FinderIDs() (ids []xid.ID) {
	if id := m.finder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFinder resets all changes to the "finder" edge.
func (m *TenderMutation) ResetFinder() {
	m.finder = nil
	m.clearedfinder = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *TenderMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[tender.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *TenderMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *TenderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddFollowingSaleIDs adds the "following_sales" edge to the User entity by ids.
func (m *TenderMutation) AddFollowingSaleIDs(ids ...xid.ID) {
	if m.following_sales == nil {
		m.following_sales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.following_sales[ids[i]] = struct{}{}
	}
}

// ClearFollowingSales clears the "following_sales" edge to the User entity.
func (m *TenderMutation) ClearFollowingSales() {
	m.clearedfollowing_sales = true
}

// FollowingSalesCleared reports if the "following_sales" edge to the User entity was cleared.
func (m *TenderMutation) FollowingSalesCleared() bool {
	return m.clearedfollowing_sales
}

// RemoveFollowingSaleIDs removes the "following_sales" edge to the User entity by IDs.
func (m *TenderMutation) RemoveFollowingSaleIDs(ids ...xid.ID) {
	if m.removedfollowing_sales == nil {
		m.removedfollowing_sales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.following_sales, ids[i])
		m.removedfollowing_sales[ids[i]] = struct{}{}
	}
}

// RemovedFollowingSales returns the removed IDs of the "following_sales" edge to the User entity.
func (m *TenderMutation) RemovedFollowingSalesIDs() (ids []xid.ID) {
	for id := range m.removedfollowing_sales {
		ids = append(ids, id)
	}
	return
}

// FollowingSalesIDs returns the "following_sales" edge IDs in the mutation.
func (m *TenderMutation) FollowingSalesIDs() (ids []xid.ID) {
	for id := range m.following_sales {
		ids = append(ids, id)
	}
	return
}

// ResetFollowingSales resets all changes to the "following_sales" edge.
func (m *TenderMutation) ResetFollowingSales() {
	m.following_sales = nil
	m.clearedfollowing_sales = false
	m.removedfollowing_sales = nil
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *TenderMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[tender.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *TenderMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *TenderMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *TenderMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[tender.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *TenderMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CityIDs() (ids []xid.ID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *TenderMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *TenderMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[tender.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *TenderMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) DistrictIDs() (ids []xid.ID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *TenderMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *TenderMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *TenderMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *TenderMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *TenderMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *TenderMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *TenderMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *TenderMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// Where appends a list predicates to the TenderMutation builder.
func (m *TenderMutation) Where(ps ...predicate.Tender) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tender, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tender).
func (m *TenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenderMutation) Fields() []string {
	fields := make([]string, 0, 60)
	if m.created_at != nil {
		fields = append(fields, tender.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tender.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, tender.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, tender.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tender.FieldName)
	}
	if m.estimated_amount != nil {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.tender_date != nil {
		fields = append(fields, tender.FieldTenderDate)
	}
	if m.discovery_date != nil {
		fields = append(fields, tender.FieldDiscoveryDate)
	}
	if m.address != nil {
		fields = append(fields, tender.FieldAddress)
	}
	if m.full_address != nil {
		fields = append(fields, tender.FieldFullAddress)
	}
	if m.contractor != nil {
		fields = append(fields, tender.FieldContractor)
	}
	if m.size_and_value_rating != nil {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.size_and_value_rating_overview != nil {
		fields = append(fields, tender.FieldSizeAndValueRatingOverview)
	}
	if m.credit_and_payment_rating != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.credit_and_payment_rating_overview != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRatingOverview)
	}
	if m.time_limit_rating != nil {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.time_limit_rating_overview != nil {
		fields = append(fields, tender.FieldTimeLimitRatingOverview)
	}
	if m.customer_relationship_rating != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.customer_relationship_rating_overview != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRatingOverview)
	}
	if m.competitive_partnership_rating != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.competitive_partnership_rating_overview != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRatingOverview)
	}
	if m.prepare_to_bid != nil {
		fields = append(fields, tender.FieldPrepareToBid)
	}
	if m.project_code != nil {
		fields = append(fields, tender.FieldProjectCode)
	}
	if m.project_definition != nil {
		fields = append(fields, tender.FieldProjectDefinition)
	}
	if m.estimated_project_start_date != nil {
		fields = append(fields, tender.FieldEstimatedProjectStartDate)
	}
	if m.estimated_project_end_date != nil {
		fields = append(fields, tender.FieldEstimatedProjectEndDate)
	}
	if m.project_type != nil {
		fields = append(fields, tender.FieldProjectType)
	}
	if m.attachements != nil {
		fields = append(fields, tender.FieldAttachements)
	}
	if m.geo_coordinate != nil {
		fields = append(fields, tender.FieldGeoCoordinate)
	}
	if m.geo_bounds != nil {
		fields = append(fields, tender.FieldGeoBounds)
	}
	if m.remark != nil {
		fields = append(fields, tender.FieldRemark)
	}
	if m.images != nil {
		fields = append(fields, tender.FieldImages)
	}
	if m.tender_situations != nil {
		fields = append(fields, tender.FieldTenderSituations)
	}
	if m.owner_situations != nil {
		fields = append(fields, tender.FieldOwnerSituations)
	}
	if m.bidding_instructions != nil {
		fields = append(fields, tender.FieldBiddingInstructions)
	}
	if m.competitor_situations != nil {
		fields = append(fields, tender.FieldCompetitorSituations)
	}
	if m.cost_engineer != nil {
		fields = append(fields, tender.FieldCostEngineer)
	}
	if m.tender_form != nil {
		fields = append(fields, tender.FieldTenderForm)
	}
	if m.contract_form != nil {
		fields = append(fields, tender.FieldContractForm)
	}
	if m.management_company != nil {
		fields = append(fields, tender.FieldManagementCompany)
	}
	if m.tendering_agency != nil {
		fields = append(fields, tender.FieldTenderingAgency)
	}
	if m.bidding_date != nil {
		fields = append(fields, tender.FieldBiddingDate)
	}
	if m.facade_consultant != nil {
		fields = append(fields, tender.FieldFacadeConsultant)
	}
	if m.design_unit != nil {
		fields = append(fields, tender.FieldDesignUnit)
	}
	if m.consulting_firm != nil {
		fields = append(fields, tender.FieldConsultingFirm)
	}
	if m.key_project != nil {
		fields = append(fields, tender.FieldKeyProject)
	}
	if m.tender_code != nil {
		fields = append(fields, tender.FieldTenderCode)
	}
	if m.architect != nil {
		fields = append(fields, tender.FieldArchitect)
	}
	if m.tender_closing_date != nil {
		fields = append(fields, tender.FieldTenderClosingDate)
	}
	if m.construction_area != nil {
		fields = append(fields, tender.FieldConstructionArea)
	}
	if m.tender_win_date != nil {
		fields = append(fields, tender.FieldTenderWinDate)
	}
	if m.tender_win_amount != nil {
		fields = append(fields, tender.FieldTenderWinAmount)
	}
	if m.last_tender_amount != nil {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	if m.area != nil {
		fields = append(fields, tender.FieldAreaID)
	}
	if m.province != nil {
		fields = append(fields, tender.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, tender.FieldCityID)
	}
	if m.district != nil {
		fields = append(fields, tender.FieldDistrictID)
	}
	if m.customer != nil {
		fields = append(fields, tender.FieldCustomerID)
	}
	if m.finder != nil {
		fields = append(fields, tender.FieldFinderID)
	}
	if m.created_by != nil {
		fields = append(fields, tender.FieldCreatedByID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tender.FieldCreatedAt:
		return m.CreatedAt()
	case tender.FieldUpdatedAt:
		return m.UpdatedAt()
	case tender.FieldCode:
		return m.Code()
	case tender.FieldStatus:
		return m.Status()
	case tender.FieldName:
		return m.Name()
	case tender.FieldEstimatedAmount:
		return m.EstimatedAmount()
	case tender.FieldTenderDate:
		return m.TenderDate()
	case tender.FieldDiscoveryDate:
		return m.DiscoveryDate()
	case tender.FieldAddress:
		return m.Address()
	case tender.FieldFullAddress:
		return m.FullAddress()
	case tender.FieldContractor:
		return m.Contractor()
	case tender.FieldSizeAndValueRating:
		return m.SizeAndValueRating()
	case tender.FieldSizeAndValueRatingOverview:
		return m.SizeAndValueRatingOverview()
	case tender.FieldCreditAndPaymentRating:
		return m.CreditAndPaymentRating()
	case tender.FieldCreditAndPaymentRatingOverview:
		return m.CreditAndPaymentRatingOverview()
	case tender.FieldTimeLimitRating:
		return m.TimeLimitRating()
	case tender.FieldTimeLimitRatingOverview:
		return m.TimeLimitRatingOverview()
	case tender.FieldCustomerRelationshipRating:
		return m.CustomerRelationshipRating()
	case tender.FieldCustomerRelationshipRatingOverview:
		return m.CustomerRelationshipRatingOverview()
	case tender.FieldCompetitivePartnershipRating:
		return m.CompetitivePartnershipRating()
	case tender.FieldCompetitivePartnershipRatingOverview:
		return m.CompetitivePartnershipRatingOverview()
	case tender.FieldPrepareToBid:
		return m.PrepareToBid()
	case tender.FieldProjectCode:
		return m.ProjectCode()
	case tender.FieldProjectDefinition:
		return m.ProjectDefinition()
	case tender.FieldEstimatedProjectStartDate:
		return m.EstimatedProjectStartDate()
	case tender.FieldEstimatedProjectEndDate:
		return m.EstimatedProjectEndDate()
	case tender.FieldProjectType:
		return m.ProjectType()
	case tender.FieldAttachements:
		return m.Attachements()
	case tender.FieldGeoCoordinate:
		return m.GeoCoordinate()
	case tender.FieldGeoBounds:
		return m.GeoBounds()
	case tender.FieldRemark:
		return m.Remark()
	case tender.FieldImages:
		return m.Images()
	case tender.FieldTenderSituations:
		return m.TenderSituations()
	case tender.FieldOwnerSituations:
		return m.OwnerSituations()
	case tender.FieldBiddingInstructions:
		return m.BiddingInstructions()
	case tender.FieldCompetitorSituations:
		return m.CompetitorSituations()
	case tender.FieldCostEngineer:
		return m.CostEngineer()
	case tender.FieldTenderForm:
		return m.TenderForm()
	case tender.FieldContractForm:
		return m.ContractForm()
	case tender.FieldManagementCompany:
		return m.ManagementCompany()
	case tender.FieldTenderingAgency:
		return m.TenderingAgency()
	case tender.FieldBiddingDate:
		return m.BiddingDate()
	case tender.FieldFacadeConsultant:
		return m.FacadeConsultant()
	case tender.FieldDesignUnit:
		return m.DesignUnit()
	case tender.FieldConsultingFirm:
		return m.ConsultingFirm()
	case tender.FieldKeyProject:
		return m.KeyProject()
	case tender.FieldTenderCode:
		return m.TenderCode()
	case tender.FieldArchitect:
		return m.Architect()
	case tender.FieldTenderClosingDate:
		return m.TenderClosingDate()
	case tender.FieldConstructionArea:
		return m.ConstructionArea()
	case tender.FieldTenderWinDate:
		return m.TenderWinDate()
	case tender.FieldTenderWinAmount:
		return m.TenderWinAmount()
	case tender.FieldLastTenderAmount:
		return m.LastTenderAmount()
	case tender.FieldAreaID:
		return m.AreaID()
	case tender.FieldProvinceID:
		return m.ProvinceID()
	case tender.FieldCityID:
		return m.CityID()
	case tender.FieldDistrictID:
		return m.DistrictID()
	case tender.FieldCustomerID:
		return m.CustomerID()
	case tender.FieldFinderID:
		return m.FinderID()
	case tender.FieldCreatedByID:
		return m.CreatedByID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tender.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tender.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tender.FieldCode:
		return m.OldCode(ctx)
	case tender.FieldStatus:
		return m.OldStatus(ctx)
	case tender.FieldName:
		return m.OldName(ctx)
	case tender.FieldEstimatedAmount:
		return m.OldEstimatedAmount(ctx)
	case tender.FieldTenderDate:
		return m.OldTenderDate(ctx)
	case tender.FieldDiscoveryDate:
		return m.OldDiscoveryDate(ctx)
	case tender.FieldAddress:
		return m.OldAddress(ctx)
	case tender.FieldFullAddress:
		return m.OldFullAddress(ctx)
	case tender.FieldContractor:
		return m.OldContractor(ctx)
	case tender.FieldSizeAndValueRating:
		return m.OldSizeAndValueRating(ctx)
	case tender.FieldSizeAndValueRatingOverview:
		return m.OldSizeAndValueRatingOverview(ctx)
	case tender.FieldCreditAndPaymentRating:
		return m.OldCreditAndPaymentRating(ctx)
	case tender.FieldCreditAndPaymentRatingOverview:
		return m.OldCreditAndPaymentRatingOverview(ctx)
	case tender.FieldTimeLimitRating:
		return m.OldTimeLimitRating(ctx)
	case tender.FieldTimeLimitRatingOverview:
		return m.OldTimeLimitRatingOverview(ctx)
	case tender.FieldCustomerRelationshipRating:
		return m.OldCustomerRelationshipRating(ctx)
	case tender.FieldCustomerRelationshipRatingOverview:
		return m.OldCustomerRelationshipRatingOverview(ctx)
	case tender.FieldCompetitivePartnershipRating:
		return m.OldCompetitivePartnershipRating(ctx)
	case tender.FieldCompetitivePartnershipRatingOverview:
		return m.OldCompetitivePartnershipRatingOverview(ctx)
	case tender.FieldPrepareToBid:
		return m.OldPrepareToBid(ctx)
	case tender.FieldProjectCode:
		return m.OldProjectCode(ctx)
	case tender.FieldProjectDefinition:
		return m.OldProjectDefinition(ctx)
	case tender.FieldEstimatedProjectStartDate:
		return m.OldEstimatedProjectStartDate(ctx)
	case tender.FieldEstimatedProjectEndDate:
		return m.OldEstimatedProjectEndDate(ctx)
	case tender.FieldProjectType:
		return m.OldProjectType(ctx)
	case tender.FieldAttachements:
		return m.OldAttachements(ctx)
	case tender.FieldGeoCoordinate:
		return m.OldGeoCoordinate(ctx)
	case tender.FieldGeoBounds:
		return m.OldGeoBounds(ctx)
	case tender.FieldRemark:
		return m.OldRemark(ctx)
	case tender.FieldImages:
		return m.OldImages(ctx)
	case tender.FieldTenderSituations:
		return m.OldTenderSituations(ctx)
	case tender.FieldOwnerSituations:
		return m.OldOwnerSituations(ctx)
	case tender.FieldBiddingInstructions:
		return m.OldBiddingInstructions(ctx)
	case tender.FieldCompetitorSituations:
		return m.OldCompetitorSituations(ctx)
	case tender.FieldCostEngineer:
		return m.OldCostEngineer(ctx)
	case tender.FieldTenderForm:
		return m.OldTenderForm(ctx)
	case tender.FieldContractForm:
		return m.OldContractForm(ctx)
	case tender.FieldManagementCompany:
		return m.OldManagementCompany(ctx)
	case tender.FieldTenderingAgency:
		return m.OldTenderingAgency(ctx)
	case tender.FieldBiddingDate:
		return m.OldBiddingDate(ctx)
	case tender.FieldFacadeConsultant:
		return m.OldFacadeConsultant(ctx)
	case tender.FieldDesignUnit:
		return m.OldDesignUnit(ctx)
	case tender.FieldConsultingFirm:
		return m.OldConsultingFirm(ctx)
	case tender.FieldKeyProject:
		return m.OldKeyProject(ctx)
	case tender.FieldTenderCode:
		return m.OldTenderCode(ctx)
	case tender.FieldArchitect:
		return m.OldArchitect(ctx)
	case tender.FieldTenderClosingDate:
		return m.OldTenderClosingDate(ctx)
	case tender.FieldConstructionArea:
		return m.OldConstructionArea(ctx)
	case tender.FieldTenderWinDate:
		return m.OldTenderWinDate(ctx)
	case tender.FieldTenderWinAmount:
		return m.OldTenderWinAmount(ctx)
	case tender.FieldLastTenderAmount:
		return m.OldLastTenderAmount(ctx)
	case tender.FieldAreaID:
		return m.OldAreaID(ctx)
	case tender.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case tender.FieldCityID:
		return m.OldCityID(ctx)
	case tender.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case tender.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case tender.FieldFinderID:
		return m.OldFinderID(ctx)
	case tender.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	}
	return nil, fmt.Errorf("unknown Tender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tender.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tender.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tender.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tender.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tender.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tender.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedAmount(v)
		return nil
	case tender.FieldTenderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderDate(v)
		return nil
	case tender.FieldDiscoveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryDate(v)
		return nil
	case tender.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tender.FieldFullAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullAddress(v)
		return nil
	case tender.FieldContractor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractor(v)
		return nil
	case tender.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRating(v)
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRatingOverview(v)
		return nil
	case tender.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRating(v)
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRatingOverview(v)
		return nil
	case tender.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRating(v)
		return nil
	case tender.FieldTimeLimitRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRatingOverview(v)
		return nil
	case tender.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRating(v)
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRatingOverview(v)
		return nil
	case tender.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRating(v)
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRatingOverview(v)
		return nil
	case tender.FieldPrepareToBid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepareToBid(v)
		return nil
	case tender.FieldProjectCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectCode(v)
		return nil
	case tender.FieldProjectDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectDefinition(v)
		return nil
	case tender.FieldEstimatedProjectStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectStartDate(v)
		return nil
	case tender.FieldEstimatedProjectEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectEndDate(v)
		return nil
	case tender.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case tender.FieldAttachements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachements(v)
		return nil
	case tender.FieldGeoCoordinate:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoCoordinate(v)
		return nil
	case tender.FieldGeoBounds:
		v, ok := value.([][]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoBounds(v)
		return nil
	case tender.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case tender.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case tender.FieldTenderSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderSituations(v)
		return nil
	case tender.FieldOwnerSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSituations(v)
		return nil
	case tender.FieldBiddingInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingInstructions(v)
		return nil
	case tender.FieldCompetitorSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitorSituations(v)
		return nil
	case tender.FieldCostEngineer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostEngineer(v)
		return nil
	case tender.FieldTenderForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderForm(v)
		return nil
	case tender.FieldContractForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractForm(v)
		return nil
	case tender.FieldManagementCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementCompany(v)
		return nil
	case tender.FieldTenderingAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderingAgency(v)
		return nil
	case tender.FieldBiddingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingDate(v)
		return nil
	case tender.FieldFacadeConsultant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacadeConsultant(v)
		return nil
	case tender.FieldDesignUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignUnit(v)
		return nil
	case tender.FieldConsultingFirm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsultingFirm(v)
		return nil
	case tender.FieldKeyProject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyProject(v)
		return nil
	case tender.FieldTenderCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderCode(v)
		return nil
	case tender.FieldArchitect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitect(v)
		return nil
	case tender.FieldTenderClosingDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderClosingDate(v)
		return nil
	case tender.FieldConstructionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionArea(v)
		return nil
	case tender.FieldTenderWinDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinDate(v)
		return nil
	case tender.FieldTenderWinAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinAmount(v)
		return nil
	case tender.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTenderAmount(v)
		return nil
	case tender.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case tender.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case tender.FieldCityID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case tender.FieldDistrictID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case tender.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case tender.FieldFinderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinderID(v)
		return nil
	case tender.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	}
	return fmt.Errorf("unknown Tender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tender.FieldStatus)
	}
	if m.addestimated_amount != nil {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.addsize_and_value_rating != nil {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.addcredit_and_payment_rating != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.addtime_limit_rating != nil {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.addcustomer_relationship_rating != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.addcompetitive_partnership_rating != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.addlast_tender_amount != nil {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tender.FieldStatus:
		return m.AddedStatus()
	case tender.FieldEstimatedAmount:
		return m.AddedEstimatedAmount()
	case tender.FieldSizeAndValueRating:
		return m.AddedSizeAndValueRating()
	case tender.FieldCreditAndPaymentRating:
		return m.AddedCreditAndPaymentRating()
	case tender.FieldTimeLimitRating:
		return m.AddedTimeLimitRating()
	case tender.FieldCustomerRelationshipRating:
		return m.AddedCustomerRelationshipRating()
	case tender.FieldCompetitivePartnershipRating:
		return m.AddedCompetitivePartnershipRating()
	case tender.FieldLastTenderAmount:
		return m.AddedLastTenderAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tender.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tender.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedAmount(v)
		return nil
	case tender.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeAndValueRating(v)
		return nil
	case tender.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAndPaymentRating(v)
		return nil
	case tender.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeLimitRating(v)
		return nil
	case tender.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerRelationshipRating(v)
		return nil
	case tender.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompetitivePartnershipRating(v)
		return nil
	case tender.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastTenderAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Tender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tender.FieldEstimatedAmount) {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.FieldCleared(tender.FieldTenderDate) {
		fields = append(fields, tender.FieldTenderDate)
	}
	if m.FieldCleared(tender.FieldAddress) {
		fields = append(fields, tender.FieldAddress)
	}
	if m.FieldCleared(tender.FieldFullAddress) {
		fields = append(fields, tender.FieldFullAddress)
	}
	if m.FieldCleared(tender.FieldContractor) {
		fields = append(fields, tender.FieldContractor)
	}
	if m.FieldCleared(tender.FieldSizeAndValueRating) {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.FieldCleared(tender.FieldSizeAndValueRatingOverview) {
		fields = append(fields, tender.FieldSizeAndValueRatingOverview)
	}
	if m.FieldCleared(tender.FieldCreditAndPaymentRating) {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.FieldCleared(tender.FieldCreditAndPaymentRatingOverview) {
		fields = append(fields, tender.FieldCreditAndPaymentRatingOverview)
	}
	if m.FieldCleared(tender.FieldTimeLimitRating) {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.FieldCleared(tender.FieldTimeLimitRatingOverview) {
		fields = append(fields, tender.FieldTimeLimitRatingOverview)
	}
	if m.FieldCleared(tender.FieldCustomerRelationshipRating) {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.FieldCleared(tender.FieldCustomerRelationshipRatingOverview) {
		fields = append(fields, tender.FieldCustomerRelationshipRatingOverview)
	}
	if m.FieldCleared(tender.FieldCompetitivePartnershipRating) {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.FieldCleared(tender.FieldCompetitivePartnershipRatingOverview) {
		fields = append(fields, tender.FieldCompetitivePartnershipRatingOverview)
	}
	if m.FieldCleared(tender.FieldProjectCode) {
		fields = append(fields, tender.FieldProjectCode)
	}
	if m.FieldCleared(tender.FieldProjectDefinition) {
		fields = append(fields, tender.FieldProjectDefinition)
	}
	if m.FieldCleared(tender.FieldEstimatedProjectStartDate) {
		fields = append(fields, tender.FieldEstimatedProjectStartDate)
	}
	if m.FieldCleared(tender.FieldEstimatedProjectEndDate) {
		fields = append(fields, tender.FieldEstimatedProjectEndDate)
	}
	if m.FieldCleared(tender.FieldProjectType) {
		fields = append(fields, tender.FieldProjectType)
	}
	if m.FieldCleared(tender.FieldAttachements) {
		fields = append(fields, tender.FieldAttachements)
	}
	if m.FieldCleared(tender.FieldGeoCoordinate) {
		fields = append(fields, tender.FieldGeoCoordinate)
	}
	if m.FieldCleared(tender.FieldGeoBounds) {
		fields = append(fields, tender.FieldGeoBounds)
	}
	if m.FieldCleared(tender.FieldRemark) {
		fields = append(fields, tender.FieldRemark)
	}
	if m.FieldCleared(tender.FieldImages) {
		fields = append(fields, tender.FieldImages)
	}
	if m.FieldCleared(tender.FieldTenderSituations) {
		fields = append(fields, tender.FieldTenderSituations)
	}
	if m.FieldCleared(tender.FieldOwnerSituations) {
		fields = append(fields, tender.FieldOwnerSituations)
	}
	if m.FieldCleared(tender.FieldBiddingInstructions) {
		fields = append(fields, tender.FieldBiddingInstructions)
	}
	if m.FieldCleared(tender.FieldCompetitorSituations) {
		fields = append(fields, tender.FieldCompetitorSituations)
	}
	if m.FieldCleared(tender.FieldCostEngineer) {
		fields = append(fields, tender.FieldCostEngineer)
	}
	if m.FieldCleared(tender.FieldTenderForm) {
		fields = append(fields, tender.FieldTenderForm)
	}
	if m.FieldCleared(tender.FieldContractForm) {
		fields = append(fields, tender.FieldContractForm)
	}
	if m.FieldCleared(tender.FieldManagementCompany) {
		fields = append(fields, tender.FieldManagementCompany)
	}
	if m.FieldCleared(tender.FieldTenderingAgency) {
		fields = append(fields, tender.FieldTenderingAgency)
	}
	if m.FieldCleared(tender.FieldBiddingDate) {
		fields = append(fields, tender.FieldBiddingDate)
	}
	if m.FieldCleared(tender.FieldFacadeConsultant) {
		fields = append(fields, tender.FieldFacadeConsultant)
	}
	if m.FieldCleared(tender.FieldDesignUnit) {
		fields = append(fields, tender.FieldDesignUnit)
	}
	if m.FieldCleared(tender.FieldConsultingFirm) {
		fields = append(fields, tender.FieldConsultingFirm)
	}
	if m.FieldCleared(tender.FieldTenderCode) {
		fields = append(fields, tender.FieldTenderCode)
	}
	if m.FieldCleared(tender.FieldArchitect) {
		fields = append(fields, tender.FieldArchitect)
	}
	if m.FieldCleared(tender.FieldTenderClosingDate) {
		fields = append(fields, tender.FieldTenderClosingDate)
	}
	if m.FieldCleared(tender.FieldConstructionArea) {
		fields = append(fields, tender.FieldConstructionArea)
	}
	if m.FieldCleared(tender.FieldTenderWinDate) {
		fields = append(fields, tender.FieldTenderWinDate)
	}
	if m.FieldCleared(tender.FieldTenderWinAmount) {
		fields = append(fields, tender.FieldTenderWinAmount)
	}
	if m.FieldCleared(tender.FieldLastTenderAmount) {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	if m.FieldCleared(tender.FieldCityID) {
		fields = append(fields, tender.FieldCityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenderMutation) ClearField(name string) error {
	switch name {
	case tender.FieldEstimatedAmount:
		m.ClearEstimatedAmount()
		return nil
	case tender.FieldTenderDate:
		m.ClearTenderDate()
		return nil
	case tender.FieldAddress:
		m.ClearAddress()
		return nil
	case tender.FieldFullAddress:
		m.ClearFullAddress()
		return nil
	case tender.FieldContractor:
		m.ClearContractor()
		return nil
	case tender.FieldSizeAndValueRating:
		m.ClearSizeAndValueRating()
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		m.ClearSizeAndValueRatingOverview()
		return nil
	case tender.FieldCreditAndPaymentRating:
		m.ClearCreditAndPaymentRating()
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		m.ClearCreditAndPaymentRatingOverview()
		return nil
	case tender.FieldTimeLimitRating:
		m.ClearTimeLimitRating()
		return nil
	case tender.FieldTimeLimitRatingOverview:
		m.ClearTimeLimitRatingOverview()
		return nil
	case tender.FieldCustomerRelationshipRating:
		m.ClearCustomerRelationshipRating()
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		m.ClearCustomerRelationshipRatingOverview()
		return nil
	case tender.FieldCompetitivePartnershipRating:
		m.ClearCompetitivePartnershipRating()
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		m.ClearCompetitivePartnershipRatingOverview()
		return nil
	case tender.FieldProjectCode:
		m.ClearProjectCode()
		return nil
	case tender.FieldProjectDefinition:
		m.ClearProjectDefinition()
		return nil
	case tender.FieldEstimatedProjectStartDate:
		m.ClearEstimatedProjectStartDate()
		return nil
	case tender.FieldEstimatedProjectEndDate:
		m.ClearEstimatedProjectEndDate()
		return nil
	case tender.FieldProjectType:
		m.ClearProjectType()
		return nil
	case tender.FieldAttachements:
		m.ClearAttachements()
		return nil
	case tender.FieldGeoCoordinate:
		m.ClearGeoCoordinate()
		return nil
	case tender.FieldGeoBounds:
		m.ClearGeoBounds()
		return nil
	case tender.FieldRemark:
		m.ClearRemark()
		return nil
	case tender.FieldImages:
		m.ClearImages()
		return nil
	case tender.FieldTenderSituations:
		m.ClearTenderSituations()
		return nil
	case tender.FieldOwnerSituations:
		m.ClearOwnerSituations()
		return nil
	case tender.FieldBiddingInstructions:
		m.ClearBiddingInstructions()
		return nil
	case tender.FieldCompetitorSituations:
		m.ClearCompetitorSituations()
		return nil
	case tender.FieldCostEngineer:
		m.ClearCostEngineer()
		return nil
	case tender.FieldTenderForm:
		m.ClearTenderForm()
		return nil
	case tender.FieldContractForm:
		m.ClearContractForm()
		return nil
	case tender.FieldManagementCompany:
		m.ClearManagementCompany()
		return nil
	case tender.FieldTenderingAgency:
		m.ClearTenderingAgency()
		return nil
	case tender.FieldBiddingDate:
		m.ClearBiddingDate()
		return nil
	case tender.FieldFacadeConsultant:
		m.ClearFacadeConsultant()
		return nil
	case tender.FieldDesignUnit:
		m.ClearDesignUnit()
		return nil
	case tender.FieldConsultingFirm:
		m.ClearConsultingFirm()
		return nil
	case tender.FieldTenderCode:
		m.ClearTenderCode()
		return nil
	case tender.FieldArchitect:
		m.ClearArchitect()
		return nil
	case tender.FieldTenderClosingDate:
		m.ClearTenderClosingDate()
		return nil
	case tender.FieldConstructionArea:
		m.ClearConstructionArea()
		return nil
	case tender.FieldTenderWinDate:
		m.ClearTenderWinDate()
		return nil
	case tender.FieldTenderWinAmount:
		m.ClearTenderWinAmount()
		return nil
	case tender.FieldLastTenderAmount:
		m.ClearLastTenderAmount()
		return nil
	case tender.FieldCityID:
		m.ClearCityID()
		return nil
	}
	return fmt.Errorf("unknown Tender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenderMutation) ResetField(name string) error {
	switch name {
	case tender.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tender.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tender.FieldCode:
		m.ResetCode()
		return nil
	case tender.FieldStatus:
		m.ResetStatus()
		return nil
	case tender.FieldName:
		m.ResetName()
		return nil
	case tender.FieldEstimatedAmount:
		m.ResetEstimatedAmount()
		return nil
	case tender.FieldTenderDate:
		m.ResetTenderDate()
		return nil
	case tender.FieldDiscoveryDate:
		m.ResetDiscoveryDate()
		return nil
	case tender.FieldAddress:
		m.ResetAddress()
		return nil
	case tender.FieldFullAddress:
		m.ResetFullAddress()
		return nil
	case tender.FieldContractor:
		m.ResetContractor()
		return nil
	case tender.FieldSizeAndValueRating:
		m.ResetSizeAndValueRating()
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		m.ResetSizeAndValueRatingOverview()
		return nil
	case tender.FieldCreditAndPaymentRating:
		m.ResetCreditAndPaymentRating()
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		m.ResetCreditAndPaymentRatingOverview()
		return nil
	case tender.FieldTimeLimitRating:
		m.ResetTimeLimitRating()
		return nil
	case tender.FieldTimeLimitRatingOverview:
		m.ResetTimeLimitRatingOverview()
		return nil
	case tender.FieldCustomerRelationshipRating:
		m.ResetCustomerRelationshipRating()
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		m.ResetCustomerRelationshipRatingOverview()
		return nil
	case tender.FieldCompetitivePartnershipRating:
		m.ResetCompetitivePartnershipRating()
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		m.ResetCompetitivePartnershipRatingOverview()
		return nil
	case tender.FieldPrepareToBid:
		m.ResetPrepareToBid()
		return nil
	case tender.FieldProjectCode:
		m.ResetProjectCode()
		return nil
	case tender.FieldProjectDefinition:
		m.ResetProjectDefinition()
		return nil
	case tender.FieldEstimatedProjectStartDate:
		m.ResetEstimatedProjectStartDate()
		return nil
	case tender.FieldEstimatedProjectEndDate:
		m.ResetEstimatedProjectEndDate()
		return nil
	case tender.FieldProjectType:
		m.ResetProjectType()
		return nil
	case tender.FieldAttachements:
		m.ResetAttachements()
		return nil
	case tender.FieldGeoCoordinate:
		m.ResetGeoCoordinate()
		return nil
	case tender.FieldGeoBounds:
		m.ResetGeoBounds()
		return nil
	case tender.FieldRemark:
		m.ResetRemark()
		return nil
	case tender.FieldImages:
		m.ResetImages()
		return nil
	case tender.FieldTenderSituations:
		m.ResetTenderSituations()
		return nil
	case tender.FieldOwnerSituations:
		m.ResetOwnerSituations()
		return nil
	case tender.FieldBiddingInstructions:
		m.ResetBiddingInstructions()
		return nil
	case tender.FieldCompetitorSituations:
		m.ResetCompetitorSituations()
		return nil
	case tender.FieldCostEngineer:
		m.ResetCostEngineer()
		return nil
	case tender.FieldTenderForm:
		m.ResetTenderForm()
		return nil
	case tender.FieldContractForm:
		m.ResetContractForm()
		return nil
	case tender.FieldManagementCompany:
		m.ResetManagementCompany()
		return nil
	case tender.FieldTenderingAgency:
		m.ResetTenderingAgency()
		return nil
	case tender.FieldBiddingDate:
		m.ResetBiddingDate()
		return nil
	case tender.FieldFacadeConsultant:
		m.ResetFacadeConsultant()
		return nil
	case tender.FieldDesignUnit:
		m.ResetDesignUnit()
		return nil
	case tender.FieldConsultingFirm:
		m.ResetConsultingFirm()
		return nil
	case tender.FieldKeyProject:
		m.ResetKeyProject()
		return nil
	case tender.FieldTenderCode:
		m.ResetTenderCode()
		return nil
	case tender.FieldArchitect:
		m.ResetArchitect()
		return nil
	case tender.FieldTenderClosingDate:
		m.ResetTenderClosingDate()
		return nil
	case tender.FieldConstructionArea:
		m.ResetConstructionArea()
		return nil
	case tender.FieldTenderWinDate:
		m.ResetTenderWinDate()
		return nil
	case tender.FieldTenderWinAmount:
		m.ResetTenderWinAmount()
		return nil
	case tender.FieldLastTenderAmount:
		m.ResetLastTenderAmount()
		return nil
	case tender.FieldAreaID:
		m.ResetAreaID()
		return nil
	case tender.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case tender.FieldCityID:
		m.ResetCityID()
		return nil
	case tender.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case tender.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case tender.FieldFinderID:
		m.ResetFinderID()
		return nil
	case tender.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	}
	return fmt.Errorf("unknown Tender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.area != nil {
		edges = append(edges, tender.EdgeArea)
	}
	if m.customer != nil {
		edges = append(edges, tender.EdgeCustomer)
	}
	if m.finder != nil {
		edges = append(edges, tender.EdgeFinder)
	}
	if m.created_by != nil {
		edges = append(edges, tender.EdgeCreatedBy)
	}
	if m.following_sales != nil {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.province != nil {
		edges = append(edges, tender.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, tender.EdgeCity)
	}
	if m.district != nil {
		edges = append(edges, tender.EdgeDistrict)
	}
	if m.visit_records != nil {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tender.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeFinder:
		if id := m.finder; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeFollowingSales:
		ids := make([]ent.Value, 0, len(m.following_sales))
		for id := range m.following_sales {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedfollowing_sales != nil {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tender.EdgeFollowingSales:
		ids := make([]ent.Value, 0, len(m.removedfollowing_sales))
		for id := range m.removedfollowing_sales {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedarea {
		edges = append(edges, tender.EdgeArea)
	}
	if m.clearedcustomer {
		edges = append(edges, tender.EdgeCustomer)
	}
	if m.clearedfinder {
		edges = append(edges, tender.EdgeFinder)
	}
	if m.clearedcreated_by {
		edges = append(edges, tender.EdgeCreatedBy)
	}
	if m.clearedfollowing_sales {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.clearedprovince {
		edges = append(edges, tender.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, tender.EdgeCity)
	}
	if m.cleareddistrict {
		edges = append(edges, tender.EdgeDistrict)
	}
	if m.clearedvisit_records {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenderMutation) EdgeCleared(name string) bool {
	switch name {
	case tender.EdgeArea:
		return m.clearedarea
	case tender.EdgeCustomer:
		return m.clearedcustomer
	case tender.EdgeFinder:
		return m.clearedfinder
	case tender.EdgeCreatedBy:
		return m.clearedcreated_by
	case tender.EdgeFollowingSales:
		return m.clearedfollowing_sales
	case tender.EdgeProvince:
		return m.clearedprovince
	case tender.EdgeCity:
		return m.clearedcity
	case tender.EdgeDistrict:
		return m.cleareddistrict
	case tender.EdgeVisitRecords:
		return m.clearedvisit_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenderMutation) ClearEdge(name string) error {
	switch name {
	case tender.EdgeArea:
		m.ClearArea()
		return nil
	case tender.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case tender.EdgeFinder:
		m.ClearFinder()
		return nil
	case tender.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tender.EdgeProvince:
		m.ClearProvince()
		return nil
	case tender.EdgeCity:
		m.ClearCity()
		return nil
	case tender.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Tender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenderMutation) ResetEdge(name string) error {
	switch name {
	case tender.EdgeArea:
		m.ResetArea()
		return nil
	case tender.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case tender.EdgeFinder:
		m.ResetFinder()
		return nil
	case tender.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tender.EdgeFollowingSales:
		m.ResetFollowingSales()
		return nil
	case tender.EdgeProvince:
		m.ResetProvince()
		return nil
	case tender.EdgeCity:
		m.ResetCity()
		return nil
	case tender.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case tender.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	}
	return fmt.Errorf("unknown Tender edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	email                *string
	username             *string
	open_id              *string
	avatar_url           *string
	disabled             *bool
	is_admin             *bool
	has_map_access       *bool
	is_editor            *bool
	clearedFields        map[string]struct{}
	areas                map[xid.ID]struct{}
	removedareas         map[xid.ID]struct{}
	clearedareas         bool
	customers            map[xid.ID]struct{}
	removedcustomers     map[xid.ID]struct{}
	clearedcustomers     bool
	leader               *xid.ID
	clearedleader        bool
	team_members         map[xid.ID]struct{}
	removedteam_members  map[xid.ID]struct{}
	clearedteam_members  bool
	tenders              map[xid.ID]struct{}
	removedtenders       map[xid.ID]struct{}
	clearedtenders       bool
	visit_records        map[xid.ID]struct{}
	removedvisit_records map[xid.ID]struct{}
	clearedvisit_records bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id xid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetOpenID sets the "open_id" field.
func (m *UserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *UserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *UserMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[user.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *UserMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[user.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *UserMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, user.FieldOpenID)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetHasMapAccess sets the "has_map_access" field.
func (m *UserMutation) SetHasMapAccess(b bool) {
	m.has_map_access = &b
}

// HasMapAccess returns the value of the "has_map_access" field in the mutation.
func (m *UserMutation) HasMapAccess() (r bool, exists bool) {
	v := m.has_map_access
	if v == nil {
		return
	}
	return *v, true
}

// OldHasMapAccess returns the old "has_map_access" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHasMapAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasMapAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasMapAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasMapAccess: %w", err)
	}
	return oldValue.HasMapAccess, nil
}

// ResetHasMapAccess resets all changes to the "has_map_access" field.
func (m *UserMutation) ResetHasMapAccess() {
	m.has_map_access = nil
}

// SetIsEditor sets the "is_editor" field.
func (m *UserMutation) SetIsEditor(b bool) {
	m.is_editor = &b
}

// IsEditor returns the value of the "is_editor" field in the mutation.
func (m *UserMutation) IsEditor() (r bool, exists bool) {
	v := m.is_editor
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEditor returns the old "is_editor" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsEditor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEditor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEditor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEditor: %w", err)
	}
	return oldValue.IsEditor, nil
}

// ResetIsEditor resets all changes to the "is_editor" field.
func (m *UserMutation) ResetIsEditor() {
	m.is_editor = nil
}

// SetLeaderID sets the "leader_id" field.
func (m *UserMutation) SetLeaderID(x xid.ID) {
	m.leader = &x
}

// LeaderID returns the value of the "leader_id" field in the mutation.
func (m *UserMutation) LeaderID() (r xid.ID, exists bool) {
	v := m.leader
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderID returns the old "leader_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLeaderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderID: %w", err)
	}
	return oldValue.LeaderID, nil
}

// ClearLeaderID clears the value of the "leader_id" field.
func (m *UserMutation) ClearLeaderID() {
	m.leader = nil
	m.clearedFields[user.FieldLeaderID] = struct{}{}
}

// LeaderIDCleared returns if the "leader_id" field was cleared in this mutation.
func (m *UserMutation) LeaderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldLeaderID]
	return ok
}

// ResetLeaderID resets all changes to the "leader_id" field.
func (m *UserMutation) ResetLeaderID() {
	m.leader = nil
	delete(m.clearedFields, user.FieldLeaderID)
}

// AddAreaIDs adds the "areas" edge to the Area entity by ids.
func (m *UserMutation) AddAreaIDs(ids ...xid.ID) {
	if m.areas == nil {
		m.areas = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.areas[ids[i]] = struct{}{}
	}
}

// ClearAreas clears the "areas" edge to the Area entity.
func (m *UserMutation) ClearAreas() {
	m.clearedareas = true
}

// AreasCleared reports if the "areas" edge to the Area entity was cleared.
func (m *UserMutation) AreasCleared() bool {
	return m.clearedareas
}

// RemoveAreaIDs removes the "areas" edge to the Area entity by IDs.
func (m *UserMutation) RemoveAreaIDs(ids ...xid.ID) {
	if m.removedareas == nil {
		m.removedareas = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.areas, ids[i])
		m.removedareas[ids[i]] = struct{}{}
	}
}

// RemovedAreas returns the removed IDs of the "areas" edge to the Area entity.
func (m *UserMutation) RemovedAreasIDs() (ids []xid.ID) {
	for id := range m.removedareas {
		ids = append(ids, id)
	}
	return
}

// AreasIDs returns the "areas" edge IDs in the mutation.
func (m *UserMutation) AreasIDs() (ids []xid.ID) {
	for id := range m.areas {
		ids = append(ids, id)
	}
	return
}

// ResetAreas resets all changes to the "areas" edge.
func (m *UserMutation) ResetAreas() {
	m.areas = nil
	m.clearedareas = false
	m.removedareas = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *UserMutation) AddCustomerIDs(ids ...xid.ID) {
	if m.customers == nil {
		m.customers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *UserMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *UserMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *UserMutation) RemoveCustomerIDs(ids ...xid.ID) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *UserMutation) RemovedCustomersIDs() (ids []xid.ID) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *UserMutation) CustomersIDs() (ids []xid.ID) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *UserMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *UserMutation) ClearLeader() {
	m.clearedleader = true
	m.clearedFields[user.FieldLeaderID] = struct{}{}
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *UserMutation) LeaderCleared() bool {
	return m.LeaderIDCleared() || m.clearedleader
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LeaderIDs() (ids []xid.ID) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *UserMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddTeamMemberIDs adds the "team_members" edge to the User entity by ids.
func (m *UserMutation) AddTeamMemberIDs(ids ...xid.ID) {
	if m.team_members == nil {
		m.team_members = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.team_members[ids[i]] = struct{}{}
	}
}

// ClearTeamMembers clears the "team_members" edge to the User entity.
func (m *UserMutation) ClearTeamMembers() {
	m.clearedteam_members = true
}

// TeamMembersCleared reports if the "team_members" edge to the User entity was cleared.
func (m *UserMutation) TeamMembersCleared() bool {
	return m.clearedteam_members
}

// RemoveTeamMemberIDs removes the "team_members" edge to the User entity by IDs.
func (m *UserMutation) RemoveTeamMemberIDs(ids ...xid.ID) {
	if m.removedteam_members == nil {
		m.removedteam_members = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.team_members, ids[i])
		m.removedteam_members[ids[i]] = struct{}{}
	}
}

// RemovedTeamMembers returns the removed IDs of the "team_members" edge to the User entity.
func (m *UserMutation) RemovedTeamMembersIDs() (ids []xid.ID) {
	for id := range m.removedteam_members {
		ids = append(ids, id)
	}
	return
}

// TeamMembersIDs returns the "team_members" edge IDs in the mutation.
func (m *UserMutation) TeamMembersIDs() (ids []xid.ID) {
	for id := range m.team_members {
		ids = append(ids, id)
	}
	return
}

// ResetTeamMembers resets all changes to the "team_members" edge.
func (m *UserMutation) ResetTeamMembers() {
	m.team_members = nil
	m.clearedteam_members = false
	m.removedteam_members = nil
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *UserMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *UserMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *UserMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *UserMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *UserMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *UserMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *UserMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *UserMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *UserMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *UserMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *UserMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *UserMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *UserMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *UserMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.open_id != nil {
		fields = append(fields, user.FieldOpenID)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.has_map_access != nil {
		fields = append(fields, user.FieldHasMapAccess)
	}
	if m.is_editor != nil {
		fields = append(fields, user.FieldIsEditor)
	}
	if m.leader != nil {
		fields = append(fields, user.FieldLeaderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldOpenID:
		return m.OpenID()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldDisabled:
		return m.Disabled()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldHasMapAccess:
		return m.HasMapAccess()
	case user.FieldIsEditor:
		return m.IsEditor()
	case user.FieldLeaderID:
		return m.LeaderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldOpenID:
		return m.OldOpenID(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldHasMapAccess:
		return m.OldHasMapAccess(ctx)
	case user.FieldIsEditor:
		return m.OldIsEditor(ctx)
	case user.FieldLeaderID:
		return m.OldLeaderID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldHasMapAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasMapAccess(v)
		return nil
	case user.FieldIsEditor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEditor(v)
		return nil
	case user.FieldLeaderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldOpenID) {
		fields = append(fields, user.FieldOpenID)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldLeaderID) {
		fields = append(fields, user.FieldLeaderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldOpenID:
		m.ClearOpenID()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldLeaderID:
		m.ClearLeaderID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldOpenID:
		m.ResetOpenID()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldHasMapAccess:
		m.ResetHasMapAccess()
		return nil
	case user.FieldIsEditor:
		m.ResetIsEditor()
		return nil
	case user.FieldLeaderID:
		m.ResetLeaderID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.areas != nil {
		edges = append(edges, user.EdgeAreas)
	}
	if m.customers != nil {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.leader != nil {
		edges = append(edges, user.EdgeLeader)
	}
	if m.team_members != nil {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.tenders != nil {
		edges = append(edges, user.EdgeTenders)
	}
	if m.visit_records != nil {
		edges = append(edges, user.EdgeVisitRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.areas))
		for id := range m.areas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTeamMembers:
		ids := make([]ent.Value, 0, len(m.team_members))
		for id := range m.team_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedareas != nil {
		edges = append(edges, user.EdgeAreas)
	}
	if m.removedcustomers != nil {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.removedteam_members != nil {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.removedtenders != nil {
		edges = append(edges, user.EdgeTenders)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, user.EdgeVisitRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.removedareas))
		for id := range m.removedareas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamMembers:
		ids := make([]ent.Value, 0, len(m.removedteam_members))
		for id := range m.removedteam_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedareas {
		edges = append(edges, user.EdgeAreas)
	}
	if m.clearedcustomers {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.clearedleader {
		edges = append(edges, user.EdgeLeader)
	}
	if m.clearedteam_members {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.clearedtenders {
		edges = append(edges, user.EdgeTenders)
	}
	if m.clearedvisit_records {
		edges = append(edges, user.EdgeVisitRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAreas:
		return m.clearedareas
	case user.EdgeCustomers:
		return m.clearedcustomers
	case user.EdgeLeader:
		return m.clearedleader
	case user.EdgeTeamMembers:
		return m.clearedteam_members
	case user.EdgeTenders:
		return m.clearedtenders
	case user.EdgeVisitRecords:
		return m.clearedvisit_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAreas:
		m.ResetAreas()
		return nil
	case user.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case user.EdgeLeader:
		m.ResetLeader()
		return nil
	case user.EdgeTeamMembers:
		m.ResetTeamMembers()
		return nil
	case user.EdgeTenders:
		m.ResetTenders()
		return nil
	case user.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VisitRecordMutation represents an operation that mutates the VisitRecord nodes in the graph.
type VisitRecordMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	visit_type         *int
	addvisit_type      *int
	comm_people        *string
	comm_content       *string
	next_step          *string
	date               *time.Time
	clearedFields      map[string]struct{}
	tender             *xid.ID
	clearedtender      bool
	customer           *xid.ID
	clearedcustomer    bool
	followUpBys        map[xid.ID]struct{}
	removedfollowUpBys map[xid.ID]struct{}
	clearedfollowUpBys bool
	done               bool
	oldValue           func(context.Context) (*VisitRecord, error)
	predicates         []predicate.VisitRecord
}

var _ ent.Mutation = (*VisitRecordMutation)(nil)

// visitrecordOption allows management of the mutation configuration using functional options.
type visitrecordOption func(*VisitRecordMutation)

// newVisitRecordMutation creates new mutation for the VisitRecord entity.
func newVisitRecordMutation(c config, op Op, opts ...visitrecordOption) *VisitRecordMutation {
	m := &VisitRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitRecordID sets the ID field of the mutation.
func withVisitRecordID(id xid.ID) visitrecordOption {
	return func(m *VisitRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitRecord
		)
		m.oldValue = func(ctx context.Context) (*VisitRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitRecord sets the old VisitRecord of the mutation.
func withVisitRecord(node *VisitRecord) visitrecordOption {
	return func(m *VisitRecordMutation) {
		m.oldValue = func(context.Context) (*VisitRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitRecord entities.
func (m *VisitRecordMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitRecordMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitRecordMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVisitType sets the "visit_type" field.
func (m *VisitRecordMutation) SetVisitType(i int) {
	m.visit_type = &i
	m.addvisit_type = nil
}

// VisitType returns the value of the "visit_type" field in the mutation.
func (m *VisitRecordMutation) VisitType() (r int, exists bool) {
	v := m.visit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitType returns the old "visit_type" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldVisitType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitType: %w", err)
	}
	return oldValue.VisitType, nil
}

// AddVisitType adds i to the "visit_type" field.
func (m *VisitRecordMutation) AddVisitType(i int) {
	if m.addvisit_type != nil {
		*m.addvisit_type += i
	} else {
		m.addvisit_type = &i
	}
}

// AddedVisitType returns the value that was added to the "visit_type" field in this mutation.
func (m *VisitRecordMutation) AddedVisitType() (r int, exists bool) {
	v := m.addvisit_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetVisitType resets all changes to the "visit_type" field.
func (m *VisitRecordMutation) ResetVisitType() {
	m.visit_type = nil
	m.addvisit_type = nil
}

// SetCommPeople sets the "comm_people" field.
func (m *VisitRecordMutation) SetCommPeople(s string) {
	m.comm_people = &s
}

// CommPeople returns the value of the "comm_people" field in the mutation.
func (m *VisitRecordMutation) CommPeople() (r string, exists bool) {
	v := m.comm_people
	if v == nil {
		return
	}
	return *v, true
}

// OldCommPeople returns the old "comm_people" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCommPeople(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommPeople is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommPeople requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommPeople: %w", err)
	}
	return oldValue.CommPeople, nil
}

// ResetCommPeople resets all changes to the "comm_people" field.
func (m *VisitRecordMutation) ResetCommPeople() {
	m.comm_people = nil
}

// SetCommContent sets the "comm_content" field.
func (m *VisitRecordMutation) SetCommContent(s string) {
	m.comm_content = &s
}

// CommContent returns the value of the "comm_content" field in the mutation.
func (m *VisitRecordMutation) CommContent() (r string, exists bool) {
	v := m.comm_content
	if v == nil {
		return
	}
	return *v, true
}

// OldCommContent returns the old "comm_content" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCommContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommContent: %w", err)
	}
	return oldValue.CommContent, nil
}

// ResetCommContent resets all changes to the "comm_content" field.
func (m *VisitRecordMutation) ResetCommContent() {
	m.comm_content = nil
}

// SetNextStep sets the "next_step" field.
func (m *VisitRecordMutation) SetNextStep(s string) {
	m.next_step = &s
}

// NextStep returns the value of the "next_step" field in the mutation.
func (m *VisitRecordMutation) NextStep() (r string, exists bool) {
	v := m.next_step
	if v == nil {
		return
	}
	return *v, true
}

// OldNextStep returns the old "next_step" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldNextStep(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextStep: %w", err)
	}
	return oldValue.NextStep, nil
}

// ClearNextStep clears the value of the "next_step" field.
func (m *VisitRecordMutation) ClearNextStep() {
	m.next_step = nil
	m.clearedFields[visitrecord.FieldNextStep] = struct{}{}
}

// NextStepCleared returns if the "next_step" field was cleared in this mutation.
func (m *VisitRecordMutation) NextStepCleared() bool {
	_, ok := m.clearedFields[visitrecord.FieldNextStep]
	return ok
}

// ResetNextStep resets all changes to the "next_step" field.
func (m *VisitRecordMutation) ResetNextStep() {
	m.next_step = nil
	delete(m.clearedFields, visitrecord.FieldNextStep)
}

// SetDate sets the "date" field.
func (m *VisitRecordMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *VisitRecordMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *VisitRecordMutation) ResetDate() {
	m.date = nil
}

// SetTenderID sets the "tender_id" field.
func (m *VisitRecordMutation) SetTenderID(x xid.ID) {
	m.tender = &x
}

// TenderID returns the value of the "tender_id" field in the mutation.
func (m *VisitRecordMutation) TenderID() (r xid.ID, exists bool) {
	v := m.tender
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderID returns the old "tender_id" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldTenderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderID: %w", err)
	}
	return oldValue.TenderID, nil
}

// ClearTenderID clears the value of the "tender_id" field.
func (m *VisitRecordMutation) ClearTenderID() {
	m.tender = nil
	m.clearedFields[visitrecord.FieldTenderID] = struct{}{}
}

// TenderIDCleared returns if the "tender_id" field was cleared in this mutation.
func (m *VisitRecordMutation) TenderIDCleared() bool {
	_, ok := m.clearedFields[visitrecord.FieldTenderID]
	return ok
}

// ResetTenderID resets all changes to the "tender_id" field.
func (m *VisitRecordMutation) ResetTenderID() {
	m.tender = nil
	delete(m.clearedFields, visitrecord.FieldTenderID)
}

// SetCustomerID sets the "customer_id" field.
func (m *VisitRecordMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *VisitRecordMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCustomerID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *VisitRecordMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[visitrecord.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *VisitRecordMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[visitrecord.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *VisitRecordMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, visitrecord.FieldCustomerID)
}

// ClearTender clears the "tender" edge to the Tender entity.
func (m *VisitRecordMutation) ClearTender() {
	m.clearedtender = true
	m.clearedFields[visitrecord.FieldTenderID] = struct{}{}
}

// TenderCleared reports if the "tender" edge to the Tender entity was cleared.
func (m *VisitRecordMutation) TenderCleared() bool {
	return m.TenderIDCleared() || m.clearedtender
}

// TenderIDs returns the "tender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenderID instead. It exists only for internal usage by the builders.
func (m *VisitRecordMutation) TenderIDs() (ids []xid.ID) {
	if id := m.tender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTender resets all changes to the "tender" edge.
func (m *VisitRecordMutation) ResetTender() {
	m.tender = nil
	m.clearedtender = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *VisitRecordMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[visitrecord.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *VisitRecordMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *VisitRecordMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *VisitRecordMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddFollowUpByIDs adds the "followUpBys" edge to the User entity by ids.
func (m *VisitRecordMutation) AddFollowUpByIDs(ids ...xid.ID) {
	if m.followUpBys == nil {
		m.followUpBys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.followUpBys[ids[i]] = struct{}{}
	}
}

// ClearFollowUpBys clears the "followUpBys" edge to the User entity.
func (m *VisitRecordMutation) ClearFollowUpBys() {
	m.clearedfollowUpBys = true
}

// FollowUpBysCleared reports if the "followUpBys" edge to the User entity was cleared.
func (m *VisitRecordMutation) FollowUpBysCleared() bool {
	return m.clearedfollowUpBys
}

// RemoveFollowUpByIDs removes the "followUpBys" edge to the User entity by IDs.
func (m *VisitRecordMutation) RemoveFollowUpByIDs(ids ...xid.ID) {
	if m.removedfollowUpBys == nil {
		m.removedfollowUpBys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.followUpBys, ids[i])
		m.removedfollowUpBys[ids[i]] = struct{}{}
	}
}

// RemovedFollowUpBys returns the removed IDs of the "followUpBys" edge to the User entity.
func (m *VisitRecordMutation) RemovedFollowUpBysIDs() (ids []xid.ID) {
	for id := range m.removedfollowUpBys {
		ids = append(ids, id)
	}
	return
}

// FollowUpBysIDs returns the "followUpBys" edge IDs in the mutation.
func (m *VisitRecordMutation) FollowUpBysIDs() (ids []xid.ID) {
	for id := range m.followUpBys {
		ids = append(ids, id)
	}
	return
}

// ResetFollowUpBys resets all changes to the "followUpBys" edge.
func (m *VisitRecordMutation) ResetFollowUpBys() {
	m.followUpBys = nil
	m.clearedfollowUpBys = false
	m.removedfollowUpBys = nil
}

// Where appends a list predicates to the VisitRecordMutation builder.
func (m *VisitRecordMutation) Where(ps ...predicate.VisitRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitRecord).
func (m *VisitRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, visitrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, visitrecord.FieldUpdatedAt)
	}
	if m.visit_type != nil {
		fields = append(fields, visitrecord.FieldVisitType)
	}
	if m.comm_people != nil {
		fields = append(fields, visitrecord.FieldCommPeople)
	}
	if m.comm_content != nil {
		fields = append(fields, visitrecord.FieldCommContent)
	}
	if m.next_step != nil {
		fields = append(fields, visitrecord.FieldNextStep)
	}
	if m.date != nil {
		fields = append(fields, visitrecord.FieldDate)
	}
	if m.tender != nil {
		fields = append(fields, visitrecord.FieldTenderID)
	}
	if m.customer != nil {
		fields = append(fields, visitrecord.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitrecord.FieldCreatedAt:
		return m.CreatedAt()
	case visitrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case visitrecord.FieldVisitType:
		return m.VisitType()
	case visitrecord.FieldCommPeople:
		return m.CommPeople()
	case visitrecord.FieldCommContent:
		return m.CommContent()
	case visitrecord.FieldNextStep:
		return m.NextStep()
	case visitrecord.FieldDate:
		return m.Date()
	case visitrecord.FieldTenderID:
		return m.TenderID()
	case visitrecord.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visitrecord.FieldVisitType:
		return m.OldVisitType(ctx)
	case visitrecord.FieldCommPeople:
		return m.OldCommPeople(ctx)
	case visitrecord.FieldCommContent:
		return m.OldCommContent(ctx)
	case visitrecord.FieldNextStep:
		return m.OldNextStep(ctx)
	case visitrecord.FieldDate:
		return m.OldDate(ctx)
	case visitrecord.FieldTenderID:
		return m.OldTenderID(ctx)
	case visitrecord.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown VisitRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visitrecord.FieldVisitType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitType(v)
		return nil
	case visitrecord.FieldCommPeople:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommPeople(v)
		return nil
	case visitrecord.FieldCommContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommContent(v)
		return nil
	case visitrecord.FieldNextStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextStep(v)
		return nil
	case visitrecord.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case visitrecord.FieldTenderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderID(v)
		return nil
	case visitrecord.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown VisitRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitRecordMutation) AddedFields() []string {
	var fields []string
	if m.addvisit_type != nil {
		fields = append(fields, visitrecord.FieldVisitType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitrecord.FieldVisitType:
		return m.AddedVisitType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitrecord.FieldVisitType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisitType(v)
		return nil
	}
	return fmt.Errorf("unknown VisitRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visitrecord.FieldNextStep) {
		fields = append(fields, visitrecord.FieldNextStep)
	}
	if m.FieldCleared(visitrecord.FieldTenderID) {
		fields = append(fields, visitrecord.FieldTenderID)
	}
	if m.FieldCleared(visitrecord.FieldCustomerID) {
		fields = append(fields, visitrecord.FieldCustomerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitRecordMutation) ClearField(name string) error {
	switch name {
	case visitrecord.FieldNextStep:
		m.ClearNextStep()
		return nil
	case visitrecord.FieldTenderID:
		m.ClearTenderID()
		return nil
	case visitrecord.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitRecordMutation) ResetField(name string) error {
	switch name {
	case visitrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visitrecord.FieldVisitType:
		m.ResetVisitType()
		return nil
	case visitrecord.FieldCommPeople:
		m.ResetCommPeople()
		return nil
	case visitrecord.FieldCommContent:
		m.ResetCommContent()
		return nil
	case visitrecord.FieldNextStep:
		m.ResetNextStep()
		return nil
	case visitrecord.FieldDate:
		m.ResetDate()
		return nil
	case visitrecord.FieldTenderID:
		m.ResetTenderID()
		return nil
	case visitrecord.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tender != nil {
		edges = append(edges, visitrecord.EdgeTender)
	}
	if m.customer != nil {
		edges = append(edges, visitrecord.EdgeCustomer)
	}
	if m.followUpBys != nil {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case visitrecord.EdgeTender:
		if id := m.tender; id != nil {
			return []ent.Value{*id}
		}
	case visitrecord.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case visitrecord.EdgeFollowUpBys:
		ids := make([]ent.Value, 0, len(m.followUpBys))
		for id := range m.followUpBys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfollowUpBys != nil {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case visitrecord.EdgeFollowUpBys:
		ids := make([]ent.Value, 0, len(m.removedfollowUpBys))
		for id := range m.removedfollowUpBys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtender {
		edges = append(edges, visitrecord.EdgeTender)
	}
	if m.clearedcustomer {
		edges = append(edges, visitrecord.EdgeCustomer)
	}
	if m.clearedfollowUpBys {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case visitrecord.EdgeTender:
		return m.clearedtender
	case visitrecord.EdgeCustomer:
		return m.clearedcustomer
	case visitrecord.EdgeFollowUpBys:
		return m.clearedfollowUpBys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitRecordMutation) ClearEdge(name string) error {
	switch name {
	case visitrecord.EdgeTender:
		m.ClearTender()
		return nil
	case visitrecord.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitRecordMutation) ResetEdge(name string) error {
	switch name {
	case visitrecord.EdgeTender:
		m.ResetTender()
		return nil
	case visitrecord.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case visitrecord.EdgeFollowUpBys:
		m.ResetFollowUpBys()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord edge %s", name)
}
