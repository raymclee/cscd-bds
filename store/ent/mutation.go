// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"cscd-bds/store/ent/area"
	"cscd-bds/store/ent/city"
	"cscd-bds/store/ent/competitor"
	"cscd-bds/store/ent/country"
	"cscd-bds/store/ent/customer"
	"cscd-bds/store/ent/customerprofile"
	"cscd-bds/store/ent/district"
	"cscd-bds/store/ent/land"
	"cscd-bds/store/ent/operation"
	"cscd-bds/store/ent/plot"
	"cscd-bds/store/ent/potentialtender"
	"cscd-bds/store/ent/predicate"
	"cscd-bds/store/ent/project"
	"cscd-bds/store/ent/province"
	"cscd-bds/store/ent/schema/geo"
	"cscd-bds/store/ent/schema/model"
	"cscd-bds/store/ent/schema/xid"
	"cscd-bds/store/ent/schema/zht"
	"cscd-bds/store/ent/tender"
	"cscd-bds/store/ent/tendercompetitor"
	"cscd-bds/store/ent/tenderprofile"
	"cscd-bds/store/ent/user"
	"cscd-bds/store/ent/visitrecord"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeArea             = "Area"
	TypeCity             = "City"
	TypeCompetitor       = "Competitor"
	TypeCountry          = "Country"
	TypeCustomer         = "Customer"
	TypeCustomerProfile  = "CustomerProfile"
	TypeDistrict         = "District"
	TypeLand             = "Land"
	TypeOperation        = "Operation"
	TypePlot             = "Plot"
	TypePotentialTender  = "PotentialTender"
	TypeProject          = "Project"
	TypeProvince         = "Province"
	TypeTender           = "Tender"
	TypeTenderCompetitor = "TenderCompetitor"
	TypeTenderProfile    = "TenderProfile"
	TypeUser             = "User"
	TypeVisitRecord      = "VisitRecord"
)

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	code             *string
	leader_chat_id   *string
	sales_chat_id    *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	customers        map[xid.ID]struct{}
	removedcustomers map[xid.ID]struct{}
	clearedcustomers bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	users            map[xid.ID]struct{}
	removedusers     map[xid.ID]struct{}
	clearedusers     bool
	provinces        map[xid.ID]struct{}
	removedprovinces map[xid.ID]struct{}
	clearedprovinces bool
	done             bool
	oldValue         func(context.Context) (*Area, error)
	predicates       []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id xid.ID) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Area entities.
func (m *AreaMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AreaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AreaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AreaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AreaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AreaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AreaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *AreaMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AreaMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AreaMutation) ResetCode() {
	m.code = nil
}

// SetLeaderChatID sets the "leader_chat_id" field.
func (m *AreaMutation) SetLeaderChatID(s string) {
	m.leader_chat_id = &s
}

// LeaderChatID returns the value of the "leader_chat_id" field in the mutation.
func (m *AreaMutation) LeaderChatID() (r string, exists bool) {
	v := m.leader_chat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderChatID returns the old "leader_chat_id" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldLeaderChatID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderChatID: %w", err)
	}
	return oldValue.LeaderChatID, nil
}

// ClearLeaderChatID clears the value of the "leader_chat_id" field.
func (m *AreaMutation) ClearLeaderChatID() {
	m.leader_chat_id = nil
	m.clearedFields[area.FieldLeaderChatID] = struct{}{}
}

// LeaderChatIDCleared returns if the "leader_chat_id" field was cleared in this mutation.
func (m *AreaMutation) LeaderChatIDCleared() bool {
	_, ok := m.clearedFields[area.FieldLeaderChatID]
	return ok
}

// ResetLeaderChatID resets all changes to the "leader_chat_id" field.
func (m *AreaMutation) ResetLeaderChatID() {
	m.leader_chat_id = nil
	delete(m.clearedFields, area.FieldLeaderChatID)
}

// SetSalesChatID sets the "sales_chat_id" field.
func (m *AreaMutation) SetSalesChatID(s string) {
	m.sales_chat_id = &s
}

// SalesChatID returns the value of the "sales_chat_id" field in the mutation.
func (m *AreaMutation) SalesChatID() (r string, exists bool) {
	v := m.sales_chat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesChatID returns the old "sales_chat_id" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldSalesChatID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesChatID: %w", err)
	}
	return oldValue.SalesChatID, nil
}

// ClearSalesChatID clears the value of the "sales_chat_id" field.
func (m *AreaMutation) ClearSalesChatID() {
	m.sales_chat_id = nil
	m.clearedFields[area.FieldSalesChatID] = struct{}{}
}

// SalesChatIDCleared returns if the "sales_chat_id" field was cleared in this mutation.
func (m *AreaMutation) SalesChatIDCleared() bool {
	_, ok := m.clearedFields[area.FieldSalesChatID]
	return ok
}

// ResetSalesChatID resets all changes to the "sales_chat_id" field.
func (m *AreaMutation) ResetSalesChatID() {
	m.sales_chat_id = nil
	delete(m.clearedFields, area.FieldSalesChatID)
}

// SetCenter sets the "center" field.
func (m *AreaMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *AreaMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ClearCenter clears the value of the "center" field.
func (m *AreaMutation) ClearCenter() {
	m.center = nil
	m.clearedFields[area.FieldCenter] = struct{}{}
}

// CenterCleared returns if the "center" field was cleared in this mutation.
func (m *AreaMutation) CenterCleared() bool {
	_, ok := m.clearedFields[area.FieldCenter]
	return ok
}

// ResetCenter resets all changes to the "center" field.
func (m *AreaMutation) ResetCenter() {
	m.center = nil
	delete(m.clearedFields, area.FieldCenter)
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *AreaMutation) AddCustomerIDs(ids ...xid.ID) {
	if m.customers == nil {
		m.customers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *AreaMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *AreaMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *AreaMutation) RemoveCustomerIDs(ids ...xid.ID) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *AreaMutation) RemovedCustomersIDs() (ids []xid.ID) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *AreaMutation) CustomersIDs() (ids []xid.ID) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *AreaMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *AreaMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *AreaMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *AreaMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *AreaMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *AreaMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *AreaMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *AreaMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *AreaMutation) AddUserIDs(ids ...xid.ID) {
	if m.users == nil {
		m.users = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *AreaMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *AreaMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *AreaMutation) RemoveUserIDs(ids ...xid.ID) {
	if m.removedusers == nil {
		m.removedusers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *AreaMutation) RemovedUsersIDs() (ids []xid.ID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AreaMutation) UsersIDs() (ids []xid.ID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AreaMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddProvinceIDs adds the "provinces" edge to the Province entity by ids.
func (m *AreaMutation) AddProvinceIDs(ids ...xid.ID) {
	if m.provinces == nil {
		m.provinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.provinces[ids[i]] = struct{}{}
	}
}

// ClearProvinces clears the "provinces" edge to the Province entity.
func (m *AreaMutation) ClearProvinces() {
	m.clearedprovinces = true
}

// ProvincesCleared reports if the "provinces" edge to the Province entity was cleared.
func (m *AreaMutation) ProvincesCleared() bool {
	return m.clearedprovinces
}

// RemoveProvinceIDs removes the "provinces" edge to the Province entity by IDs.
func (m *AreaMutation) RemoveProvinceIDs(ids ...xid.ID) {
	if m.removedprovinces == nil {
		m.removedprovinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.provinces, ids[i])
		m.removedprovinces[ids[i]] = struct{}{}
	}
}

// RemovedProvinces returns the removed IDs of the "provinces" edge to the Province entity.
func (m *AreaMutation) RemovedProvincesIDs() (ids []xid.ID) {
	for id := range m.removedprovinces {
		ids = append(ids, id)
	}
	return
}

// ProvincesIDs returns the "provinces" edge IDs in the mutation.
func (m *AreaMutation) ProvincesIDs() (ids []xid.ID) {
	for id := range m.provinces {
		ids = append(ids, id)
	}
	return
}

// ResetProvinces resets all changes to the "provinces" edge.
func (m *AreaMutation) ResetProvinces() {
	m.provinces = nil
	m.clearedprovinces = false
	m.removedprovinces = nil
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Area, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, area.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, area.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.code != nil {
		fields = append(fields, area.FieldCode)
	}
	if m.leader_chat_id != nil {
		fields = append(fields, area.FieldLeaderChatID)
	}
	if m.sales_chat_id != nil {
		fields = append(fields, area.FieldSalesChatID)
	}
	if m.center != nil {
		fields = append(fields, area.FieldCenter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldCreatedAt:
		return m.CreatedAt()
	case area.FieldUpdatedAt:
		return m.UpdatedAt()
	case area.FieldName:
		return m.Name()
	case area.FieldCode:
		return m.Code()
	case area.FieldLeaderChatID:
		return m.LeaderChatID()
	case area.FieldSalesChatID:
		return m.SalesChatID()
	case area.FieldCenter:
		return m.Center()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case area.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldCode:
		return m.OldCode(ctx)
	case area.FieldLeaderChatID:
		return m.OldLeaderChatID(ctx)
	case area.FieldSalesChatID:
		return m.OldSalesChatID(ctx)
	case area.FieldCenter:
		return m.OldCenter(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case area.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case area.FieldLeaderChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderChatID(v)
		return nil
	case area.FieldSalesChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesChatID(v)
		return nil
	case area.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(area.FieldLeaderChatID) {
		fields = append(fields, area.FieldLeaderChatID)
	}
	if m.FieldCleared(area.FieldSalesChatID) {
		fields = append(fields, area.FieldSalesChatID)
	}
	if m.FieldCleared(area.FieldCenter) {
		fields = append(fields, area.FieldCenter)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	switch name {
	case area.FieldLeaderChatID:
		m.ClearLeaderChatID()
		return nil
	case area.FieldSalesChatID:
		m.ClearSalesChatID()
		return nil
	case area.FieldCenter:
		m.ClearCenter()
		return nil
	}
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case area.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldCode:
		m.ResetCode()
		return nil
	case area.FieldLeaderChatID:
		m.ResetLeaderChatID()
		return nil
	case area.FieldSalesChatID:
		m.ResetSalesChatID()
		return nil
	case area.FieldCenter:
		m.ResetCenter()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customers != nil {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.tenders != nil {
		edges = append(edges, area.EdgeTenders)
	}
	if m.users != nil {
		edges = append(edges, area.EdgeUsers)
	}
	if m.provinces != nil {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.provinces))
		for id := range m.provinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcustomers != nil {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.removedtenders != nil {
		edges = append(edges, area.EdgeTenders)
	}
	if m.removedusers != nil {
		edges = append(edges, area.EdgeUsers)
	}
	if m.removedprovinces != nil {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case area.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.removedprovinces))
		for id := range m.removedprovinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomers {
		edges = append(edges, area.EdgeCustomers)
	}
	if m.clearedtenders {
		edges = append(edges, area.EdgeTenders)
	}
	if m.clearedusers {
		edges = append(edges, area.EdgeUsers)
	}
	if m.clearedprovinces {
		edges = append(edges, area.EdgeProvinces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	switch name {
	case area.EdgeCustomers:
		return m.clearedcustomers
	case area.EdgeTenders:
		return m.clearedtenders
	case area.EdgeUsers:
		return m.clearedusers
	case area.EdgeProvinces:
		return m.clearedprovinces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	switch name {
	case area.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case area.EdgeTenders:
		m.ResetTenders()
		return nil
	case area.EdgeUsers:
		m.ResetUsers()
		return nil
	case area.EdgeProvinces:
		m.ResetProvinces()
		return nil
	}
	return fmt.Errorf("unknown Area edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	prov_code        *int
	addprov_code     *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	districts        map[xid.ID]struct{}
	removeddistricts map[xid.ID]struct{}
	cleareddistricts bool
	province         *xid.ID
	clearedprovince  bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	done             bool
	oldValue         func(context.Context) (*City, error)
	predicates       []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id xid.ID) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *CityMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *CityMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *CityMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *CityMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *CityMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetProvCode sets the "prov_code" field.
func (m *CityMutation) SetProvCode(i int) {
	m.prov_code = &i
	m.addprov_code = nil
}

// ProvCode returns the value of the "prov_code" field in the mutation.
func (m *CityMutation) ProvCode() (r int, exists bool) {
	v := m.prov_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvCode returns the old "prov_code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldProvCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvCode: %w", err)
	}
	return oldValue.ProvCode, nil
}

// AddProvCode adds i to the "prov_code" field.
func (m *CityMutation) AddProvCode(i int) {
	if m.addprov_code != nil {
		*m.addprov_code += i
	} else {
		m.addprov_code = &i
	}
}

// AddedProvCode returns the value that was added to the "prov_code" field in this mutation.
func (m *CityMutation) AddedProvCode() (r int, exists bool) {
	v := m.addprov_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvCode resets all changes to the "prov_code" field.
func (m *CityMutation) ResetProvCode() {
	m.prov_code = nil
	m.addprov_code = nil
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *CityMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *CityMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *CityMutation) ResetCenter() {
	m.center = nil
}

// SetProvinceID sets the "province_id" field.
func (m *CityMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *CityMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldProvinceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *CityMutation) ResetProvinceID() {
	m.province = nil
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *CityMutation) AddDistrictIDs(ids ...xid.ID) {
	if m.districts == nil {
		m.districts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *CityMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *CityMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *CityMutation) RemoveDistrictIDs(ids ...xid.ID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *CityMutation) RemovedDistrictsIDs() (ids []xid.ID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *CityMutation) DistrictsIDs() (ids []xid.ID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *CityMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *CityMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[city.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *CityMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *CityMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *CityMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *CityMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *CityMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *CityMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *CityMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *CityMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *CityMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, city.FieldAdcode)
	}
	if m.prov_code != nil {
		fields = append(fields, city.FieldProvCode)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.center != nil {
		fields = append(fields, city.FieldCenter)
	}
	if m.province != nil {
		fields = append(fields, city.FieldProvinceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldAdcode:
		return m.Adcode()
	case city.FieldProvCode:
		return m.ProvCode()
	case city.FieldName:
		return m.Name()
	case city.FieldCenter:
		return m.Center()
	case city.FieldProvinceID:
		return m.ProvinceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldAdcode:
		return m.OldAdcode(ctx)
	case city.FieldProvCode:
		return m.OldProvCode(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldCenter:
		return m.OldCenter(ctx)
	case city.FieldProvinceID:
		return m.OldProvinceID(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case city.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvCode(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case city.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, city.FieldAdcode)
	}
	if m.addprov_code != nil {
		fields = append(fields, city.FieldProvCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldAdcode:
		return m.AddedAdcode()
	case city.FieldProvCode:
		return m.AddedProvCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	case city.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvCode(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldAdcode:
		m.ResetAdcode()
		return nil
	case city.FieldProvCode:
		m.ResetProvCode()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldCenter:
		m.ResetCenter()
		return nil
	case city.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.districts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.province != nil {
		edges = append(edges, city.EdgeProvince)
	}
	if m.tenders != nil {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddistricts != nil {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.removedtenders != nil {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddistricts {
		edges = append(edges, city.EdgeDistricts)
	}
	if m.clearedprovince {
		edges = append(edges, city.EdgeProvince)
	}
	if m.clearedtenders {
		edges = append(edges, city.EdgeTenders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeDistricts:
		return m.cleareddistricts
	case city.EdgeProvince:
		return m.clearedprovince
	case city.EdgeTenders:
		return m.clearedtenders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeProvince:
		m.ClearProvince()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case city.EdgeProvince:
		m.ResetProvince()
		return nil
	case city.EdgeTenders:
		m.ResetTenders()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CompetitorMutation represents an operation that mutates the Competitor nodes in the graph.
type CompetitorMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	updated_at     *time.Time
	short_name     *string
	name           *string
	clearedFields  map[string]struct{}
	tenders        map[xid.ID]struct{}
	removedtenders map[xid.ID]struct{}
	clearedtenders bool
	done           bool
	oldValue       func(context.Context) (*Competitor, error)
	predicates     []predicate.Competitor
}

var _ ent.Mutation = (*CompetitorMutation)(nil)

// competitorOption allows management of the mutation configuration using functional options.
type competitorOption func(*CompetitorMutation)

// newCompetitorMutation creates new mutation for the Competitor entity.
func newCompetitorMutation(c config, op Op, opts ...competitorOption) *CompetitorMutation {
	m := &CompetitorMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetitor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitorID sets the ID field of the mutation.
func withCompetitorID(id xid.ID) competitorOption {
	return func(m *CompetitorMutation) {
		var (
			err   error
			once  sync.Once
			value *Competitor
		)
		m.oldValue = func(ctx context.Context) (*Competitor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competitor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetitor sets the old Competitor of the mutation.
func withCompetitor(node *Competitor) competitorOption {
	return func(m *CompetitorMutation) {
		m.oldValue = func(context.Context) (*Competitor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competitor entities.
func (m *CompetitorMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitorMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitorMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competitor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompetitorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompetitorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Competitor entity.
// If the Competitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompetitorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompetitorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompetitorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Competitor entity.
// If the Competitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompetitorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetShortName sets the "short_name" field.
func (m *CompetitorMutation) SetShortName(s string) {
	m.short_name = &s
}

// ShortName returns the value of the "short_name" field in the mutation.
func (m *CompetitorMutation) ShortName() (r string, exists bool) {
	v := m.short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "short_name" field's value of the Competitor entity.
// If the Competitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitorMutation) OldShortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ResetShortName resets all changes to the "short_name" field.
func (m *CompetitorMutation) ResetShortName() {
	m.short_name = nil
}

// SetName sets the "name" field.
func (m *CompetitorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompetitorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Competitor entity.
// If the Competitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompetitorMutation) ResetName() {
	m.name = nil
}

// AddTenderIDs adds the "tenders" edge to the TenderCompetitor entity by ids.
func (m *CompetitorMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the TenderCompetitor entity.
func (m *CompetitorMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the TenderCompetitor entity was cleared.
func (m *CompetitorMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the TenderCompetitor entity by IDs.
func (m *CompetitorMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the TenderCompetitor entity.
func (m *CompetitorMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *CompetitorMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *CompetitorMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// Where appends a list predicates to the CompetitorMutation builder.
func (m *CompetitorMutation) Where(ps ...predicate.Competitor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competitor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competitor).
func (m *CompetitorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, competitor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, competitor.FieldUpdatedAt)
	}
	if m.short_name != nil {
		fields = append(fields, competitor.FieldShortName)
	}
	if m.name != nil {
		fields = append(fields, competitor.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competitor.FieldCreatedAt:
		return m.CreatedAt()
	case competitor.FieldUpdatedAt:
		return m.UpdatedAt()
	case competitor.FieldShortName:
		return m.ShortName()
	case competitor.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competitor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case competitor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case competitor.FieldShortName:
		return m.OldShortName(ctx)
	case competitor.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Competitor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competitor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case competitor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case competitor.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case competitor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Competitor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competitor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competitor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitorMutation) ResetField(name string) error {
	switch name {
	case competitor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case competitor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case competitor.FieldShortName:
		m.ResetShortName()
		return nil
	case competitor.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Competitor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenders != nil {
		edges = append(edges, competitor.EdgeTenders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competitor.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtenders != nil {
		edges = append(edges, competitor.EdgeTenders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competitor.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenders {
		edges = append(edges, competitor.EdgeTenders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitorMutation) EdgeCleared(name string) bool {
	switch name {
	case competitor.EdgeTenders:
		return m.clearedtenders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Competitor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitorMutation) ResetEdge(name string) error {
	switch name {
	case competitor.EdgeTenders:
		m.ResetTenders()
		return nil
	}
	return fmt.Errorf("unknown Competitor edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	provinces        map[xid.ID]struct{}
	removedprovinces map[xid.ID]struct{}
	clearedprovinces bool
	done             bool
	oldValue         func(context.Context) (*Country, error)
	predicates       []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id xid.ID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CountryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CountryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CountryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CountryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CountryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CountryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *CountryMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *CountryMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *CountryMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *CountryMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *CountryMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *CountryMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *CountryMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *CountryMutation) ResetCenter() {
	m.center = nil
}

// AddProvinceIDs adds the "provinces" edge to the Province entity by ids.
func (m *CountryMutation) AddProvinceIDs(ids ...xid.ID) {
	if m.provinces == nil {
		m.provinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.provinces[ids[i]] = struct{}{}
	}
}

// ClearProvinces clears the "provinces" edge to the Province entity.
func (m *CountryMutation) ClearProvinces() {
	m.clearedprovinces = true
}

// ProvincesCleared reports if the "provinces" edge to the Province entity was cleared.
func (m *CountryMutation) ProvincesCleared() bool {
	return m.clearedprovinces
}

// RemoveProvinceIDs removes the "provinces" edge to the Province entity by IDs.
func (m *CountryMutation) RemoveProvinceIDs(ids ...xid.ID) {
	if m.removedprovinces == nil {
		m.removedprovinces = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.provinces, ids[i])
		m.removedprovinces[ids[i]] = struct{}{}
	}
}

// RemovedProvinces returns the removed IDs of the "provinces" edge to the Province entity.
func (m *CountryMutation) RemovedProvincesIDs() (ids []xid.ID) {
	for id := range m.removedprovinces {
		ids = append(ids, id)
	}
	return
}

// ProvincesIDs returns the "provinces" edge IDs in the mutation.
func (m *CountryMutation) ProvincesIDs() (ids []xid.ID) {
	for id := range m.provinces {
		ids = append(ids, id)
	}
	return
}

// ResetProvinces resets all changes to the "provinces" edge.
func (m *CountryMutation) ResetProvinces() {
	m.provinces = nil
	m.clearedprovinces = false
	m.removedprovinces = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, country.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, country.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, country.FieldAdcode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.center != nil {
		fields = append(fields, country.FieldCenter)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCreatedAt:
		return m.CreatedAt()
	case country.FieldUpdatedAt:
		return m.UpdatedAt()
	case country.FieldAdcode:
		return m.Adcode()
	case country.FieldName:
		return m.Name()
	case country.FieldCenter:
		return m.Center()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case country.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case country.FieldAdcode:
		return m.OldAdcode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldCenter:
		return m.OldCenter(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case country.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case country.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, country.FieldAdcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case country.FieldAdcode:
		return m.AddedAdcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case country.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case country.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case country.FieldAdcode:
		m.ResetAdcode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldCenter:
		m.ResetCenter()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.provinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.provinces))
		for id := range m.provinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprovinces != nil {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeProvinces:
		ids := make([]ent.Value, 0, len(m.removedprovinces))
		for id := range m.removedprovinces {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprovinces {
		edges = append(edges, country.EdgeProvinces)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeProvinces:
		return m.clearedprovinces
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeProvinces:
		m.ResetProvinces()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *xid.ID
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	approval_status         *int
	addapproval_status      *int
	owner_type              *int
	addowner_type           *int
	industry                *int
	addindustry             *int
	size                    *int
	addsize                 *int
	contact_person          *string
	contact_person_position *string
	contact_person_phone    *string
	contact_person_email    *string
	draft                   **model.Customer
	feishu_group            **zht.Group
	clearedFields           map[string]struct{}
	area                    *xid.ID
	clearedarea             bool
	tenders                 map[xid.ID]struct{}
	removedtenders          map[xid.ID]struct{}
	clearedtenders          bool
	sales                   *xid.ID
	clearedsales            bool
	created_by              *xid.ID
	clearedcreated_by       bool
	updated_by              *xid.ID
	clearedupdated_by       bool
	approver                *xid.ID
	clearedapprover         bool
	visit_records           map[xid.ID]struct{}
	removedvisit_records    map[xid.ID]struct{}
	clearedvisit_records    bool
	profiles                map[xid.ID]struct{}
	removedprofiles         map[xid.ID]struct{}
	clearedprofiles         bool
	active_profile          *xid.ID
	clearedactive_profile   bool
	pending_profile         *xid.ID
	clearedpending_profile  bool
	done                    bool
	oldValue                func(context.Context) (*Customer, error)
	predicates              []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id xid.ID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetApprovalStatus sets the "approval_status" field.
func (m *CustomerMutation) SetApprovalStatus(i int) {
	m.approval_status = &i
	m.addapproval_status = nil
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *CustomerMutation) ApprovalStatus() (r int, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldApprovalStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// AddApprovalStatus adds i to the "approval_status" field.
func (m *CustomerMutation) AddApprovalStatus(i int) {
	if m.addapproval_status != nil {
		*m.addapproval_status += i
	} else {
		m.addapproval_status = &i
	}
}

// AddedApprovalStatus returns the value that was added to the "approval_status" field in this mutation.
func (m *CustomerMutation) AddedApprovalStatus() (r int, exists bool) {
	v := m.addapproval_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *CustomerMutation) ResetApprovalStatus() {
	m.approval_status = nil
	m.addapproval_status = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *CustomerMutation) SetOwnerType(i int) {
	m.owner_type = &i
	m.addowner_type = nil
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *CustomerMutation) OwnerType() (r int, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOwnerType(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// AddOwnerType adds i to the "owner_type" field.
func (m *CustomerMutation) AddOwnerType(i int) {
	if m.addowner_type != nil {
		*m.addowner_type += i
	} else {
		m.addowner_type = &i
	}
}

// AddedOwnerType returns the value that was added to the "owner_type" field in this mutation.
func (m *CustomerMutation) AddedOwnerType() (r int, exists bool) {
	v := m.addowner_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerType clears the value of the "owner_type" field.
func (m *CustomerMutation) ClearOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	m.clearedFields[customer.FieldOwnerType] = struct{}{}
}

// OwnerTypeCleared returns if the "owner_type" field was cleared in this mutation.
func (m *CustomerMutation) OwnerTypeCleared() bool {
	_, ok := m.clearedFields[customer.FieldOwnerType]
	return ok
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *CustomerMutation) ResetOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	delete(m.clearedFields, customer.FieldOwnerType)
}

// SetIndustry sets the "industry" field.
func (m *CustomerMutation) SetIndustry(i int) {
	m.industry = &i
	m.addindustry = nil
}

// Industry returns the value of the "industry" field in the mutation.
func (m *CustomerMutation) Industry() (r int, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldIndustry(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// AddIndustry adds i to the "industry" field.
func (m *CustomerMutation) AddIndustry(i int) {
	if m.addindustry != nil {
		*m.addindustry += i
	} else {
		m.addindustry = &i
	}
}

// AddedIndustry returns the value that was added to the "industry" field in this mutation.
func (m *CustomerMutation) AddedIndustry() (r int, exists bool) {
	v := m.addindustry
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndustry clears the value of the "industry" field.
func (m *CustomerMutation) ClearIndustry() {
	m.industry = nil
	m.addindustry = nil
	m.clearedFields[customer.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *CustomerMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[customer.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *CustomerMutation) ResetIndustry() {
	m.industry = nil
	m.addindustry = nil
	delete(m.clearedFields, customer.FieldIndustry)
}

// SetSize sets the "size" field.
func (m *CustomerMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CustomerMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldSize(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CustomerMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CustomerMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *CustomerMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[customer.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *CustomerMutation) SizeCleared() bool {
	_, ok := m.clearedFields[customer.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *CustomerMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, customer.FieldSize)
}

// SetContactPerson sets the "contact_person" field.
func (m *CustomerMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *CustomerMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPerson(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *CustomerMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[customer.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *CustomerMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, customer.FieldContactPerson)
}

// SetContactPersonPosition sets the "contact_person_position" field.
func (m *CustomerMutation) SetContactPersonPosition(s string) {
	m.contact_person_position = &s
}

// ContactPersonPosition returns the value of the "contact_person_position" field in the mutation.
func (m *CustomerMutation) ContactPersonPosition() (r string, exists bool) {
	v := m.contact_person_position
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPosition returns the old "contact_person_position" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPosition: %w", err)
	}
	return oldValue.ContactPersonPosition, nil
}

// ClearContactPersonPosition clears the value of the "contact_person_position" field.
func (m *CustomerMutation) ClearContactPersonPosition() {
	m.contact_person_position = nil
	m.clearedFields[customer.FieldContactPersonPosition] = struct{}{}
}

// ContactPersonPositionCleared returns if the "contact_person_position" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonPositionCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonPosition]
	return ok
}

// ResetContactPersonPosition resets all changes to the "contact_person_position" field.
func (m *CustomerMutation) ResetContactPersonPosition() {
	m.contact_person_position = nil
	delete(m.clearedFields, customer.FieldContactPersonPosition)
}

// SetContactPersonPhone sets the "contact_person_phone" field.
func (m *CustomerMutation) SetContactPersonPhone(s string) {
	m.contact_person_phone = &s
}

// ContactPersonPhone returns the value of the "contact_person_phone" field in the mutation.
func (m *CustomerMutation) ContactPersonPhone() (r string, exists bool) {
	v := m.contact_person_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPhone returns the old "contact_person_phone" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPhone: %w", err)
	}
	return oldValue.ContactPersonPhone, nil
}

// ClearContactPersonPhone clears the value of the "contact_person_phone" field.
func (m *CustomerMutation) ClearContactPersonPhone() {
	m.contact_person_phone = nil
	m.clearedFields[customer.FieldContactPersonPhone] = struct{}{}
}

// ContactPersonPhoneCleared returns if the "contact_person_phone" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonPhoneCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonPhone]
	return ok
}

// ResetContactPersonPhone resets all changes to the "contact_person_phone" field.
func (m *CustomerMutation) ResetContactPersonPhone() {
	m.contact_person_phone = nil
	delete(m.clearedFields, customer.FieldContactPersonPhone)
}

// SetContactPersonEmail sets the "contact_person_email" field.
func (m *CustomerMutation) SetContactPersonEmail(s string) {
	m.contact_person_email = &s
}

// ContactPersonEmail returns the value of the "contact_person_email" field in the mutation.
func (m *CustomerMutation) ContactPersonEmail() (r string, exists bool) {
	v := m.contact_person_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonEmail returns the old "contact_person_email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldContactPersonEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonEmail: %w", err)
	}
	return oldValue.ContactPersonEmail, nil
}

// ClearContactPersonEmail clears the value of the "contact_person_email" field.
func (m *CustomerMutation) ClearContactPersonEmail() {
	m.contact_person_email = nil
	m.clearedFields[customer.FieldContactPersonEmail] = struct{}{}
}

// ContactPersonEmailCleared returns if the "contact_person_email" field was cleared in this mutation.
func (m *CustomerMutation) ContactPersonEmailCleared() bool {
	_, ok := m.clearedFields[customer.FieldContactPersonEmail]
	return ok
}

// ResetContactPersonEmail resets all changes to the "contact_person_email" field.
func (m *CustomerMutation) ResetContactPersonEmail() {
	m.contact_person_email = nil
	delete(m.clearedFields, customer.FieldContactPersonEmail)
}

// SetDraft sets the "draft" field.
func (m *CustomerMutation) SetDraft(value *model.Customer) {
	m.draft = &value
}

// Draft returns the value of the "draft" field in the mutation.
func (m *CustomerMutation) Draft() (r *model.Customer, exists bool) {
	v := m.draft
	if v == nil {
		return
	}
	return *v, true
}

// OldDraft returns the old "draft" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDraft(ctx context.Context) (v *model.Customer, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDraft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDraft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDraft: %w", err)
	}
	return oldValue.Draft, nil
}

// ClearDraft clears the value of the "draft" field.
func (m *CustomerMutation) ClearDraft() {
	m.draft = nil
	m.clearedFields[customer.FieldDraft] = struct{}{}
}

// DraftCleared returns if the "draft" field was cleared in this mutation.
func (m *CustomerMutation) DraftCleared() bool {
	_, ok := m.clearedFields[customer.FieldDraft]
	return ok
}

// ResetDraft resets all changes to the "draft" field.
func (m *CustomerMutation) ResetDraft() {
	m.draft = nil
	delete(m.clearedFields, customer.FieldDraft)
}

// SetFeishuGroup sets the "feishu_group" field.
func (m *CustomerMutation) SetFeishuGroup(z *zht.Group) {
	m.feishu_group = &z
}

// FeishuGroup returns the value of the "feishu_group" field in the mutation.
func (m *CustomerMutation) FeishuGroup() (r *zht.Group, exists bool) {
	v := m.feishu_group
	if v == nil {
		return
	}
	return *v, true
}

// OldFeishuGroup returns the old "feishu_group" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFeishuGroup(ctx context.Context) (v *zht.Group, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeishuGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeishuGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeishuGroup: %w", err)
	}
	return oldValue.FeishuGroup, nil
}

// ClearFeishuGroup clears the value of the "feishu_group" field.
func (m *CustomerMutation) ClearFeishuGroup() {
	m.feishu_group = nil
	m.clearedFields[customer.FieldFeishuGroup] = struct{}{}
}

// FeishuGroupCleared returns if the "feishu_group" field was cleared in this mutation.
func (m *CustomerMutation) FeishuGroupCleared() bool {
	_, ok := m.clearedFields[customer.FieldFeishuGroup]
	return ok
}

// ResetFeishuGroup resets all changes to the "feishu_group" field.
func (m *CustomerMutation) ResetFeishuGroup() {
	m.feishu_group = nil
	delete(m.clearedFields, customer.FieldFeishuGroup)
}

// SetAreaID sets the "area_id" field.
func (m *CustomerMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *CustomerMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAreaID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *CustomerMutation) ResetAreaID() {
	m.area = nil
}

// SetSalesID sets the "sales_id" field.
func (m *CustomerMutation) SetSalesID(x xid.ID) {
	m.sales = &x
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *CustomerMutation) SalesID() (r xid.ID, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldSalesID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *CustomerMutation) ClearSalesID() {
	m.sales = nil
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *CustomerMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *CustomerMutation) ResetSalesID() {
	m.sales = nil
	delete(m.clearedFields, customer.FieldSalesID)
}

// SetCreatedByID sets the "created_by_id" field.
func (m *CustomerMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *CustomerMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ClearCreatedByID clears the value of the "created_by_id" field.
func (m *CustomerMutation) ClearCreatedByID() {
	m.created_by = nil
	m.clearedFields[customer.FieldCreatedByID] = struct{}{}
}

// CreatedByIDCleared returns if the "created_by_id" field was cleared in this mutation.
func (m *CustomerMutation) CreatedByIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldCreatedByID]
	return ok
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *CustomerMutation) ResetCreatedByID() {
	m.created_by = nil
	delete(m.clearedFields, customer.FieldCreatedByID)
}

// SetUpdatedByID sets the "updated_by_id" field.
func (m *CustomerMutation) SetUpdatedByID(x xid.ID) {
	m.updated_by = &x
}

// UpdatedByID returns the value of the "updated_by_id" field in the mutation.
func (m *CustomerMutation) UpdatedByID() (r xid.ID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByID returns the old "updated_by_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByID: %w", err)
	}
	return oldValue.UpdatedByID, nil
}

// ClearUpdatedByID clears the value of the "updated_by_id" field.
func (m *CustomerMutation) ClearUpdatedByID() {
	m.updated_by = nil
	m.clearedFields[customer.FieldUpdatedByID] = struct{}{}
}

// UpdatedByIDCleared returns if the "updated_by_id" field was cleared in this mutation.
func (m *CustomerMutation) UpdatedByIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldUpdatedByID]
	return ok
}

// ResetUpdatedByID resets all changes to the "updated_by_id" field.
func (m *CustomerMutation) ResetUpdatedByID() {
	m.updated_by = nil
	delete(m.clearedFields, customer.FieldUpdatedByID)
}

// SetApproverID sets the "approver_id" field.
func (m *CustomerMutation) SetApproverID(x xid.ID) {
	m.approver = &x
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *CustomerMutation) ApproverID() (r xid.ID, exists bool) {
	v := m.approver
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldApproverID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *CustomerMutation) ClearApproverID() {
	m.approver = nil
	m.clearedFields[customer.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *CustomerMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *CustomerMutation) ResetApproverID() {
	m.approver = nil
	delete(m.clearedFields, customer.FieldApproverID)
}

// SetActiveProfileID sets the "active_profile_id" field.
func (m *CustomerMutation) SetActiveProfileID(x xid.ID) {
	m.active_profile = &x
}

// ActiveProfileID returns the value of the "active_profile_id" field in the mutation.
func (m *CustomerMutation) ActiveProfileID() (r xid.ID, exists bool) {
	v := m.active_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveProfileID returns the old "active_profile_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldActiveProfileID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveProfileID: %w", err)
	}
	return oldValue.ActiveProfileID, nil
}

// ClearActiveProfileID clears the value of the "active_profile_id" field.
func (m *CustomerMutation) ClearActiveProfileID() {
	m.active_profile = nil
	m.clearedFields[customer.FieldActiveProfileID] = struct{}{}
}

// ActiveProfileIDCleared returns if the "active_profile_id" field was cleared in this mutation.
func (m *CustomerMutation) ActiveProfileIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldActiveProfileID]
	return ok
}

// ResetActiveProfileID resets all changes to the "active_profile_id" field.
func (m *CustomerMutation) ResetActiveProfileID() {
	m.active_profile = nil
	delete(m.clearedFields, customer.FieldActiveProfileID)
}

// SetPendingProfileID sets the "pending_profile_id" field.
func (m *CustomerMutation) SetPendingProfileID(x xid.ID) {
	m.pending_profile = &x
}

// PendingProfileID returns the value of the "pending_profile_id" field in the mutation.
func (m *CustomerMutation) PendingProfileID() (r xid.ID, exists bool) {
	v := m.pending_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingProfileID returns the old "pending_profile_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPendingProfileID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingProfileID: %w", err)
	}
	return oldValue.PendingProfileID, nil
}

// ClearPendingProfileID clears the value of the "pending_profile_id" field.
func (m *CustomerMutation) ClearPendingProfileID() {
	m.pending_profile = nil
	m.clearedFields[customer.FieldPendingProfileID] = struct{}{}
}

// PendingProfileIDCleared returns if the "pending_profile_id" field was cleared in this mutation.
func (m *CustomerMutation) PendingProfileIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldPendingProfileID]
	return ok
}

// ResetPendingProfileID resets all changes to the "pending_profile_id" field.
func (m *CustomerMutation) ResetPendingProfileID() {
	m.pending_profile = nil
	delete(m.clearedFields, customer.FieldPendingProfileID)
}

// ClearArea clears the "area" edge to the Area entity.
func (m *CustomerMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[customer.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *CustomerMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *CustomerMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *CustomerMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *CustomerMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *CustomerMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *CustomerMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *CustomerMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *CustomerMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *CustomerMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// ClearSales clears the "sales" edge to the User entity.
func (m *CustomerMutation) ClearSales() {
	m.clearedsales = true
	m.clearedFields[customer.FieldSalesID] = struct{}{}
}

// SalesCleared reports if the "sales" edge to the User entity was cleared.
func (m *CustomerMutation) SalesCleared() bool {
	return m.SalesIDCleared() || m.clearedsales
}

// SalesIDs returns the "sales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) SalesIDs() (ids []xid.ID) {
	if id := m.sales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *CustomerMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *CustomerMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[customer.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *CustomerMutation) CreatedByCleared() bool {
	return m.CreatedByIDCleared() || m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *CustomerMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// ClearUpdatedBy clears the "updated_by" edge to the User entity.
func (m *CustomerMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
	m.clearedFields[customer.FieldUpdatedByID] = struct{}{}
}

// UpdatedByCleared reports if the "updated_by" edge to the User entity was cleared.
func (m *CustomerMutation) UpdatedByCleared() bool {
	return m.UpdatedByIDCleared() || m.clearedupdated_by
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) UpdatedByIDs() (ids []xid.ID) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *CustomerMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// ClearApprover clears the "approver" edge to the User entity.
func (m *CustomerMutation) ClearApprover() {
	m.clearedapprover = true
	m.clearedFields[customer.FieldApproverID] = struct{}{}
}

// ApproverCleared reports if the "approver" edge to the User entity was cleared.
func (m *CustomerMutation) ApproverCleared() bool {
	return m.ApproverIDCleared() || m.clearedapprover
}

// ApproverIDs returns the "approver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApproverID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) ApproverIDs() (ids []xid.ID) {
	if id := m.approver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprover resets all changes to the "approver" edge.
func (m *CustomerMutation) ResetApprover() {
	m.approver = nil
	m.clearedapprover = false
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *CustomerMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *CustomerMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *CustomerMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *CustomerMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *CustomerMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *CustomerMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *CustomerMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// AddProfileIDs adds the "profiles" edge to the CustomerProfile entity by ids.
func (m *CustomerMutation) AddProfileIDs(ids ...xid.ID) {
	if m.profiles == nil {
		m.profiles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the CustomerProfile entity.
func (m *CustomerMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the CustomerProfile entity was cleared.
func (m *CustomerMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the CustomerProfile entity by IDs.
func (m *CustomerMutation) RemoveProfileIDs(ids ...xid.ID) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the CustomerProfile entity.
func (m *CustomerMutation) RemovedProfilesIDs() (ids []xid.ID) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *CustomerMutation) ProfilesIDs() (ids []xid.ID) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *CustomerMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// ClearActiveProfile clears the "active_profile" edge to the CustomerProfile entity.
func (m *CustomerMutation) ClearActiveProfile() {
	m.clearedactive_profile = true
	m.clearedFields[customer.FieldActiveProfileID] = struct{}{}
}

// ActiveProfileCleared reports if the "active_profile" edge to the CustomerProfile entity was cleared.
func (m *CustomerMutation) ActiveProfileCleared() bool {
	return m.ActiveProfileIDCleared() || m.clearedactive_profile
}

// ActiveProfileIDs returns the "active_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) ActiveProfileIDs() (ids []xid.ID) {
	if id := m.active_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveProfile resets all changes to the "active_profile" edge.
func (m *CustomerMutation) ResetActiveProfile() {
	m.active_profile = nil
	m.clearedactive_profile = false
}

// ClearPendingProfile clears the "pending_profile" edge to the CustomerProfile entity.
func (m *CustomerMutation) ClearPendingProfile() {
	m.clearedpending_profile = true
	m.clearedFields[customer.FieldPendingProfileID] = struct{}{}
}

// PendingProfileCleared reports if the "pending_profile" edge to the CustomerProfile entity was cleared.
func (m *CustomerMutation) PendingProfileCleared() bool {
	return m.PendingProfileIDCleared() || m.clearedpending_profile
}

// PendingProfileIDs returns the "pending_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PendingProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) PendingProfileIDs() (ids []xid.ID) {
	if id := m.pending_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPendingProfile resets all changes to the "pending_profile" edge.
func (m *CustomerMutation) ResetPendingProfile() {
	m.pending_profile = nil
	m.clearedpending_profile = false
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.approval_status != nil {
		fields = append(fields, customer.FieldApprovalStatus)
	}
	if m.owner_type != nil {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.industry != nil {
		fields = append(fields, customer.FieldIndustry)
	}
	if m.size != nil {
		fields = append(fields, customer.FieldSize)
	}
	if m.contact_person != nil {
		fields = append(fields, customer.FieldContactPerson)
	}
	if m.contact_person_position != nil {
		fields = append(fields, customer.FieldContactPersonPosition)
	}
	if m.contact_person_phone != nil {
		fields = append(fields, customer.FieldContactPersonPhone)
	}
	if m.contact_person_email != nil {
		fields = append(fields, customer.FieldContactPersonEmail)
	}
	if m.draft != nil {
		fields = append(fields, customer.FieldDraft)
	}
	if m.feishu_group != nil {
		fields = append(fields, customer.FieldFeishuGroup)
	}
	if m.area != nil {
		fields = append(fields, customer.FieldAreaID)
	}
	if m.sales != nil {
		fields = append(fields, customer.FieldSalesID)
	}
	if m.created_by != nil {
		fields = append(fields, customer.FieldCreatedByID)
	}
	if m.updated_by != nil {
		fields = append(fields, customer.FieldUpdatedByID)
	}
	if m.approver != nil {
		fields = append(fields, customer.FieldApproverID)
	}
	if m.active_profile != nil {
		fields = append(fields, customer.FieldActiveProfileID)
	}
	if m.pending_profile != nil {
		fields = append(fields, customer.FieldPendingProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldName:
		return m.Name()
	case customer.FieldApprovalStatus:
		return m.ApprovalStatus()
	case customer.FieldOwnerType:
		return m.OwnerType()
	case customer.FieldIndustry:
		return m.Industry()
	case customer.FieldSize:
		return m.Size()
	case customer.FieldContactPerson:
		return m.ContactPerson()
	case customer.FieldContactPersonPosition:
		return m.ContactPersonPosition()
	case customer.FieldContactPersonPhone:
		return m.ContactPersonPhone()
	case customer.FieldContactPersonEmail:
		return m.ContactPersonEmail()
	case customer.FieldDraft:
		return m.Draft()
	case customer.FieldFeishuGroup:
		return m.FeishuGroup()
	case customer.FieldAreaID:
		return m.AreaID()
	case customer.FieldSalesID:
		return m.SalesID()
	case customer.FieldCreatedByID:
		return m.CreatedByID()
	case customer.FieldUpdatedByID:
		return m.UpdatedByID()
	case customer.FieldApproverID:
		return m.ApproverID()
	case customer.FieldActiveProfileID:
		return m.ActiveProfileID()
	case customer.FieldPendingProfileID:
		return m.PendingProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case customer.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case customer.FieldIndustry:
		return m.OldIndustry(ctx)
	case customer.FieldSize:
		return m.OldSize(ctx)
	case customer.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case customer.FieldContactPersonPosition:
		return m.OldContactPersonPosition(ctx)
	case customer.FieldContactPersonPhone:
		return m.OldContactPersonPhone(ctx)
	case customer.FieldContactPersonEmail:
		return m.OldContactPersonEmail(ctx)
	case customer.FieldDraft:
		return m.OldDraft(ctx)
	case customer.FieldFeishuGroup:
		return m.OldFeishuGroup(ctx)
	case customer.FieldAreaID:
		return m.OldAreaID(ctx)
	case customer.FieldSalesID:
		return m.OldSalesID(ctx)
	case customer.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	case customer.FieldUpdatedByID:
		return m.OldUpdatedByID(ctx)
	case customer.FieldApproverID:
		return m.OldApproverID(ctx)
	case customer.FieldActiveProfileID:
		return m.OldActiveProfileID(ctx)
	case customer.FieldPendingProfileID:
		return m.OldPendingProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case customer.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case customer.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case customer.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case customer.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case customer.FieldContactPersonPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPosition(v)
		return nil
	case customer.FieldContactPersonPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPhone(v)
		return nil
	case customer.FieldContactPersonEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonEmail(v)
		return nil
	case customer.FieldDraft:
		v, ok := value.(*model.Customer)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDraft(v)
		return nil
	case customer.FieldFeishuGroup:
		v, ok := value.(*zht.Group)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeishuGroup(v)
		return nil
	case customer.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case customer.FieldSalesID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case customer.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	case customer.FieldUpdatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByID(v)
		return nil
	case customer.FieldApproverID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case customer.FieldActiveProfileID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveProfileID(v)
		return nil
	case customer.FieldPendingProfileID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	if m.addapproval_status != nil {
		fields = append(fields, customer.FieldApprovalStatus)
	}
	if m.addowner_type != nil {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.addindustry != nil {
		fields = append(fields, customer.FieldIndustry)
	}
	if m.addsize != nil {
		fields = append(fields, customer.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldApprovalStatus:
		return m.AddedApprovalStatus()
	case customer.FieldOwnerType:
		return m.AddedOwnerType()
	case customer.FieldIndustry:
		return m.AddedIndustry()
	case customer.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customer.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovalStatus(v)
		return nil
	case customer.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerType(v)
		return nil
	case customer.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndustry(v)
		return nil
	case customer.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldOwnerType) {
		fields = append(fields, customer.FieldOwnerType)
	}
	if m.FieldCleared(customer.FieldIndustry) {
		fields = append(fields, customer.FieldIndustry)
	}
	if m.FieldCleared(customer.FieldSize) {
		fields = append(fields, customer.FieldSize)
	}
	if m.FieldCleared(customer.FieldContactPerson) {
		fields = append(fields, customer.FieldContactPerson)
	}
	if m.FieldCleared(customer.FieldContactPersonPosition) {
		fields = append(fields, customer.FieldContactPersonPosition)
	}
	if m.FieldCleared(customer.FieldContactPersonPhone) {
		fields = append(fields, customer.FieldContactPersonPhone)
	}
	if m.FieldCleared(customer.FieldContactPersonEmail) {
		fields = append(fields, customer.FieldContactPersonEmail)
	}
	if m.FieldCleared(customer.FieldDraft) {
		fields = append(fields, customer.FieldDraft)
	}
	if m.FieldCleared(customer.FieldFeishuGroup) {
		fields = append(fields, customer.FieldFeishuGroup)
	}
	if m.FieldCleared(customer.FieldSalesID) {
		fields = append(fields, customer.FieldSalesID)
	}
	if m.FieldCleared(customer.FieldCreatedByID) {
		fields = append(fields, customer.FieldCreatedByID)
	}
	if m.FieldCleared(customer.FieldUpdatedByID) {
		fields = append(fields, customer.FieldUpdatedByID)
	}
	if m.FieldCleared(customer.FieldApproverID) {
		fields = append(fields, customer.FieldApproverID)
	}
	if m.FieldCleared(customer.FieldActiveProfileID) {
		fields = append(fields, customer.FieldActiveProfileID)
	}
	if m.FieldCleared(customer.FieldPendingProfileID) {
		fields = append(fields, customer.FieldPendingProfileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldOwnerType:
		m.ClearOwnerType()
		return nil
	case customer.FieldIndustry:
		m.ClearIndustry()
		return nil
	case customer.FieldSize:
		m.ClearSize()
		return nil
	case customer.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case customer.FieldContactPersonPosition:
		m.ClearContactPersonPosition()
		return nil
	case customer.FieldContactPersonPhone:
		m.ClearContactPersonPhone()
		return nil
	case customer.FieldContactPersonEmail:
		m.ClearContactPersonEmail()
		return nil
	case customer.FieldDraft:
		m.ClearDraft()
		return nil
	case customer.FieldFeishuGroup:
		m.ClearFeishuGroup()
		return nil
	case customer.FieldSalesID:
		m.ClearSalesID()
		return nil
	case customer.FieldCreatedByID:
		m.ClearCreatedByID()
		return nil
	case customer.FieldUpdatedByID:
		m.ClearUpdatedByID()
		return nil
	case customer.FieldApproverID:
		m.ClearApproverID()
		return nil
	case customer.FieldActiveProfileID:
		m.ClearActiveProfileID()
		return nil
	case customer.FieldPendingProfileID:
		m.ClearPendingProfileID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case customer.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case customer.FieldIndustry:
		m.ResetIndustry()
		return nil
	case customer.FieldSize:
		m.ResetSize()
		return nil
	case customer.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case customer.FieldContactPersonPosition:
		m.ResetContactPersonPosition()
		return nil
	case customer.FieldContactPersonPhone:
		m.ResetContactPersonPhone()
		return nil
	case customer.FieldContactPersonEmail:
		m.ResetContactPersonEmail()
		return nil
	case customer.FieldDraft:
		m.ResetDraft()
		return nil
	case customer.FieldFeishuGroup:
		m.ResetFeishuGroup()
		return nil
	case customer.FieldAreaID:
		m.ResetAreaID()
		return nil
	case customer.FieldSalesID:
		m.ResetSalesID()
		return nil
	case customer.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	case customer.FieldUpdatedByID:
		m.ResetUpdatedByID()
		return nil
	case customer.FieldApproverID:
		m.ResetApproverID()
		return nil
	case customer.FieldActiveProfileID:
		m.ResetActiveProfileID()
		return nil
	case customer.FieldPendingProfileID:
		m.ResetPendingProfileID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.area != nil {
		edges = append(edges, customer.EdgeArea)
	}
	if m.tenders != nil {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.sales != nil {
		edges = append(edges, customer.EdgeSales)
	}
	if m.created_by != nil {
		edges = append(edges, customer.EdgeCreatedBy)
	}
	if m.updated_by != nil {
		edges = append(edges, customer.EdgeUpdatedBy)
	}
	if m.approver != nil {
		edges = append(edges, customer.EdgeApprover)
	}
	if m.visit_records != nil {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	if m.profiles != nil {
		edges = append(edges, customer.EdgeProfiles)
	}
	if m.active_profile != nil {
		edges = append(edges, customer.EdgeActiveProfile)
	}
	if m.pending_profile != nil {
		edges = append(edges, customer.EdgePendingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeSales:
		if id := m.sales; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeApprover:
		if id := m.approver; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeActiveProfile:
		if id := m.active_profile; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgePendingProfile:
		if id := m.pending_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedtenders != nil {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	if m.removedprofiles != nil {
		edges = append(edges, customer.EdgeProfiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedarea {
		edges = append(edges, customer.EdgeArea)
	}
	if m.clearedtenders {
		edges = append(edges, customer.EdgeTenders)
	}
	if m.clearedsales {
		edges = append(edges, customer.EdgeSales)
	}
	if m.clearedcreated_by {
		edges = append(edges, customer.EdgeCreatedBy)
	}
	if m.clearedupdated_by {
		edges = append(edges, customer.EdgeUpdatedBy)
	}
	if m.clearedapprover {
		edges = append(edges, customer.EdgeApprover)
	}
	if m.clearedvisit_records {
		edges = append(edges, customer.EdgeVisitRecords)
	}
	if m.clearedprofiles {
		edges = append(edges, customer.EdgeProfiles)
	}
	if m.clearedactive_profile {
		edges = append(edges, customer.EdgeActiveProfile)
	}
	if m.clearedpending_profile {
		edges = append(edges, customer.EdgePendingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeArea:
		return m.clearedarea
	case customer.EdgeTenders:
		return m.clearedtenders
	case customer.EdgeSales:
		return m.clearedsales
	case customer.EdgeCreatedBy:
		return m.clearedcreated_by
	case customer.EdgeUpdatedBy:
		return m.clearedupdated_by
	case customer.EdgeApprover:
		return m.clearedapprover
	case customer.EdgeVisitRecords:
		return m.clearedvisit_records
	case customer.EdgeProfiles:
		return m.clearedprofiles
	case customer.EdgeActiveProfile:
		return m.clearedactive_profile
	case customer.EdgePendingProfile:
		return m.clearedpending_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeArea:
		m.ClearArea()
		return nil
	case customer.EdgeSales:
		m.ClearSales()
		return nil
	case customer.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case customer.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case customer.EdgeApprover:
		m.ClearApprover()
		return nil
	case customer.EdgeActiveProfile:
		m.ClearActiveProfile()
		return nil
	case customer.EdgePendingProfile:
		m.ClearPendingProfile()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeArea:
		m.ResetArea()
		return nil
	case customer.EdgeTenders:
		m.ResetTenders()
		return nil
	case customer.EdgeSales:
		m.ResetSales()
		return nil
	case customer.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case customer.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case customer.EdgeApprover:
		m.ResetApprover()
		return nil
	case customer.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	case customer.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case customer.EdgeActiveProfile:
		m.ResetActiveProfile()
		return nil
	case customer.EdgePendingProfile:
		m.ResetPendingProfile()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerProfileMutation represents an operation that mutates the CustomerProfile nodes in the graph.
type CustomerProfileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *xid.ID
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	approval_status         *int
	addapproval_status      *int
	owner_type              *int
	addowner_type           *int
	industry                *int
	addindustry             *int
	size                    *int
	addsize                 *int
	contact_person          *string
	contact_person_position *string
	contact_person_phone    *string
	contact_person_email    *string
	clearedFields           map[string]struct{}
	customer                *xid.ID
	clearedcustomer         bool
	created_by              *xid.ID
	clearedcreated_by       bool
	approver                *xid.ID
	clearedapprover         bool
	sales                   *xid.ID
	clearedsales            bool
	done                    bool
	oldValue                func(context.Context) (*CustomerProfile, error)
	predicates              []predicate.CustomerProfile
}

var _ ent.Mutation = (*CustomerProfileMutation)(nil)

// customerprofileOption allows management of the mutation configuration using functional options.
type customerprofileOption func(*CustomerProfileMutation)

// newCustomerProfileMutation creates new mutation for the CustomerProfile entity.
func newCustomerProfileMutation(c config, op Op, opts ...customerprofileOption) *CustomerProfileMutation {
	m := &CustomerProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerProfileID sets the ID field of the mutation.
func withCustomerProfileID(id xid.ID) customerprofileOption {
	return func(m *CustomerProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerProfile
		)
		m.oldValue = func(ctx context.Context) (*CustomerProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerProfile sets the old CustomerProfile of the mutation.
func withCustomerProfile(node *CustomerProfile) customerprofileOption {
	return func(m *CustomerProfileMutation) {
		m.oldValue = func(context.Context) (*CustomerProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerProfile entities.
func (m *CustomerProfileMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerProfileMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerProfileMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CustomerProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerProfileMutation) ResetName() {
	m.name = nil
}

// SetApprovalStatus sets the "approval_status" field.
func (m *CustomerProfileMutation) SetApprovalStatus(i int) {
	m.approval_status = &i
	m.addapproval_status = nil
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *CustomerProfileMutation) ApprovalStatus() (r int, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldApprovalStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// AddApprovalStatus adds i to the "approval_status" field.
func (m *CustomerProfileMutation) AddApprovalStatus(i int) {
	if m.addapproval_status != nil {
		*m.addapproval_status += i
	} else {
		m.addapproval_status = &i
	}
}

// AddedApprovalStatus returns the value that was added to the "approval_status" field in this mutation.
func (m *CustomerProfileMutation) AddedApprovalStatus() (r int, exists bool) {
	v := m.addapproval_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *CustomerProfileMutation) ResetApprovalStatus() {
	m.approval_status = nil
	m.addapproval_status = nil
}

// SetOwnerType sets the "owner_type" field.
func (m *CustomerProfileMutation) SetOwnerType(i int) {
	m.owner_type = &i
	m.addowner_type = nil
}

// OwnerType returns the value of the "owner_type" field in the mutation.
func (m *CustomerProfileMutation) OwnerType() (r int, exists bool) {
	v := m.owner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerType returns the old "owner_type" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldOwnerType(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerType: %w", err)
	}
	return oldValue.OwnerType, nil
}

// AddOwnerType adds i to the "owner_type" field.
func (m *CustomerProfileMutation) AddOwnerType(i int) {
	if m.addowner_type != nil {
		*m.addowner_type += i
	} else {
		m.addowner_type = &i
	}
}

// AddedOwnerType returns the value that was added to the "owner_type" field in this mutation.
func (m *CustomerProfileMutation) AddedOwnerType() (r int, exists bool) {
	v := m.addowner_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerType clears the value of the "owner_type" field.
func (m *CustomerProfileMutation) ClearOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	m.clearedFields[customerprofile.FieldOwnerType] = struct{}{}
}

// OwnerTypeCleared returns if the "owner_type" field was cleared in this mutation.
func (m *CustomerProfileMutation) OwnerTypeCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldOwnerType]
	return ok
}

// ResetOwnerType resets all changes to the "owner_type" field.
func (m *CustomerProfileMutation) ResetOwnerType() {
	m.owner_type = nil
	m.addowner_type = nil
	delete(m.clearedFields, customerprofile.FieldOwnerType)
}

// SetIndustry sets the "industry" field.
func (m *CustomerProfileMutation) SetIndustry(i int) {
	m.industry = &i
	m.addindustry = nil
}

// Industry returns the value of the "industry" field in the mutation.
func (m *CustomerProfileMutation) Industry() (r int, exists bool) {
	v := m.industry
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustry returns the old "industry" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldIndustry(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustry: %w", err)
	}
	return oldValue.Industry, nil
}

// AddIndustry adds i to the "industry" field.
func (m *CustomerProfileMutation) AddIndustry(i int) {
	if m.addindustry != nil {
		*m.addindustry += i
	} else {
		m.addindustry = &i
	}
}

// AddedIndustry returns the value that was added to the "industry" field in this mutation.
func (m *CustomerProfileMutation) AddedIndustry() (r int, exists bool) {
	v := m.addindustry
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndustry clears the value of the "industry" field.
func (m *CustomerProfileMutation) ClearIndustry() {
	m.industry = nil
	m.addindustry = nil
	m.clearedFields[customerprofile.FieldIndustry] = struct{}{}
}

// IndustryCleared returns if the "industry" field was cleared in this mutation.
func (m *CustomerProfileMutation) IndustryCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldIndustry]
	return ok
}

// ResetIndustry resets all changes to the "industry" field.
func (m *CustomerProfileMutation) ResetIndustry() {
	m.industry = nil
	m.addindustry = nil
	delete(m.clearedFields, customerprofile.FieldIndustry)
}

// SetSize sets the "size" field.
func (m *CustomerProfileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CustomerProfileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldSize(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *CustomerProfileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CustomerProfileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *CustomerProfileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[customerprofile.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *CustomerProfileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *CustomerProfileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, customerprofile.FieldSize)
}

// SetContactPerson sets the "contact_person" field.
func (m *CustomerProfileMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *CustomerProfileMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldContactPerson(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *CustomerProfileMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[customerprofile.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *CustomerProfileMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *CustomerProfileMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, customerprofile.FieldContactPerson)
}

// SetContactPersonPosition sets the "contact_person_position" field.
func (m *CustomerProfileMutation) SetContactPersonPosition(s string) {
	m.contact_person_position = &s
}

// ContactPersonPosition returns the value of the "contact_person_position" field in the mutation.
func (m *CustomerProfileMutation) ContactPersonPosition() (r string, exists bool) {
	v := m.contact_person_position
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPosition returns the old "contact_person_position" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldContactPersonPosition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPosition: %w", err)
	}
	return oldValue.ContactPersonPosition, nil
}

// ClearContactPersonPosition clears the value of the "contact_person_position" field.
func (m *CustomerProfileMutation) ClearContactPersonPosition() {
	m.contact_person_position = nil
	m.clearedFields[customerprofile.FieldContactPersonPosition] = struct{}{}
}

// ContactPersonPositionCleared returns if the "contact_person_position" field was cleared in this mutation.
func (m *CustomerProfileMutation) ContactPersonPositionCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldContactPersonPosition]
	return ok
}

// ResetContactPersonPosition resets all changes to the "contact_person_position" field.
func (m *CustomerProfileMutation) ResetContactPersonPosition() {
	m.contact_person_position = nil
	delete(m.clearedFields, customerprofile.FieldContactPersonPosition)
}

// SetContactPersonPhone sets the "contact_person_phone" field.
func (m *CustomerProfileMutation) SetContactPersonPhone(s string) {
	m.contact_person_phone = &s
}

// ContactPersonPhone returns the value of the "contact_person_phone" field in the mutation.
func (m *CustomerProfileMutation) ContactPersonPhone() (r string, exists bool) {
	v := m.contact_person_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonPhone returns the old "contact_person_phone" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldContactPersonPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonPhone: %w", err)
	}
	return oldValue.ContactPersonPhone, nil
}

// ClearContactPersonPhone clears the value of the "contact_person_phone" field.
func (m *CustomerProfileMutation) ClearContactPersonPhone() {
	m.contact_person_phone = nil
	m.clearedFields[customerprofile.FieldContactPersonPhone] = struct{}{}
}

// ContactPersonPhoneCleared returns if the "contact_person_phone" field was cleared in this mutation.
func (m *CustomerProfileMutation) ContactPersonPhoneCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldContactPersonPhone]
	return ok
}

// ResetContactPersonPhone resets all changes to the "contact_person_phone" field.
func (m *CustomerProfileMutation) ResetContactPersonPhone() {
	m.contact_person_phone = nil
	delete(m.clearedFields, customerprofile.FieldContactPersonPhone)
}

// SetContactPersonEmail sets the "contact_person_email" field.
func (m *CustomerProfileMutation) SetContactPersonEmail(s string) {
	m.contact_person_email = &s
}

// ContactPersonEmail returns the value of the "contact_person_email" field in the mutation.
func (m *CustomerProfileMutation) ContactPersonEmail() (r string, exists bool) {
	v := m.contact_person_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPersonEmail returns the old "contact_person_email" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldContactPersonEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPersonEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPersonEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPersonEmail: %w", err)
	}
	return oldValue.ContactPersonEmail, nil
}

// ClearContactPersonEmail clears the value of the "contact_person_email" field.
func (m *CustomerProfileMutation) ClearContactPersonEmail() {
	m.contact_person_email = nil
	m.clearedFields[customerprofile.FieldContactPersonEmail] = struct{}{}
}

// ContactPersonEmailCleared returns if the "contact_person_email" field was cleared in this mutation.
func (m *CustomerProfileMutation) ContactPersonEmailCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldContactPersonEmail]
	return ok
}

// ResetContactPersonEmail resets all changes to the "contact_person_email" field.
func (m *CustomerProfileMutation) ResetContactPersonEmail() {
	m.contact_person_email = nil
	delete(m.clearedFields, customerprofile.FieldContactPersonEmail)
}

// SetSalesID sets the "sales_id" field.
func (m *CustomerProfileMutation) SetSalesID(x xid.ID) {
	m.sales = &x
}

// SalesID returns the value of the "sales_id" field in the mutation.
func (m *CustomerProfileMutation) SalesID() (r xid.ID, exists bool) {
	v := m.sales
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesID returns the old "sales_id" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldSalesID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesID: %w", err)
	}
	return oldValue.SalesID, nil
}

// ClearSalesID clears the value of the "sales_id" field.
func (m *CustomerProfileMutation) ClearSalesID() {
	m.sales = nil
	m.clearedFields[customerprofile.FieldSalesID] = struct{}{}
}

// SalesIDCleared returns if the "sales_id" field was cleared in this mutation.
func (m *CustomerProfileMutation) SalesIDCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldSalesID]
	return ok
}

// ResetSalesID resets all changes to the "sales_id" field.
func (m *CustomerProfileMutation) ResetSalesID() {
	m.sales = nil
	delete(m.clearedFields, customerprofile.FieldSalesID)
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerProfileMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerProfileMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldCustomerID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerProfileMutation) ResetCustomerID() {
	m.customer = nil
}

// SetCreatedByID sets the "created_by_id" field.
func (m *CustomerProfileMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *CustomerProfileMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldCreatedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ClearCreatedByID clears the value of the "created_by_id" field.
func (m *CustomerProfileMutation) ClearCreatedByID() {
	m.created_by = nil
	m.clearedFields[customerprofile.FieldCreatedByID] = struct{}{}
}

// CreatedByIDCleared returns if the "created_by_id" field was cleared in this mutation.
func (m *CustomerProfileMutation) CreatedByIDCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldCreatedByID]
	return ok
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *CustomerProfileMutation) ResetCreatedByID() {
	m.created_by = nil
	delete(m.clearedFields, customerprofile.FieldCreatedByID)
}

// SetApproverID sets the "approver_id" field.
func (m *CustomerProfileMutation) SetApproverID(x xid.ID) {
	m.approver = &x
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *CustomerProfileMutation) ApproverID() (r xid.ID, exists bool) {
	v := m.approver
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the CustomerProfile entity.
// If the CustomerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerProfileMutation) OldApproverID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *CustomerProfileMutation) ClearApproverID() {
	m.approver = nil
	m.clearedFields[customerprofile.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *CustomerProfileMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[customerprofile.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *CustomerProfileMutation) ResetApproverID() {
	m.approver = nil
	delete(m.clearedFields, customerprofile.FieldApproverID)
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerProfileMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customerprofile.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerProfileMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerProfileMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerProfileMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *CustomerProfileMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[customerprofile.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *CustomerProfileMutation) CreatedByCleared() bool {
	return m.CreatedByIDCleared() || m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *CustomerProfileMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *CustomerProfileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// ClearApprover clears the "approver" edge to the User entity.
func (m *CustomerProfileMutation) ClearApprover() {
	m.clearedapprover = true
	m.clearedFields[customerprofile.FieldApproverID] = struct{}{}
}

// ApproverCleared reports if the "approver" edge to the User entity was cleared.
func (m *CustomerProfileMutation) ApproverCleared() bool {
	return m.ApproverIDCleared() || m.clearedapprover
}

// ApproverIDs returns the "approver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApproverID instead. It exists only for internal usage by the builders.
func (m *CustomerProfileMutation) ApproverIDs() (ids []xid.ID) {
	if id := m.approver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprover resets all changes to the "approver" edge.
func (m *CustomerProfileMutation) ResetApprover() {
	m.approver = nil
	m.clearedapprover = false
}

// ClearSales clears the "sales" edge to the User entity.
func (m *CustomerProfileMutation) ClearSales() {
	m.clearedsales = true
	m.clearedFields[customerprofile.FieldSalesID] = struct{}{}
}

// SalesCleared reports if the "sales" edge to the User entity was cleared.
func (m *CustomerProfileMutation) SalesCleared() bool {
	return m.SalesIDCleared() || m.clearedsales
}

// SalesIDs returns the "sales" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesID instead. It exists only for internal usage by the builders.
func (m *CustomerProfileMutation) SalesIDs() (ids []xid.ID) {
	if id := m.sales; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *CustomerProfileMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
}

// Where appends a list predicates to the CustomerProfileMutation builder.
func (m *CustomerProfileMutation) Where(ps ...predicate.CustomerProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerProfile).
func (m *CustomerProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerProfileMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, customerprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customerprofile.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, customerprofile.FieldName)
	}
	if m.approval_status != nil {
		fields = append(fields, customerprofile.FieldApprovalStatus)
	}
	if m.owner_type != nil {
		fields = append(fields, customerprofile.FieldOwnerType)
	}
	if m.industry != nil {
		fields = append(fields, customerprofile.FieldIndustry)
	}
	if m.size != nil {
		fields = append(fields, customerprofile.FieldSize)
	}
	if m.contact_person != nil {
		fields = append(fields, customerprofile.FieldContactPerson)
	}
	if m.contact_person_position != nil {
		fields = append(fields, customerprofile.FieldContactPersonPosition)
	}
	if m.contact_person_phone != nil {
		fields = append(fields, customerprofile.FieldContactPersonPhone)
	}
	if m.contact_person_email != nil {
		fields = append(fields, customerprofile.FieldContactPersonEmail)
	}
	if m.sales != nil {
		fields = append(fields, customerprofile.FieldSalesID)
	}
	if m.customer != nil {
		fields = append(fields, customerprofile.FieldCustomerID)
	}
	if m.created_by != nil {
		fields = append(fields, customerprofile.FieldCreatedByID)
	}
	if m.approver != nil {
		fields = append(fields, customerprofile.FieldApproverID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customerprofile.FieldCreatedAt:
		return m.CreatedAt()
	case customerprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case customerprofile.FieldName:
		return m.Name()
	case customerprofile.FieldApprovalStatus:
		return m.ApprovalStatus()
	case customerprofile.FieldOwnerType:
		return m.OwnerType()
	case customerprofile.FieldIndustry:
		return m.Industry()
	case customerprofile.FieldSize:
		return m.Size()
	case customerprofile.FieldContactPerson:
		return m.ContactPerson()
	case customerprofile.FieldContactPersonPosition:
		return m.ContactPersonPosition()
	case customerprofile.FieldContactPersonPhone:
		return m.ContactPersonPhone()
	case customerprofile.FieldContactPersonEmail:
		return m.ContactPersonEmail()
	case customerprofile.FieldSalesID:
		return m.SalesID()
	case customerprofile.FieldCustomerID:
		return m.CustomerID()
	case customerprofile.FieldCreatedByID:
		return m.CreatedByID()
	case customerprofile.FieldApproverID:
		return m.ApproverID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customerprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customerprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customerprofile.FieldName:
		return m.OldName(ctx)
	case customerprofile.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case customerprofile.FieldOwnerType:
		return m.OldOwnerType(ctx)
	case customerprofile.FieldIndustry:
		return m.OldIndustry(ctx)
	case customerprofile.FieldSize:
		return m.OldSize(ctx)
	case customerprofile.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case customerprofile.FieldContactPersonPosition:
		return m.OldContactPersonPosition(ctx)
	case customerprofile.FieldContactPersonPhone:
		return m.OldContactPersonPhone(ctx)
	case customerprofile.FieldContactPersonEmail:
		return m.OldContactPersonEmail(ctx)
	case customerprofile.FieldSalesID:
		return m.OldSalesID(ctx)
	case customerprofile.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customerprofile.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	case customerprofile.FieldApproverID:
		return m.OldApproverID(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customerprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customerprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customerprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customerprofile.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case customerprofile.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerType(v)
		return nil
	case customerprofile.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustry(v)
		return nil
	case customerprofile.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case customerprofile.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case customerprofile.FieldContactPersonPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPosition(v)
		return nil
	case customerprofile.FieldContactPersonPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonPhone(v)
		return nil
	case customerprofile.FieldContactPersonEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPersonEmail(v)
		return nil
	case customerprofile.FieldSalesID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesID(v)
		return nil
	case customerprofile.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customerprofile.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	case customerprofile.FieldApproverID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerProfileMutation) AddedFields() []string {
	var fields []string
	if m.addapproval_status != nil {
		fields = append(fields, customerprofile.FieldApprovalStatus)
	}
	if m.addowner_type != nil {
		fields = append(fields, customerprofile.FieldOwnerType)
	}
	if m.addindustry != nil {
		fields = append(fields, customerprofile.FieldIndustry)
	}
	if m.addsize != nil {
		fields = append(fields, customerprofile.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customerprofile.FieldApprovalStatus:
		return m.AddedApprovalStatus()
	case customerprofile.FieldOwnerType:
		return m.AddedOwnerType()
	case customerprofile.FieldIndustry:
		return m.AddedIndustry()
	case customerprofile.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customerprofile.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovalStatus(v)
		return nil
	case customerprofile.FieldOwnerType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerType(v)
		return nil
	case customerprofile.FieldIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndustry(v)
		return nil
	case customerprofile.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customerprofile.FieldOwnerType) {
		fields = append(fields, customerprofile.FieldOwnerType)
	}
	if m.FieldCleared(customerprofile.FieldIndustry) {
		fields = append(fields, customerprofile.FieldIndustry)
	}
	if m.FieldCleared(customerprofile.FieldSize) {
		fields = append(fields, customerprofile.FieldSize)
	}
	if m.FieldCleared(customerprofile.FieldContactPerson) {
		fields = append(fields, customerprofile.FieldContactPerson)
	}
	if m.FieldCleared(customerprofile.FieldContactPersonPosition) {
		fields = append(fields, customerprofile.FieldContactPersonPosition)
	}
	if m.FieldCleared(customerprofile.FieldContactPersonPhone) {
		fields = append(fields, customerprofile.FieldContactPersonPhone)
	}
	if m.FieldCleared(customerprofile.FieldContactPersonEmail) {
		fields = append(fields, customerprofile.FieldContactPersonEmail)
	}
	if m.FieldCleared(customerprofile.FieldSalesID) {
		fields = append(fields, customerprofile.FieldSalesID)
	}
	if m.FieldCleared(customerprofile.FieldCreatedByID) {
		fields = append(fields, customerprofile.FieldCreatedByID)
	}
	if m.FieldCleared(customerprofile.FieldApproverID) {
		fields = append(fields, customerprofile.FieldApproverID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerProfileMutation) ClearField(name string) error {
	switch name {
	case customerprofile.FieldOwnerType:
		m.ClearOwnerType()
		return nil
	case customerprofile.FieldIndustry:
		m.ClearIndustry()
		return nil
	case customerprofile.FieldSize:
		m.ClearSize()
		return nil
	case customerprofile.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case customerprofile.FieldContactPersonPosition:
		m.ClearContactPersonPosition()
		return nil
	case customerprofile.FieldContactPersonPhone:
		m.ClearContactPersonPhone()
		return nil
	case customerprofile.FieldContactPersonEmail:
		m.ClearContactPersonEmail()
		return nil
	case customerprofile.FieldSalesID:
		m.ClearSalesID()
		return nil
	case customerprofile.FieldCreatedByID:
		m.ClearCreatedByID()
		return nil
	case customerprofile.FieldApproverID:
		m.ClearApproverID()
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerProfileMutation) ResetField(name string) error {
	switch name {
	case customerprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customerprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customerprofile.FieldName:
		m.ResetName()
		return nil
	case customerprofile.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case customerprofile.FieldOwnerType:
		m.ResetOwnerType()
		return nil
	case customerprofile.FieldIndustry:
		m.ResetIndustry()
		return nil
	case customerprofile.FieldSize:
		m.ResetSize()
		return nil
	case customerprofile.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case customerprofile.FieldContactPersonPosition:
		m.ResetContactPersonPosition()
		return nil
	case customerprofile.FieldContactPersonPhone:
		m.ResetContactPersonPhone()
		return nil
	case customerprofile.FieldContactPersonEmail:
		m.ResetContactPersonEmail()
		return nil
	case customerprofile.FieldSalesID:
		m.ResetSalesID()
		return nil
	case customerprofile.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customerprofile.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	case customerprofile.FieldApproverID:
		m.ResetApproverID()
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.customer != nil {
		edges = append(edges, customerprofile.EdgeCustomer)
	}
	if m.created_by != nil {
		edges = append(edges, customerprofile.EdgeCreatedBy)
	}
	if m.approver != nil {
		edges = append(edges, customerprofile.EdgeApprover)
	}
	if m.sales != nil {
		edges = append(edges, customerprofile.EdgeSales)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customerprofile.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customerprofile.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case customerprofile.EdgeApprover:
		if id := m.approver; id != nil {
			return []ent.Value{*id}
		}
	case customerprofile.EdgeSales:
		if id := m.sales; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcustomer {
		edges = append(edges, customerprofile.EdgeCustomer)
	}
	if m.clearedcreated_by {
		edges = append(edges, customerprofile.EdgeCreatedBy)
	}
	if m.clearedapprover {
		edges = append(edges, customerprofile.EdgeApprover)
	}
	if m.clearedsales {
		edges = append(edges, customerprofile.EdgeSales)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case customerprofile.EdgeCustomer:
		return m.clearedcustomer
	case customerprofile.EdgeCreatedBy:
		return m.clearedcreated_by
	case customerprofile.EdgeApprover:
		return m.clearedapprover
	case customerprofile.EdgeSales:
		return m.clearedsales
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerProfileMutation) ClearEdge(name string) error {
	switch name {
	case customerprofile.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customerprofile.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case customerprofile.EdgeApprover:
		m.ClearApprover()
		return nil
	case customerprofile.EdgeSales:
		m.ClearSales()
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerProfileMutation) ResetEdge(name string) error {
	switch name {
	case customerprofile.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customerprofile.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case customerprofile.EdgeApprover:
		m.ResetApprover()
		return nil
	case customerprofile.EdgeSales:
		m.ResetSales()
		return nil
	}
	return fmt.Errorf("unknown CustomerProfile edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	updated_at      *time.Time
	adcode          *int
	addadcode       *int
	prov_code       *int
	addprov_code    *int
	city_code       *int
	addcity_code    *int
	name            *string
	center          **geo.GeoJson
	clearedFields   map[string]struct{}
	province        *xid.ID
	clearedprovince bool
	city            *xid.ID
	clearedcity     bool
	tenders         map[xid.ID]struct{}
	removedtenders  map[xid.ID]struct{}
	clearedtenders  bool
	plots           map[xid.ID]struct{}
	removedplots    map[xid.ID]struct{}
	clearedplots    bool
	done            bool
	oldValue        func(context.Context) (*District, error)
	predicates      []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id xid.ID) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of District entities.
func (m *DistrictMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DistrictMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DistrictMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DistrictMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DistrictMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DistrictMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DistrictMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *DistrictMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *DistrictMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *DistrictMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *DistrictMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *DistrictMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetProvCode sets the "prov_code" field.
func (m *DistrictMutation) SetProvCode(i int) {
	m.prov_code = &i
	m.addprov_code = nil
}

// ProvCode returns the value of the "prov_code" field in the mutation.
func (m *DistrictMutation) ProvCode() (r int, exists bool) {
	v := m.prov_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProvCode returns the old "prov_code" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldProvCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvCode: %w", err)
	}
	return oldValue.ProvCode, nil
}

// AddProvCode adds i to the "prov_code" field.
func (m *DistrictMutation) AddProvCode(i int) {
	if m.addprov_code != nil {
		*m.addprov_code += i
	} else {
		m.addprov_code = &i
	}
}

// AddedProvCode returns the value that was added to the "prov_code" field in this mutation.
func (m *DistrictMutation) AddedProvCode() (r int, exists bool) {
	v := m.addprov_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetProvCode resets all changes to the "prov_code" field.
func (m *DistrictMutation) ResetProvCode() {
	m.prov_code = nil
	m.addprov_code = nil
}

// SetCityCode sets the "city_code" field.
func (m *DistrictMutation) SetCityCode(i int) {
	m.city_code = &i
	m.addcity_code = nil
}

// CityCode returns the value of the "city_code" field in the mutation.
func (m *DistrictMutation) CityCode() (r int, exists bool) {
	v := m.city_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCityCode returns the old "city_code" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCityCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityCode: %w", err)
	}
	return oldValue.CityCode, nil
}

// AddCityCode adds i to the "city_code" field.
func (m *DistrictMutation) AddCityCode(i int) {
	if m.addcity_code != nil {
		*m.addcity_code += i
	} else {
		m.addcity_code = &i
	}
}

// AddedCityCode returns the value that was added to the "city_code" field in this mutation.
func (m *DistrictMutation) AddedCityCode() (r int, exists bool) {
	v := m.addcity_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetCityCode resets all changes to the "city_code" field.
func (m *DistrictMutation) ResetCityCode() {
	m.city_code = nil
	m.addcity_code = nil
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *DistrictMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *DistrictMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *DistrictMutation) ResetCenter() {
	m.center = nil
}

// SetProvinceID sets the "province_id" field.
func (m *DistrictMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *DistrictMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldProvinceID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *DistrictMutation) ResetProvinceID() {
	m.province = nil
}

// SetCityID sets the "city_id" field.
func (m *DistrictMutation) SetCityID(x xid.ID) {
	m.city = &x
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *DistrictMutation) CityID() (r xid.ID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldCityID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *DistrictMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[district.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *DistrictMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[district.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *DistrictMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, district.FieldCityID)
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *DistrictMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[district.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *DistrictMutation) ProvinceCleared() bool {
	return m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *DistrictMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *DistrictMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[district.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *DistrictMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *DistrictMutation) CityIDs() (ids []xid.ID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *DistrictMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *DistrictMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *DistrictMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *DistrictMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *DistrictMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *DistrictMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *DistrictMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *DistrictMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddPlotIDs adds the "plots" edge to the Plot entity by ids.
func (m *DistrictMutation) AddPlotIDs(ids ...xid.ID) {
	if m.plots == nil {
		m.plots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.plots[ids[i]] = struct{}{}
	}
}

// ClearPlots clears the "plots" edge to the Plot entity.
func (m *DistrictMutation) ClearPlots() {
	m.clearedplots = true
}

// PlotsCleared reports if the "plots" edge to the Plot entity was cleared.
func (m *DistrictMutation) PlotsCleared() bool {
	return m.clearedplots
}

// RemovePlotIDs removes the "plots" edge to the Plot entity by IDs.
func (m *DistrictMutation) RemovePlotIDs(ids ...xid.ID) {
	if m.removedplots == nil {
		m.removedplots = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.plots, ids[i])
		m.removedplots[ids[i]] = struct{}{}
	}
}

// RemovedPlots returns the removed IDs of the "plots" edge to the Plot entity.
func (m *DistrictMutation) RemovedPlotsIDs() (ids []xid.ID) {
	for id := range m.removedplots {
		ids = append(ids, id)
	}
	return
}

// PlotsIDs returns the "plots" edge IDs in the mutation.
func (m *DistrictMutation) PlotsIDs() (ids []xid.ID) {
	for id := range m.plots {
		ids = append(ids, id)
	}
	return
}

// ResetPlots resets all changes to the "plots" edge.
func (m *DistrictMutation) ResetPlots() {
	m.plots = nil
	m.clearedplots = false
	m.removedplots = nil
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, district.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, district.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, district.FieldAdcode)
	}
	if m.prov_code != nil {
		fields = append(fields, district.FieldProvCode)
	}
	if m.city_code != nil {
		fields = append(fields, district.FieldCityCode)
	}
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	if m.center != nil {
		fields = append(fields, district.FieldCenter)
	}
	if m.province != nil {
		fields = append(fields, district.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, district.FieldCityID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldCreatedAt:
		return m.CreatedAt()
	case district.FieldUpdatedAt:
		return m.UpdatedAt()
	case district.FieldAdcode:
		return m.Adcode()
	case district.FieldProvCode:
		return m.ProvCode()
	case district.FieldCityCode:
		return m.CityCode()
	case district.FieldName:
		return m.Name()
	case district.FieldCenter:
		return m.Center()
	case district.FieldProvinceID:
		return m.ProvinceID()
	case district.FieldCityID:
		return m.CityID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case district.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case district.FieldAdcode:
		return m.OldAdcode(ctx)
	case district.FieldProvCode:
		return m.OldProvCode(ctx)
	case district.FieldCityCode:
		return m.OldCityCode(ctx)
	case district.FieldName:
		return m.OldName(ctx)
	case district.FieldCenter:
		return m.OldCenter(ctx)
	case district.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case district.FieldCityID:
		return m.OldCityID(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case district.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case district.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case district.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvCode(v)
		return nil
	case district.FieldCityCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityCode(v)
		return nil
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case district.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case district.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case district.FieldCityID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, district.FieldAdcode)
	}
	if m.addprov_code != nil {
		fields = append(fields, district.FieldProvCode)
	}
	if m.addcity_code != nil {
		fields = append(fields, district.FieldCityCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case district.FieldAdcode:
		return m.AddedAdcode()
	case district.FieldProvCode:
		return m.AddedProvCode()
	case district.FieldCityCode:
		return m.AddedCityCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	case district.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	case district.FieldProvCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvCode(v)
		return nil
	case district.FieldCityCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCityCode(v)
		return nil
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(district.FieldCityID) {
		fields = append(fields, district.FieldCityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	switch name {
	case district.FieldCityID:
		m.ClearCityID()
		return nil
	}
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case district.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case district.FieldAdcode:
		m.ResetAdcode()
		return nil
	case district.FieldProvCode:
		m.ResetProvCode()
		return nil
	case district.FieldCityCode:
		m.ResetCityCode()
		return nil
	case district.FieldName:
		m.ResetName()
		return nil
	case district.FieldCenter:
		m.ResetCenter()
		return nil
	case district.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case district.FieldCityID:
		m.ResetCityID()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.province != nil {
		edges = append(edges, district.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, district.EdgeCity)
	}
	if m.tenders != nil {
		edges = append(edges, district.EdgeTenders)
	}
	if m.plots != nil {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case district.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case district.EdgePlots:
		ids := make([]ent.Value, 0, len(m.plots))
		for id := range m.plots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtenders != nil {
		edges = append(edges, district.EdgeTenders)
	}
	if m.removedplots != nil {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case district.EdgePlots:
		ids := make([]ent.Value, 0, len(m.removedplots))
		for id := range m.removedplots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprovince {
		edges = append(edges, district.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, district.EdgeCity)
	}
	if m.clearedtenders {
		edges = append(edges, district.EdgeTenders)
	}
	if m.clearedplots {
		edges = append(edges, district.EdgePlots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeProvince:
		return m.clearedprovince
	case district.EdgeCity:
		return m.clearedcity
	case district.EdgeTenders:
		return m.clearedtenders
	case district.EdgePlots:
		return m.clearedplots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	case district.EdgeProvince:
		m.ClearProvince()
		return nil
	case district.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeProvince:
		m.ResetProvince()
		return nil
	case district.EdgeCity:
		m.ResetCity()
		return nil
	case district.EdgeTenders:
		m.ResetTenders()
		return nil
	case district.EdgePlots:
		m.ResetPlots()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// LandMutation represents an operation that mutates the Land nodes in the graph.
type LandMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Land, error)
	predicates    []predicate.Land
}

var _ ent.Mutation = (*LandMutation)(nil)

// landOption allows management of the mutation configuration using functional options.
type landOption func(*LandMutation)

// newLandMutation creates new mutation for the Land entity.
func newLandMutation(c config, op Op, opts ...landOption) *LandMutation {
	m := &LandMutation{
		config:        c,
		op:            op,
		typ:           TypeLand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLandID sets the ID field of the mutation.
func withLandID(id xid.ID) landOption {
	return func(m *LandMutation) {
		var (
			err   error
			once  sync.Once
			value *Land
		)
		m.oldValue = func(ctx context.Context) (*Land, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Land.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLand sets the old Land of the mutation.
func withLand(node *Land) landOption {
	return func(m *LandMutation) {
		m.oldValue = func(context.Context) (*Land, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Land entities.
func (m *LandMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LandMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LandMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Land.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Land entity.
// If the Land object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LandMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LandMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Land entity.
// If the Land object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LandMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LandMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the LandMutation builder.
func (m *LandMutation) Where(ps ...predicate.Land) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Land, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Land).
func (m *LandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LandMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, land.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, land.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case land.FieldCreatedAt:
		return m.CreatedAt()
	case land.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case land.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case land.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Land field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case land.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case land.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Land field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Land numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Land nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LandMutation) ResetField(name string) error {
	switch name {
	case land.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case land.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Land field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LandMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LandMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LandMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LandMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LandMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Land unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LandMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Land edge %s", name)
}

// OperationMutation represents an operation that mutates the Operation nodes in the graph.
type OperationMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	cje_ys        *float64
	addcje_ys     *float64
	cje_lj        *float64
	addcje_lj     *float64
	yye_ys        *float64
	addyye_ys     *float64
	yye_lj        *float64
	addyye_lj     *float64
	xjl_ys        *float64
	addxjl_ys     *float64
	xjl_lj        *float64
	addxjl_lj     *float64
	xmglf         *float64
	addxmglf      *float64
	xmsjf         *float64
	addxmsjf      *float64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Operation, error)
	predicates    []predicate.Operation
}

var _ ent.Mutation = (*OperationMutation)(nil)

// operationOption allows management of the mutation configuration using functional options.
type operationOption func(*OperationMutation)

// newOperationMutation creates new mutation for the Operation entity.
func newOperationMutation(c config, op Op, opts ...operationOption) *OperationMutation {
	m := &OperationMutation{
		config:        c,
		op:            op,
		typ:           TypeOperation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationID sets the ID field of the mutation.
func withOperationID(id xid.ID) operationOption {
	return func(m *OperationMutation) {
		var (
			err   error
			once  sync.Once
			value *Operation
		)
		m.oldValue = func(ctx context.Context) (*Operation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperation sets the old Operation of the mutation.
func withOperation(node *Operation) operationOption {
	return func(m *OperationMutation) {
		m.oldValue = func(context.Context) (*Operation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Operation entities.
func (m *OperationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Operation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OperationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OperationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OperationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OperationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCjeYs sets the "cje_ys" field.
func (m *OperationMutation) SetCjeYs(f float64) {
	m.cje_ys = &f
	m.addcje_ys = nil
}

// CjeYs returns the value of the "cje_ys" field in the mutation.
func (m *OperationMutation) CjeYs() (r float64, exists bool) {
	v := m.cje_ys
	if v == nil {
		return
	}
	return *v, true
}

// OldCjeYs returns the old "cje_ys" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldCjeYs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCjeYs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCjeYs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCjeYs: %w", err)
	}
	return oldValue.CjeYs, nil
}

// AddCjeYs adds f to the "cje_ys" field.
func (m *OperationMutation) AddCjeYs(f float64) {
	if m.addcje_ys != nil {
		*m.addcje_ys += f
	} else {
		m.addcje_ys = &f
	}
}

// AddedCjeYs returns the value that was added to the "cje_ys" field in this mutation.
func (m *OperationMutation) AddedCjeYs() (r float64, exists bool) {
	v := m.addcje_ys
	if v == nil {
		return
	}
	return *v, true
}

// ClearCjeYs clears the value of the "cje_ys" field.
func (m *OperationMutation) ClearCjeYs() {
	m.cje_ys = nil
	m.addcje_ys = nil
	m.clearedFields[operation.FieldCjeYs] = struct{}{}
}

// CjeYsCleared returns if the "cje_ys" field was cleared in this mutation.
func (m *OperationMutation) CjeYsCleared() bool {
	_, ok := m.clearedFields[operation.FieldCjeYs]
	return ok
}

// ResetCjeYs resets all changes to the "cje_ys" field.
func (m *OperationMutation) ResetCjeYs() {
	m.cje_ys = nil
	m.addcje_ys = nil
	delete(m.clearedFields, operation.FieldCjeYs)
}

// SetCjeLj sets the "cje_lj" field.
func (m *OperationMutation) SetCjeLj(f float64) {
	m.cje_lj = &f
	m.addcje_lj = nil
}

// CjeLj returns the value of the "cje_lj" field in the mutation.
func (m *OperationMutation) CjeLj() (r float64, exists bool) {
	v := m.cje_lj
	if v == nil {
		return
	}
	return *v, true
}

// OldCjeLj returns the old "cje_lj" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldCjeLj(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCjeLj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCjeLj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCjeLj: %w", err)
	}
	return oldValue.CjeLj, nil
}

// AddCjeLj adds f to the "cje_lj" field.
func (m *OperationMutation) AddCjeLj(f float64) {
	if m.addcje_lj != nil {
		*m.addcje_lj += f
	} else {
		m.addcje_lj = &f
	}
}

// AddedCjeLj returns the value that was added to the "cje_lj" field in this mutation.
func (m *OperationMutation) AddedCjeLj() (r float64, exists bool) {
	v := m.addcje_lj
	if v == nil {
		return
	}
	return *v, true
}

// ClearCjeLj clears the value of the "cje_lj" field.
func (m *OperationMutation) ClearCjeLj() {
	m.cje_lj = nil
	m.addcje_lj = nil
	m.clearedFields[operation.FieldCjeLj] = struct{}{}
}

// CjeLjCleared returns if the "cje_lj" field was cleared in this mutation.
func (m *OperationMutation) CjeLjCleared() bool {
	_, ok := m.clearedFields[operation.FieldCjeLj]
	return ok
}

// ResetCjeLj resets all changes to the "cje_lj" field.
func (m *OperationMutation) ResetCjeLj() {
	m.cje_lj = nil
	m.addcje_lj = nil
	delete(m.clearedFields, operation.FieldCjeLj)
}

// SetYyeYs sets the "yye_ys" field.
func (m *OperationMutation) SetYyeYs(f float64) {
	m.yye_ys = &f
	m.addyye_ys = nil
}

// YyeYs returns the value of the "yye_ys" field in the mutation.
func (m *OperationMutation) YyeYs() (r float64, exists bool) {
	v := m.yye_ys
	if v == nil {
		return
	}
	return *v, true
}

// OldYyeYs returns the old "yye_ys" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldYyeYs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYyeYs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYyeYs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYyeYs: %w", err)
	}
	return oldValue.YyeYs, nil
}

// AddYyeYs adds f to the "yye_ys" field.
func (m *OperationMutation) AddYyeYs(f float64) {
	if m.addyye_ys != nil {
		*m.addyye_ys += f
	} else {
		m.addyye_ys = &f
	}
}

// AddedYyeYs returns the value that was added to the "yye_ys" field in this mutation.
func (m *OperationMutation) AddedYyeYs() (r float64, exists bool) {
	v := m.addyye_ys
	if v == nil {
		return
	}
	return *v, true
}

// ClearYyeYs clears the value of the "yye_ys" field.
func (m *OperationMutation) ClearYyeYs() {
	m.yye_ys = nil
	m.addyye_ys = nil
	m.clearedFields[operation.FieldYyeYs] = struct{}{}
}

// YyeYsCleared returns if the "yye_ys" field was cleared in this mutation.
func (m *OperationMutation) YyeYsCleared() bool {
	_, ok := m.clearedFields[operation.FieldYyeYs]
	return ok
}

// ResetYyeYs resets all changes to the "yye_ys" field.
func (m *OperationMutation) ResetYyeYs() {
	m.yye_ys = nil
	m.addyye_ys = nil
	delete(m.clearedFields, operation.FieldYyeYs)
}

// SetYyeLj sets the "yye_lj" field.
func (m *OperationMutation) SetYyeLj(f float64) {
	m.yye_lj = &f
	m.addyye_lj = nil
}

// YyeLj returns the value of the "yye_lj" field in the mutation.
func (m *OperationMutation) YyeLj() (r float64, exists bool) {
	v := m.yye_lj
	if v == nil {
		return
	}
	return *v, true
}

// OldYyeLj returns the old "yye_lj" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldYyeLj(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYyeLj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYyeLj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYyeLj: %w", err)
	}
	return oldValue.YyeLj, nil
}

// AddYyeLj adds f to the "yye_lj" field.
func (m *OperationMutation) AddYyeLj(f float64) {
	if m.addyye_lj != nil {
		*m.addyye_lj += f
	} else {
		m.addyye_lj = &f
	}
}

// AddedYyeLj returns the value that was added to the "yye_lj" field in this mutation.
func (m *OperationMutation) AddedYyeLj() (r float64, exists bool) {
	v := m.addyye_lj
	if v == nil {
		return
	}
	return *v, true
}

// ClearYyeLj clears the value of the "yye_lj" field.
func (m *OperationMutation) ClearYyeLj() {
	m.yye_lj = nil
	m.addyye_lj = nil
	m.clearedFields[operation.FieldYyeLj] = struct{}{}
}

// YyeLjCleared returns if the "yye_lj" field was cleared in this mutation.
func (m *OperationMutation) YyeLjCleared() bool {
	_, ok := m.clearedFields[operation.FieldYyeLj]
	return ok
}

// ResetYyeLj resets all changes to the "yye_lj" field.
func (m *OperationMutation) ResetYyeLj() {
	m.yye_lj = nil
	m.addyye_lj = nil
	delete(m.clearedFields, operation.FieldYyeLj)
}

// SetXjlYs sets the "xjl_ys" field.
func (m *OperationMutation) SetXjlYs(f float64) {
	m.xjl_ys = &f
	m.addxjl_ys = nil
}

// XjlYs returns the value of the "xjl_ys" field in the mutation.
func (m *OperationMutation) XjlYs() (r float64, exists bool) {
	v := m.xjl_ys
	if v == nil {
		return
	}
	return *v, true
}

// OldXjlYs returns the old "xjl_ys" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldXjlYs(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXjlYs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXjlYs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXjlYs: %w", err)
	}
	return oldValue.XjlYs, nil
}

// AddXjlYs adds f to the "xjl_ys" field.
func (m *OperationMutation) AddXjlYs(f float64) {
	if m.addxjl_ys != nil {
		*m.addxjl_ys += f
	} else {
		m.addxjl_ys = &f
	}
}

// AddedXjlYs returns the value that was added to the "xjl_ys" field in this mutation.
func (m *OperationMutation) AddedXjlYs() (r float64, exists bool) {
	v := m.addxjl_ys
	if v == nil {
		return
	}
	return *v, true
}

// ClearXjlYs clears the value of the "xjl_ys" field.
func (m *OperationMutation) ClearXjlYs() {
	m.xjl_ys = nil
	m.addxjl_ys = nil
	m.clearedFields[operation.FieldXjlYs] = struct{}{}
}

// XjlYsCleared returns if the "xjl_ys" field was cleared in this mutation.
func (m *OperationMutation) XjlYsCleared() bool {
	_, ok := m.clearedFields[operation.FieldXjlYs]
	return ok
}

// ResetXjlYs resets all changes to the "xjl_ys" field.
func (m *OperationMutation) ResetXjlYs() {
	m.xjl_ys = nil
	m.addxjl_ys = nil
	delete(m.clearedFields, operation.FieldXjlYs)
}

// SetXjlLj sets the "xjl_lj" field.
func (m *OperationMutation) SetXjlLj(f float64) {
	m.xjl_lj = &f
	m.addxjl_lj = nil
}

// XjlLj returns the value of the "xjl_lj" field in the mutation.
func (m *OperationMutation) XjlLj() (r float64, exists bool) {
	v := m.xjl_lj
	if v == nil {
		return
	}
	return *v, true
}

// OldXjlLj returns the old "xjl_lj" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldXjlLj(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXjlLj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXjlLj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXjlLj: %w", err)
	}
	return oldValue.XjlLj, nil
}

// AddXjlLj adds f to the "xjl_lj" field.
func (m *OperationMutation) AddXjlLj(f float64) {
	if m.addxjl_lj != nil {
		*m.addxjl_lj += f
	} else {
		m.addxjl_lj = &f
	}
}

// AddedXjlLj returns the value that was added to the "xjl_lj" field in this mutation.
func (m *OperationMutation) AddedXjlLj() (r float64, exists bool) {
	v := m.addxjl_lj
	if v == nil {
		return
	}
	return *v, true
}

// ClearXjlLj clears the value of the "xjl_lj" field.
func (m *OperationMutation) ClearXjlLj() {
	m.xjl_lj = nil
	m.addxjl_lj = nil
	m.clearedFields[operation.FieldXjlLj] = struct{}{}
}

// XjlLjCleared returns if the "xjl_lj" field was cleared in this mutation.
func (m *OperationMutation) XjlLjCleared() bool {
	_, ok := m.clearedFields[operation.FieldXjlLj]
	return ok
}

// ResetXjlLj resets all changes to the "xjl_lj" field.
func (m *OperationMutation) ResetXjlLj() {
	m.xjl_lj = nil
	m.addxjl_lj = nil
	delete(m.clearedFields, operation.FieldXjlLj)
}

// SetXmglf sets the "xmglf" field.
func (m *OperationMutation) SetXmglf(f float64) {
	m.xmglf = &f
	m.addxmglf = nil
}

// Xmglf returns the value of the "xmglf" field in the mutation.
func (m *OperationMutation) Xmglf() (r float64, exists bool) {
	v := m.xmglf
	if v == nil {
		return
	}
	return *v, true
}

// OldXmglf returns the old "xmglf" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldXmglf(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXmglf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXmglf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXmglf: %w", err)
	}
	return oldValue.Xmglf, nil
}

// AddXmglf adds f to the "xmglf" field.
func (m *OperationMutation) AddXmglf(f float64) {
	if m.addxmglf != nil {
		*m.addxmglf += f
	} else {
		m.addxmglf = &f
	}
}

// AddedXmglf returns the value that was added to the "xmglf" field in this mutation.
func (m *OperationMutation) AddedXmglf() (r float64, exists bool) {
	v := m.addxmglf
	if v == nil {
		return
	}
	return *v, true
}

// ClearXmglf clears the value of the "xmglf" field.
func (m *OperationMutation) ClearXmglf() {
	m.xmglf = nil
	m.addxmglf = nil
	m.clearedFields[operation.FieldXmglf] = struct{}{}
}

// XmglfCleared returns if the "xmglf" field was cleared in this mutation.
func (m *OperationMutation) XmglfCleared() bool {
	_, ok := m.clearedFields[operation.FieldXmglf]
	return ok
}

// ResetXmglf resets all changes to the "xmglf" field.
func (m *OperationMutation) ResetXmglf() {
	m.xmglf = nil
	m.addxmglf = nil
	delete(m.clearedFields, operation.FieldXmglf)
}

// SetXmsjf sets the "xmsjf" field.
func (m *OperationMutation) SetXmsjf(f float64) {
	m.xmsjf = &f
	m.addxmsjf = nil
}

// Xmsjf returns the value of the "xmsjf" field in the mutation.
func (m *OperationMutation) Xmsjf() (r float64, exists bool) {
	v := m.xmsjf
	if v == nil {
		return
	}
	return *v, true
}

// OldXmsjf returns the old "xmsjf" field's value of the Operation entity.
// If the Operation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationMutation) OldXmsjf(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXmsjf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXmsjf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXmsjf: %w", err)
	}
	return oldValue.Xmsjf, nil
}

// AddXmsjf adds f to the "xmsjf" field.
func (m *OperationMutation) AddXmsjf(f float64) {
	if m.addxmsjf != nil {
		*m.addxmsjf += f
	} else {
		m.addxmsjf = &f
	}
}

// AddedXmsjf returns the value that was added to the "xmsjf" field in this mutation.
func (m *OperationMutation) AddedXmsjf() (r float64, exists bool) {
	v := m.addxmsjf
	if v == nil {
		return
	}
	return *v, true
}

// ClearXmsjf clears the value of the "xmsjf" field.
func (m *OperationMutation) ClearXmsjf() {
	m.xmsjf = nil
	m.addxmsjf = nil
	m.clearedFields[operation.FieldXmsjf] = struct{}{}
}

// XmsjfCleared returns if the "xmsjf" field was cleared in this mutation.
func (m *OperationMutation) XmsjfCleared() bool {
	_, ok := m.clearedFields[operation.FieldXmsjf]
	return ok
}

// ResetXmsjf resets all changes to the "xmsjf" field.
func (m *OperationMutation) ResetXmsjf() {
	m.xmsjf = nil
	m.addxmsjf = nil
	delete(m.clearedFields, operation.FieldXmsjf)
}

// Where appends a list predicates to the OperationMutation builder.
func (m *OperationMutation) Where(ps ...predicate.Operation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Operation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Operation).
func (m *OperationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, operation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, operation.FieldUpdatedAt)
	}
	if m.cje_ys != nil {
		fields = append(fields, operation.FieldCjeYs)
	}
	if m.cje_lj != nil {
		fields = append(fields, operation.FieldCjeLj)
	}
	if m.yye_ys != nil {
		fields = append(fields, operation.FieldYyeYs)
	}
	if m.yye_lj != nil {
		fields = append(fields, operation.FieldYyeLj)
	}
	if m.xjl_ys != nil {
		fields = append(fields, operation.FieldXjlYs)
	}
	if m.xjl_lj != nil {
		fields = append(fields, operation.FieldXjlLj)
	}
	if m.xmglf != nil {
		fields = append(fields, operation.FieldXmglf)
	}
	if m.xmsjf != nil {
		fields = append(fields, operation.FieldXmsjf)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operation.FieldCreatedAt:
		return m.CreatedAt()
	case operation.FieldUpdatedAt:
		return m.UpdatedAt()
	case operation.FieldCjeYs:
		return m.CjeYs()
	case operation.FieldCjeLj:
		return m.CjeLj()
	case operation.FieldYyeYs:
		return m.YyeYs()
	case operation.FieldYyeLj:
		return m.YyeLj()
	case operation.FieldXjlYs:
		return m.XjlYs()
	case operation.FieldXjlLj:
		return m.XjlLj()
	case operation.FieldXmglf:
		return m.Xmglf()
	case operation.FieldXmsjf:
		return m.Xmsjf()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case operation.FieldCjeYs:
		return m.OldCjeYs(ctx)
	case operation.FieldCjeLj:
		return m.OldCjeLj(ctx)
	case operation.FieldYyeYs:
		return m.OldYyeYs(ctx)
	case operation.FieldYyeLj:
		return m.OldYyeLj(ctx)
	case operation.FieldXjlYs:
		return m.OldXjlYs(ctx)
	case operation.FieldXjlLj:
		return m.OldXjlLj(ctx)
	case operation.FieldXmglf:
		return m.OldXmglf(ctx)
	case operation.FieldXmsjf:
		return m.OldXmsjf(ctx)
	}
	return nil, fmt.Errorf("unknown Operation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case operation.FieldCjeYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCjeYs(v)
		return nil
	case operation.FieldCjeLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCjeLj(v)
		return nil
	case operation.FieldYyeYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYyeYs(v)
		return nil
	case operation.FieldYyeLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYyeLj(v)
		return nil
	case operation.FieldXjlYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXjlYs(v)
		return nil
	case operation.FieldXjlLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXjlLj(v)
		return nil
	case operation.FieldXmglf:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXmglf(v)
		return nil
	case operation.FieldXmsjf:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXmsjf(v)
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperationMutation) AddedFields() []string {
	var fields []string
	if m.addcje_ys != nil {
		fields = append(fields, operation.FieldCjeYs)
	}
	if m.addcje_lj != nil {
		fields = append(fields, operation.FieldCjeLj)
	}
	if m.addyye_ys != nil {
		fields = append(fields, operation.FieldYyeYs)
	}
	if m.addyye_lj != nil {
		fields = append(fields, operation.FieldYyeLj)
	}
	if m.addxjl_ys != nil {
		fields = append(fields, operation.FieldXjlYs)
	}
	if m.addxjl_lj != nil {
		fields = append(fields, operation.FieldXjlLj)
	}
	if m.addxmglf != nil {
		fields = append(fields, operation.FieldXmglf)
	}
	if m.addxmsjf != nil {
		fields = append(fields, operation.FieldXmsjf)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operation.FieldCjeYs:
		return m.AddedCjeYs()
	case operation.FieldCjeLj:
		return m.AddedCjeLj()
	case operation.FieldYyeYs:
		return m.AddedYyeYs()
	case operation.FieldYyeLj:
		return m.AddedYyeLj()
	case operation.FieldXjlYs:
		return m.AddedXjlYs()
	case operation.FieldXjlLj:
		return m.AddedXjlLj()
	case operation.FieldXmglf:
		return m.AddedXmglf()
	case operation.FieldXmsjf:
		return m.AddedXmsjf()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operation.FieldCjeYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCjeYs(v)
		return nil
	case operation.FieldCjeLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCjeLj(v)
		return nil
	case operation.FieldYyeYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYyeYs(v)
		return nil
	case operation.FieldYyeLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYyeLj(v)
		return nil
	case operation.FieldXjlYs:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXjlYs(v)
		return nil
	case operation.FieldXjlLj:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXjlLj(v)
		return nil
	case operation.FieldXmglf:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXmglf(v)
		return nil
	case operation.FieldXmsjf:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXmsjf(v)
		return nil
	}
	return fmt.Errorf("unknown Operation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operation.FieldCjeYs) {
		fields = append(fields, operation.FieldCjeYs)
	}
	if m.FieldCleared(operation.FieldCjeLj) {
		fields = append(fields, operation.FieldCjeLj)
	}
	if m.FieldCleared(operation.FieldYyeYs) {
		fields = append(fields, operation.FieldYyeYs)
	}
	if m.FieldCleared(operation.FieldYyeLj) {
		fields = append(fields, operation.FieldYyeLj)
	}
	if m.FieldCleared(operation.FieldXjlYs) {
		fields = append(fields, operation.FieldXjlYs)
	}
	if m.FieldCleared(operation.FieldXjlLj) {
		fields = append(fields, operation.FieldXjlLj)
	}
	if m.FieldCleared(operation.FieldXmglf) {
		fields = append(fields, operation.FieldXmglf)
	}
	if m.FieldCleared(operation.FieldXmsjf) {
		fields = append(fields, operation.FieldXmsjf)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationMutation) ClearField(name string) error {
	switch name {
	case operation.FieldCjeYs:
		m.ClearCjeYs()
		return nil
	case operation.FieldCjeLj:
		m.ClearCjeLj()
		return nil
	case operation.FieldYyeYs:
		m.ClearYyeYs()
		return nil
	case operation.FieldYyeLj:
		m.ClearYyeLj()
		return nil
	case operation.FieldXjlYs:
		m.ClearXjlYs()
		return nil
	case operation.FieldXjlLj:
		m.ClearXjlLj()
		return nil
	case operation.FieldXmglf:
		m.ClearXmglf()
		return nil
	case operation.FieldXmsjf:
		m.ClearXmsjf()
		return nil
	}
	return fmt.Errorf("unknown Operation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperationMutation) ResetField(name string) error {
	switch name {
	case operation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case operation.FieldCjeYs:
		m.ResetCjeYs()
		return nil
	case operation.FieldCjeLj:
		m.ResetCjeLj()
		return nil
	case operation.FieldYyeYs:
		m.ResetYyeYs()
		return nil
	case operation.FieldYyeLj:
		m.ResetYyeLj()
		return nil
	case operation.FieldXjlYs:
		m.ResetXjlYs()
		return nil
	case operation.FieldXjlLj:
		m.ResetXjlLj()
		return nil
	case operation.FieldXmglf:
		m.ResetXmglf()
		return nil
	case operation.FieldXmsjf:
		m.ResetXmsjf()
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Operation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Operation edge %s", name)
}

// PlotMutation represents an operation that mutates the Plot nodes in the graph.
type PlotMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	color_hex        *string
	geo_bounds       *[][]float64
	appendgeo_bounds [][]float64
	clearedFields    map[string]struct{}
	district         *xid.ID
	cleareddistrict  bool
	done             bool
	oldValue         func(context.Context) (*Plot, error)
	predicates       []predicate.Plot
}

var _ ent.Mutation = (*PlotMutation)(nil)

// plotOption allows management of the mutation configuration using functional options.
type plotOption func(*PlotMutation)

// newPlotMutation creates new mutation for the Plot entity.
func newPlotMutation(c config, op Op, opts ...plotOption) *PlotMutation {
	m := &PlotMutation{
		config:        c,
		op:            op,
		typ:           TypePlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlotID sets the ID field of the mutation.
func withPlotID(id xid.ID) plotOption {
	return func(m *PlotMutation) {
		var (
			err   error
			once  sync.Once
			value *Plot
		)
		m.oldValue = func(ctx context.Context) (*Plot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlot sets the old Plot of the mutation.
func withPlot(node *Plot) plotOption {
	return func(m *PlotMutation) {
		m.oldValue = func(context.Context) (*Plot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plot entities.
func (m *PlotMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlotMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlotMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PlotMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlotMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlotMutation) ResetName() {
	m.name = nil
}

// SetColorHex sets the "color_hex" field.
func (m *PlotMutation) SetColorHex(s string) {
	m.color_hex = &s
}

// ColorHex returns the value of the "color_hex" field in the mutation.
func (m *PlotMutation) ColorHex() (r string, exists bool) {
	v := m.color_hex
	if v == nil {
		return
	}
	return *v, true
}

// OldColorHex returns the old "color_hex" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldColorHex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColorHex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColorHex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColorHex: %w", err)
	}
	return oldValue.ColorHex, nil
}

// ResetColorHex resets all changes to the "color_hex" field.
func (m *PlotMutation) ResetColorHex() {
	m.color_hex = nil
}

// SetGeoBounds sets the "geo_bounds" field.
func (m *PlotMutation) SetGeoBounds(f [][]float64) {
	m.geo_bounds = &f
	m.appendgeo_bounds = nil
}

// GeoBounds returns the value of the "geo_bounds" field in the mutation.
func (m *PlotMutation) GeoBounds() (r [][]float64, exists bool) {
	v := m.geo_bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoBounds returns the old "geo_bounds" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldGeoBounds(ctx context.Context) (v [][]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoBounds: %w", err)
	}
	return oldValue.GeoBounds, nil
}

// AppendGeoBounds adds f to the "geo_bounds" field.
func (m *PlotMutation) AppendGeoBounds(f [][]float64) {
	m.appendgeo_bounds = append(m.appendgeo_bounds, f...)
}

// AppendedGeoBounds returns the list of values that were appended to the "geo_bounds" field in this mutation.
func (m *PlotMutation) AppendedGeoBounds() ([][]float64, bool) {
	if len(m.appendgeo_bounds) == 0 {
		return nil, false
	}
	return m.appendgeo_bounds, true
}

// ClearGeoBounds clears the value of the "geo_bounds" field.
func (m *PlotMutation) ClearGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	m.clearedFields[plot.FieldGeoBounds] = struct{}{}
}

// GeoBoundsCleared returns if the "geo_bounds" field was cleared in this mutation.
func (m *PlotMutation) GeoBoundsCleared() bool {
	_, ok := m.clearedFields[plot.FieldGeoBounds]
	return ok
}

// ResetGeoBounds resets all changes to the "geo_bounds" field.
func (m *PlotMutation) ResetGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	delete(m.clearedFields, plot.FieldGeoBounds)
}

// SetDistrictID sets the "district_id" field.
func (m *PlotMutation) SetDistrictID(x xid.ID) {
	m.district = &x
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *PlotMutation) DistrictID() (r xid.ID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Plot entity.
// If the Plot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlotMutation) OldDistrictID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *PlotMutation) ResetDistrictID() {
	m.district = nil
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *PlotMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[plot.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *PlotMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *PlotMutation) DistrictIDs() (ids []xid.ID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *PlotMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// Where appends a list predicates to the PlotMutation builder.
func (m *PlotMutation) Where(ps ...predicate.Plot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plot).
func (m *PlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlotMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, plot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plot.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, plot.FieldName)
	}
	if m.color_hex != nil {
		fields = append(fields, plot.FieldColorHex)
	}
	if m.geo_bounds != nil {
		fields = append(fields, plot.FieldGeoBounds)
	}
	if m.district != nil {
		fields = append(fields, plot.FieldDistrictID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plot.FieldCreatedAt:
		return m.CreatedAt()
	case plot.FieldUpdatedAt:
		return m.UpdatedAt()
	case plot.FieldName:
		return m.Name()
	case plot.FieldColorHex:
		return m.ColorHex()
	case plot.FieldGeoBounds:
		return m.GeoBounds()
	case plot.FieldDistrictID:
		return m.DistrictID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plot.FieldName:
		return m.OldName(ctx)
	case plot.FieldColorHex:
		return m.OldColorHex(ctx)
	case plot.FieldGeoBounds:
		return m.OldGeoBounds(ctx)
	case plot.FieldDistrictID:
		return m.OldDistrictID(ctx)
	}
	return nil, fmt.Errorf("unknown Plot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plot.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plot.FieldColorHex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColorHex(v)
		return nil
	case plot.FieldGeoBounds:
		v, ok := value.([][]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoBounds(v)
		return nil
	case plot.FieldDistrictID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	}
	return fmt.Errorf("unknown Plot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlotMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlotMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Plot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlotMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plot.FieldGeoBounds) {
		fields = append(fields, plot.FieldGeoBounds)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlotMutation) ClearField(name string) error {
	switch name {
	case plot.FieldGeoBounds:
		m.ClearGeoBounds()
		return nil
	}
	return fmt.Errorf("unknown Plot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlotMutation) ResetField(name string) error {
	switch name {
	case plot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plot.FieldName:
		m.ResetName()
		return nil
	case plot.FieldColorHex:
		m.ResetColorHex()
		return nil
	case plot.FieldGeoBounds:
		m.ResetGeoBounds()
		return nil
	case plot.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	}
	return fmt.Errorf("unknown Plot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.district != nil {
		edges = append(edges, plot.EdgeDistrict)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plot.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddistrict {
		edges = append(edges, plot.EdgeDistrict)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlotMutation) EdgeCleared(name string) bool {
	switch name {
	case plot.EdgeDistrict:
		return m.cleareddistrict
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlotMutation) ClearEdge(name string) error {
	switch name {
	case plot.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown Plot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlotMutation) ResetEdge(name string) error {
	switch name {
	case plot.EdgeDistrict:
		m.ResetDistrict()
		return nil
	}
	return fmt.Errorf("unknown Plot edge %s", name)
}

// PotentialTenderMutation represents an operation that mutates the PotentialTender nodes in the graph.
type PotentialTenderMutation struct {
	config
	op              Op
	typ             string
	id              *xid.ID
	created_at      *time.Time
	updated_at      *time.Time
	ref_url         *string
	title           *string
	description     *string
	requirement     *string
	address         *string
	date            *string
	_type           *string
	status          *string
	amount          *string
	size            *string
	location        *string
	contact         *string
	contact_phone   *string
	contact_email   *string
	contact_address *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PotentialTender, error)
	predicates      []predicate.PotentialTender
}

var _ ent.Mutation = (*PotentialTenderMutation)(nil)

// potentialtenderOption allows management of the mutation configuration using functional options.
type potentialtenderOption func(*PotentialTenderMutation)

// newPotentialTenderMutation creates new mutation for the PotentialTender entity.
func newPotentialTenderMutation(c config, op Op, opts ...potentialtenderOption) *PotentialTenderMutation {
	m := &PotentialTenderMutation{
		config:        c,
		op:            op,
		typ:           TypePotentialTender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPotentialTenderID sets the ID field of the mutation.
func withPotentialTenderID(id xid.ID) potentialtenderOption {
	return func(m *PotentialTenderMutation) {
		var (
			err   error
			once  sync.Once
			value *PotentialTender
		)
		m.oldValue = func(ctx context.Context) (*PotentialTender, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PotentialTender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPotentialTender sets the old PotentialTender of the mutation.
func withPotentialTender(node *PotentialTender) potentialtenderOption {
	return func(m *PotentialTenderMutation) {
		m.oldValue = func(context.Context) (*PotentialTender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PotentialTenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PotentialTenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PotentialTender entities.
func (m *PotentialTenderMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PotentialTenderMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PotentialTenderMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PotentialTender.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PotentialTenderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PotentialTenderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PotentialTenderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PotentialTenderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PotentialTenderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PotentialTenderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRefURL sets the "ref_url" field.
func (m *PotentialTenderMutation) SetRefURL(s string) {
	m.ref_url = &s
}

// RefURL returns the value of the "ref_url" field in the mutation.
func (m *PotentialTenderMutation) RefURL() (r string, exists bool) {
	v := m.ref_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRefURL returns the old "ref_url" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldRefURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefURL: %w", err)
	}
	return oldValue.RefURL, nil
}

// ResetRefURL resets all changes to the "ref_url" field.
func (m *PotentialTenderMutation) ResetRefURL() {
	m.ref_url = nil
}

// SetTitle sets the "title" field.
func (m *PotentialTenderMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PotentialTenderMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PotentialTenderMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *PotentialTenderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PotentialTenderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PotentialTenderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[potentialtender.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PotentialTenderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PotentialTenderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, potentialtender.FieldDescription)
}

// SetRequirement sets the "requirement" field.
func (m *PotentialTenderMutation) SetRequirement(s string) {
	m.requirement = &s
}

// Requirement returns the value of the "requirement" field in the mutation.
func (m *PotentialTenderMutation) Requirement() (r string, exists bool) {
	v := m.requirement
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirement returns the old "requirement" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldRequirement(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequirement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequirement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirement: %w", err)
	}
	return oldValue.Requirement, nil
}

// ClearRequirement clears the value of the "requirement" field.
func (m *PotentialTenderMutation) ClearRequirement() {
	m.requirement = nil
	m.clearedFields[potentialtender.FieldRequirement] = struct{}{}
}

// RequirementCleared returns if the "requirement" field was cleared in this mutation.
func (m *PotentialTenderMutation) RequirementCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldRequirement]
	return ok
}

// ResetRequirement resets all changes to the "requirement" field.
func (m *PotentialTenderMutation) ResetRequirement() {
	m.requirement = nil
	delete(m.clearedFields, potentialtender.FieldRequirement)
}

// SetAddress sets the "address" field.
func (m *PotentialTenderMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PotentialTenderMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PotentialTenderMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[potentialtender.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PotentialTenderMutation) AddressCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PotentialTenderMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, potentialtender.FieldAddress)
}

// SetDate sets the "date" field.
func (m *PotentialTenderMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *PotentialTenderMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *PotentialTenderMutation) ClearDate() {
	m.date = nil
	m.clearedFields[potentialtender.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *PotentialTenderMutation) DateCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *PotentialTenderMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, potentialtender.FieldDate)
}

// SetType sets the "type" field.
func (m *PotentialTenderMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *PotentialTenderMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *PotentialTenderMutation) ClearType() {
	m._type = nil
	m.clearedFields[potentialtender.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *PotentialTenderMutation) TypeCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *PotentialTenderMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, potentialtender.FieldType)
}

// SetStatus sets the "status" field.
func (m *PotentialTenderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PotentialTenderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PotentialTenderMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[potentialtender.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PotentialTenderMutation) StatusCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PotentialTenderMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, potentialtender.FieldStatus)
}

// SetAmount sets the "amount" field.
func (m *PotentialTenderMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PotentialTenderMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldAmount(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ClearAmount clears the value of the "amount" field.
func (m *PotentialTenderMutation) ClearAmount() {
	m.amount = nil
	m.clearedFields[potentialtender.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *PotentialTenderMutation) AmountCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *PotentialTenderMutation) ResetAmount() {
	m.amount = nil
	delete(m.clearedFields, potentialtender.FieldAmount)
}

// SetSize sets the "size" field.
func (m *PotentialTenderMutation) SetSize(s string) {
	m.size = &s
}

// Size returns the value of the "size" field in the mutation.
func (m *PotentialTenderMutation) Size() (r string, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldSize(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// ClearSize clears the value of the "size" field.
func (m *PotentialTenderMutation) ClearSize() {
	m.size = nil
	m.clearedFields[potentialtender.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *PotentialTenderMutation) SizeCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *PotentialTenderMutation) ResetSize() {
	m.size = nil
	delete(m.clearedFields, potentialtender.FieldSize)
}

// SetLocation sets the "location" field.
func (m *PotentialTenderMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PotentialTenderMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PotentialTenderMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[potentialtender.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PotentialTenderMutation) LocationCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PotentialTenderMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, potentialtender.FieldLocation)
}

// SetContact sets the "contact" field.
func (m *PotentialTenderMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *PotentialTenderMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldContact(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *PotentialTenderMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[potentialtender.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *PotentialTenderMutation) ContactCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *PotentialTenderMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, potentialtender.FieldContact)
}

// SetContactPhone sets the "contact_phone" field.
func (m *PotentialTenderMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *PotentialTenderMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldContactPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *PotentialTenderMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[potentialtender.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *PotentialTenderMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *PotentialTenderMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, potentialtender.FieldContactPhone)
}

// SetContactEmail sets the "contact_email" field.
func (m *PotentialTenderMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *PotentialTenderMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldContactEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *PotentialTenderMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[potentialtender.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *PotentialTenderMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *PotentialTenderMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, potentialtender.FieldContactEmail)
}

// SetContactAddress sets the "contact_address" field.
func (m *PotentialTenderMutation) SetContactAddress(s string) {
	m.contact_address = &s
}

// ContactAddress returns the value of the "contact_address" field in the mutation.
func (m *PotentialTenderMutation) ContactAddress() (r string, exists bool) {
	v := m.contact_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContactAddress returns the old "contact_address" field's value of the PotentialTender entity.
// If the PotentialTender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PotentialTenderMutation) OldContactAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactAddress: %w", err)
	}
	return oldValue.ContactAddress, nil
}

// ClearContactAddress clears the value of the "contact_address" field.
func (m *PotentialTenderMutation) ClearContactAddress() {
	m.contact_address = nil
	m.clearedFields[potentialtender.FieldContactAddress] = struct{}{}
}

// ContactAddressCleared returns if the "contact_address" field was cleared in this mutation.
func (m *PotentialTenderMutation) ContactAddressCleared() bool {
	_, ok := m.clearedFields[potentialtender.FieldContactAddress]
	return ok
}

// ResetContactAddress resets all changes to the "contact_address" field.
func (m *PotentialTenderMutation) ResetContactAddress() {
	m.contact_address = nil
	delete(m.clearedFields, potentialtender.FieldContactAddress)
}

// Where appends a list predicates to the PotentialTenderMutation builder.
func (m *PotentialTenderMutation) Where(ps ...predicate.PotentialTender) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PotentialTenderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PotentialTenderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PotentialTender, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PotentialTenderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PotentialTenderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PotentialTender).
func (m *PotentialTenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PotentialTenderMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, potentialtender.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, potentialtender.FieldUpdatedAt)
	}
	if m.ref_url != nil {
		fields = append(fields, potentialtender.FieldRefURL)
	}
	if m.title != nil {
		fields = append(fields, potentialtender.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, potentialtender.FieldDescription)
	}
	if m.requirement != nil {
		fields = append(fields, potentialtender.FieldRequirement)
	}
	if m.address != nil {
		fields = append(fields, potentialtender.FieldAddress)
	}
	if m.date != nil {
		fields = append(fields, potentialtender.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, potentialtender.FieldType)
	}
	if m.status != nil {
		fields = append(fields, potentialtender.FieldStatus)
	}
	if m.amount != nil {
		fields = append(fields, potentialtender.FieldAmount)
	}
	if m.size != nil {
		fields = append(fields, potentialtender.FieldSize)
	}
	if m.location != nil {
		fields = append(fields, potentialtender.FieldLocation)
	}
	if m.contact != nil {
		fields = append(fields, potentialtender.FieldContact)
	}
	if m.contact_phone != nil {
		fields = append(fields, potentialtender.FieldContactPhone)
	}
	if m.contact_email != nil {
		fields = append(fields, potentialtender.FieldContactEmail)
	}
	if m.contact_address != nil {
		fields = append(fields, potentialtender.FieldContactAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PotentialTenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case potentialtender.FieldCreatedAt:
		return m.CreatedAt()
	case potentialtender.FieldUpdatedAt:
		return m.UpdatedAt()
	case potentialtender.FieldRefURL:
		return m.RefURL()
	case potentialtender.FieldTitle:
		return m.Title()
	case potentialtender.FieldDescription:
		return m.Description()
	case potentialtender.FieldRequirement:
		return m.Requirement()
	case potentialtender.FieldAddress:
		return m.Address()
	case potentialtender.FieldDate:
		return m.Date()
	case potentialtender.FieldType:
		return m.GetType()
	case potentialtender.FieldStatus:
		return m.Status()
	case potentialtender.FieldAmount:
		return m.Amount()
	case potentialtender.FieldSize:
		return m.Size()
	case potentialtender.FieldLocation:
		return m.Location()
	case potentialtender.FieldContact:
		return m.Contact()
	case potentialtender.FieldContactPhone:
		return m.ContactPhone()
	case potentialtender.FieldContactEmail:
		return m.ContactEmail()
	case potentialtender.FieldContactAddress:
		return m.ContactAddress()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PotentialTenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case potentialtender.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case potentialtender.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case potentialtender.FieldRefURL:
		return m.OldRefURL(ctx)
	case potentialtender.FieldTitle:
		return m.OldTitle(ctx)
	case potentialtender.FieldDescription:
		return m.OldDescription(ctx)
	case potentialtender.FieldRequirement:
		return m.OldRequirement(ctx)
	case potentialtender.FieldAddress:
		return m.OldAddress(ctx)
	case potentialtender.FieldDate:
		return m.OldDate(ctx)
	case potentialtender.FieldType:
		return m.OldType(ctx)
	case potentialtender.FieldStatus:
		return m.OldStatus(ctx)
	case potentialtender.FieldAmount:
		return m.OldAmount(ctx)
	case potentialtender.FieldSize:
		return m.OldSize(ctx)
	case potentialtender.FieldLocation:
		return m.OldLocation(ctx)
	case potentialtender.FieldContact:
		return m.OldContact(ctx)
	case potentialtender.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case potentialtender.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case potentialtender.FieldContactAddress:
		return m.OldContactAddress(ctx)
	}
	return nil, fmt.Errorf("unknown PotentialTender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PotentialTenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case potentialtender.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case potentialtender.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case potentialtender.FieldRefURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefURL(v)
		return nil
	case potentialtender.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case potentialtender.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case potentialtender.FieldRequirement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirement(v)
		return nil
	case potentialtender.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case potentialtender.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case potentialtender.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case potentialtender.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case potentialtender.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case potentialtender.FieldSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case potentialtender.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case potentialtender.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case potentialtender.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case potentialtender.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case potentialtender.FieldContactAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactAddress(v)
		return nil
	}
	return fmt.Errorf("unknown PotentialTender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PotentialTenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PotentialTenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PotentialTenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PotentialTender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PotentialTenderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(potentialtender.FieldDescription) {
		fields = append(fields, potentialtender.FieldDescription)
	}
	if m.FieldCleared(potentialtender.FieldRequirement) {
		fields = append(fields, potentialtender.FieldRequirement)
	}
	if m.FieldCleared(potentialtender.FieldAddress) {
		fields = append(fields, potentialtender.FieldAddress)
	}
	if m.FieldCleared(potentialtender.FieldDate) {
		fields = append(fields, potentialtender.FieldDate)
	}
	if m.FieldCleared(potentialtender.FieldType) {
		fields = append(fields, potentialtender.FieldType)
	}
	if m.FieldCleared(potentialtender.FieldStatus) {
		fields = append(fields, potentialtender.FieldStatus)
	}
	if m.FieldCleared(potentialtender.FieldAmount) {
		fields = append(fields, potentialtender.FieldAmount)
	}
	if m.FieldCleared(potentialtender.FieldSize) {
		fields = append(fields, potentialtender.FieldSize)
	}
	if m.FieldCleared(potentialtender.FieldLocation) {
		fields = append(fields, potentialtender.FieldLocation)
	}
	if m.FieldCleared(potentialtender.FieldContact) {
		fields = append(fields, potentialtender.FieldContact)
	}
	if m.FieldCleared(potentialtender.FieldContactPhone) {
		fields = append(fields, potentialtender.FieldContactPhone)
	}
	if m.FieldCleared(potentialtender.FieldContactEmail) {
		fields = append(fields, potentialtender.FieldContactEmail)
	}
	if m.FieldCleared(potentialtender.FieldContactAddress) {
		fields = append(fields, potentialtender.FieldContactAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PotentialTenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PotentialTenderMutation) ClearField(name string) error {
	switch name {
	case potentialtender.FieldDescription:
		m.ClearDescription()
		return nil
	case potentialtender.FieldRequirement:
		m.ClearRequirement()
		return nil
	case potentialtender.FieldAddress:
		m.ClearAddress()
		return nil
	case potentialtender.FieldDate:
		m.ClearDate()
		return nil
	case potentialtender.FieldType:
		m.ClearType()
		return nil
	case potentialtender.FieldStatus:
		m.ClearStatus()
		return nil
	case potentialtender.FieldAmount:
		m.ClearAmount()
		return nil
	case potentialtender.FieldSize:
		m.ClearSize()
		return nil
	case potentialtender.FieldLocation:
		m.ClearLocation()
		return nil
	case potentialtender.FieldContact:
		m.ClearContact()
		return nil
	case potentialtender.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case potentialtender.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case potentialtender.FieldContactAddress:
		m.ClearContactAddress()
		return nil
	}
	return fmt.Errorf("unknown PotentialTender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PotentialTenderMutation) ResetField(name string) error {
	switch name {
	case potentialtender.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case potentialtender.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case potentialtender.FieldRefURL:
		m.ResetRefURL()
		return nil
	case potentialtender.FieldTitle:
		m.ResetTitle()
		return nil
	case potentialtender.FieldDescription:
		m.ResetDescription()
		return nil
	case potentialtender.FieldRequirement:
		m.ResetRequirement()
		return nil
	case potentialtender.FieldAddress:
		m.ResetAddress()
		return nil
	case potentialtender.FieldDate:
		m.ResetDate()
		return nil
	case potentialtender.FieldType:
		m.ResetType()
		return nil
	case potentialtender.FieldStatus:
		m.ResetStatus()
		return nil
	case potentialtender.FieldAmount:
		m.ResetAmount()
		return nil
	case potentialtender.FieldSize:
		m.ResetSize()
		return nil
	case potentialtender.FieldLocation:
		m.ResetLocation()
		return nil
	case potentialtender.FieldContact:
		m.ResetContact()
		return nil
	case potentialtender.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case potentialtender.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case potentialtender.FieldContactAddress:
		m.ResetContactAddress()
		return nil
	}
	return fmt.Errorf("unknown PotentialTender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PotentialTenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PotentialTenderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PotentialTenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PotentialTenderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PotentialTenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PotentialTenderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PotentialTenderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PotentialTender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PotentialTenderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PotentialTender edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *xid.ID
	created_at                              *time.Time
	updated_at                              *time.Time
	code                                    *string
	is_finished                             *bool
	revenue_kpi                             *float64
	addrevenue_kpi                          *float64
	revenue_current_year_completed          *float64
	addrevenue_current_year_completed       *float64
	revenue_accumulated_completed           *float64
	addrevenue_accumulated_completed        *float64
	pay_date                                *time.Time
	owner_vo_count                          *int
	addowner_vo_count                       *int
	contractor_vo_count                     *int
	addcontractor_vo_count                  *int
	accumulate_deduction                    *float64
	addaccumulate_deduction                 *float64
	subcontractor_va_count                  *int
	addsubcontractor_va_count               *int
	contract_supplementary_count            *int
	addcontract_supplementary_count         *int
	repair_fee                              *float64
	addrepair_fee                           *float64
	unit_inventory_total                    *float64
	addunit_inventory_total                 *float64
	unit_component_total                    *float64
	addunit_component_total                 *float64
	unit_component_production               *float64
	addunit_component_production            *float64
	unit_component_installation             *float64
	addunit_component_installation          *float64
	bulk_materials_total_order_quantity     *float64
	addbulk_materials_total_order_quantity  *float64
	bulk_materials_completed_quantity       *float64
	addbulk_materials_completed_quantity    *float64
	bulk_materials_uncompleted_quantity     *float64
	addbulk_materials_uncompleted_quantity  *float64
	diagram_bd_finish_count                 *int
	adddiagram_bd_finish_count              *int
	diagram_bd_total_count                  *int
	adddiagram_bd_total_count               *int
	diagram_construction_finish_count       *int
	adddiagram_construction_finish_count    *int
	diagram_construction_total_count        *int
	adddiagram_construction_total_count     *int
	diagram_processing_finish_count         *int
	adddiagram_processing_finish_count      *int
	diagram_processing_total_count          *int
	adddiagram_processing_total_count       *int
	diagram_c_approval_ratio_numerator      *int
	adddiagram_c_approval_ratio_numerator   *int
	diagram_c_approval_ratio_denominator    *int
	adddiagram_c_approval_ratio_denominator *int
	clearedFields                           map[string]struct{}
	users                                   map[xid.ID]struct{}
	removedusers                            map[xid.ID]struct{}
	clearedusers                            bool
	done                                    bool
	oldValue                                func(context.Context) (*Project, error)
	predicates                              []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id xid.ID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *ProjectMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProjectMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ProjectMutation) ResetCode() {
	m.code = nil
}

// SetIsFinished sets the "is_finished" field.
func (m *ProjectMutation) SetIsFinished(b bool) {
	m.is_finished = &b
}

// IsFinished returns the value of the "is_finished" field in the mutation.
func (m *ProjectMutation) IsFinished() (r bool, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old "is_finished" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// ResetIsFinished resets all changes to the "is_finished" field.
func (m *ProjectMutation) ResetIsFinished() {
	m.is_finished = nil
}

// SetRevenueKpi sets the "revenue_kpi" field.
func (m *ProjectMutation) SetRevenueKpi(f float64) {
	m.revenue_kpi = &f
	m.addrevenue_kpi = nil
}

// RevenueKpi returns the value of the "revenue_kpi" field in the mutation.
func (m *ProjectMutation) RevenueKpi() (r float64, exists bool) {
	v := m.revenue_kpi
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueKpi returns the old "revenue_kpi" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRevenueKpi(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueKpi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueKpi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueKpi: %w", err)
	}
	return oldValue.RevenueKpi, nil
}

// AddRevenueKpi adds f to the "revenue_kpi" field.
func (m *ProjectMutation) AddRevenueKpi(f float64) {
	if m.addrevenue_kpi != nil {
		*m.addrevenue_kpi += f
	} else {
		m.addrevenue_kpi = &f
	}
}

// AddedRevenueKpi returns the value that was added to the "revenue_kpi" field in this mutation.
func (m *ProjectMutation) AddedRevenueKpi() (r float64, exists bool) {
	v := m.addrevenue_kpi
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenueKpi clears the value of the "revenue_kpi" field.
func (m *ProjectMutation) ClearRevenueKpi() {
	m.revenue_kpi = nil
	m.addrevenue_kpi = nil
	m.clearedFields[project.FieldRevenueKpi] = struct{}{}
}

// RevenueKpiCleared returns if the "revenue_kpi" field was cleared in this mutation.
func (m *ProjectMutation) RevenueKpiCleared() bool {
	_, ok := m.clearedFields[project.FieldRevenueKpi]
	return ok
}

// ResetRevenueKpi resets all changes to the "revenue_kpi" field.
func (m *ProjectMutation) ResetRevenueKpi() {
	m.revenue_kpi = nil
	m.addrevenue_kpi = nil
	delete(m.clearedFields, project.FieldRevenueKpi)
}

// SetRevenueCurrentYearCompleted sets the "revenue_current_year_completed" field.
func (m *ProjectMutation) SetRevenueCurrentYearCompleted(f float64) {
	m.revenue_current_year_completed = &f
	m.addrevenue_current_year_completed = nil
}

// RevenueCurrentYearCompleted returns the value of the "revenue_current_year_completed" field in the mutation.
func (m *ProjectMutation) RevenueCurrentYearCompleted() (r float64, exists bool) {
	v := m.revenue_current_year_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueCurrentYearCompleted returns the old "revenue_current_year_completed" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRevenueCurrentYearCompleted(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueCurrentYearCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueCurrentYearCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueCurrentYearCompleted: %w", err)
	}
	return oldValue.RevenueCurrentYearCompleted, nil
}

// AddRevenueCurrentYearCompleted adds f to the "revenue_current_year_completed" field.
func (m *ProjectMutation) AddRevenueCurrentYearCompleted(f float64) {
	if m.addrevenue_current_year_completed != nil {
		*m.addrevenue_current_year_completed += f
	} else {
		m.addrevenue_current_year_completed = &f
	}
}

// AddedRevenueCurrentYearCompleted returns the value that was added to the "revenue_current_year_completed" field in this mutation.
func (m *ProjectMutation) AddedRevenueCurrentYearCompleted() (r float64, exists bool) {
	v := m.addrevenue_current_year_completed
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenueCurrentYearCompleted clears the value of the "revenue_current_year_completed" field.
func (m *ProjectMutation) ClearRevenueCurrentYearCompleted() {
	m.revenue_current_year_completed = nil
	m.addrevenue_current_year_completed = nil
	m.clearedFields[project.FieldRevenueCurrentYearCompleted] = struct{}{}
}

// RevenueCurrentYearCompletedCleared returns if the "revenue_current_year_completed" field was cleared in this mutation.
func (m *ProjectMutation) RevenueCurrentYearCompletedCleared() bool {
	_, ok := m.clearedFields[project.FieldRevenueCurrentYearCompleted]
	return ok
}

// ResetRevenueCurrentYearCompleted resets all changes to the "revenue_current_year_completed" field.
func (m *ProjectMutation) ResetRevenueCurrentYearCompleted() {
	m.revenue_current_year_completed = nil
	m.addrevenue_current_year_completed = nil
	delete(m.clearedFields, project.FieldRevenueCurrentYearCompleted)
}

// SetRevenueAccumulatedCompleted sets the "revenue_accumulated_completed" field.
func (m *ProjectMutation) SetRevenueAccumulatedCompleted(f float64) {
	m.revenue_accumulated_completed = &f
	m.addrevenue_accumulated_completed = nil
}

// RevenueAccumulatedCompleted returns the value of the "revenue_accumulated_completed" field in the mutation.
func (m *ProjectMutation) RevenueAccumulatedCompleted() (r float64, exists bool) {
	v := m.revenue_accumulated_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueAccumulatedCompleted returns the old "revenue_accumulated_completed" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRevenueAccumulatedCompleted(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueAccumulatedCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueAccumulatedCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueAccumulatedCompleted: %w", err)
	}
	return oldValue.RevenueAccumulatedCompleted, nil
}

// AddRevenueAccumulatedCompleted adds f to the "revenue_accumulated_completed" field.
func (m *ProjectMutation) AddRevenueAccumulatedCompleted(f float64) {
	if m.addrevenue_accumulated_completed != nil {
		*m.addrevenue_accumulated_completed += f
	} else {
		m.addrevenue_accumulated_completed = &f
	}
}

// AddedRevenueAccumulatedCompleted returns the value that was added to the "revenue_accumulated_completed" field in this mutation.
func (m *ProjectMutation) AddedRevenueAccumulatedCompleted() (r float64, exists bool) {
	v := m.addrevenue_accumulated_completed
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenueAccumulatedCompleted clears the value of the "revenue_accumulated_completed" field.
func (m *ProjectMutation) ClearRevenueAccumulatedCompleted() {
	m.revenue_accumulated_completed = nil
	m.addrevenue_accumulated_completed = nil
	m.clearedFields[project.FieldRevenueAccumulatedCompleted] = struct{}{}
}

// RevenueAccumulatedCompletedCleared returns if the "revenue_accumulated_completed" field was cleared in this mutation.
func (m *ProjectMutation) RevenueAccumulatedCompletedCleared() bool {
	_, ok := m.clearedFields[project.FieldRevenueAccumulatedCompleted]
	return ok
}

// ResetRevenueAccumulatedCompleted resets all changes to the "revenue_accumulated_completed" field.
func (m *ProjectMutation) ResetRevenueAccumulatedCompleted() {
	m.revenue_accumulated_completed = nil
	m.addrevenue_accumulated_completed = nil
	delete(m.clearedFields, project.FieldRevenueAccumulatedCompleted)
}

// SetPayDate sets the "pay_date" field.
func (m *ProjectMutation) SetPayDate(t time.Time) {
	m.pay_date = &t
}

// PayDate returns the value of the "pay_date" field in the mutation.
func (m *ProjectMutation) PayDate() (r time.Time, exists bool) {
	v := m.pay_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPayDate returns the old "pay_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPayDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayDate: %w", err)
	}
	return oldValue.PayDate, nil
}

// ClearPayDate clears the value of the "pay_date" field.
func (m *ProjectMutation) ClearPayDate() {
	m.pay_date = nil
	m.clearedFields[project.FieldPayDate] = struct{}{}
}

// PayDateCleared returns if the "pay_date" field was cleared in this mutation.
func (m *ProjectMutation) PayDateCleared() bool {
	_, ok := m.clearedFields[project.FieldPayDate]
	return ok
}

// ResetPayDate resets all changes to the "pay_date" field.
func (m *ProjectMutation) ResetPayDate() {
	m.pay_date = nil
	delete(m.clearedFields, project.FieldPayDate)
}

// SetOwnerVoCount sets the "owner_vo_count" field.
func (m *ProjectMutation) SetOwnerVoCount(i int) {
	m.owner_vo_count = &i
	m.addowner_vo_count = nil
}

// OwnerVoCount returns the value of the "owner_vo_count" field in the mutation.
func (m *ProjectMutation) OwnerVoCount() (r int, exists bool) {
	v := m.owner_vo_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerVoCount returns the old "owner_vo_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldOwnerVoCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerVoCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerVoCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerVoCount: %w", err)
	}
	return oldValue.OwnerVoCount, nil
}

// AddOwnerVoCount adds i to the "owner_vo_count" field.
func (m *ProjectMutation) AddOwnerVoCount(i int) {
	if m.addowner_vo_count != nil {
		*m.addowner_vo_count += i
	} else {
		m.addowner_vo_count = &i
	}
}

// AddedOwnerVoCount returns the value that was added to the "owner_vo_count" field in this mutation.
func (m *ProjectMutation) AddedOwnerVoCount() (r int, exists bool) {
	v := m.addowner_vo_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerVoCount clears the value of the "owner_vo_count" field.
func (m *ProjectMutation) ClearOwnerVoCount() {
	m.owner_vo_count = nil
	m.addowner_vo_count = nil
	m.clearedFields[project.FieldOwnerVoCount] = struct{}{}
}

// OwnerVoCountCleared returns if the "owner_vo_count" field was cleared in this mutation.
func (m *ProjectMutation) OwnerVoCountCleared() bool {
	_, ok := m.clearedFields[project.FieldOwnerVoCount]
	return ok
}

// ResetOwnerVoCount resets all changes to the "owner_vo_count" field.
func (m *ProjectMutation) ResetOwnerVoCount() {
	m.owner_vo_count = nil
	m.addowner_vo_count = nil
	delete(m.clearedFields, project.FieldOwnerVoCount)
}

// SetContractorVoCount sets the "contractor_vo_count" field.
func (m *ProjectMutation) SetContractorVoCount(i int) {
	m.contractor_vo_count = &i
	m.addcontractor_vo_count = nil
}

// ContractorVoCount returns the value of the "contractor_vo_count" field in the mutation.
func (m *ProjectMutation) ContractorVoCount() (r int, exists bool) {
	v := m.contractor_vo_count
	if v == nil {
		return
	}
	return *v, true
}

// OldContractorVoCount returns the old "contractor_vo_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldContractorVoCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractorVoCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractorVoCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractorVoCount: %w", err)
	}
	return oldValue.ContractorVoCount, nil
}

// AddContractorVoCount adds i to the "contractor_vo_count" field.
func (m *ProjectMutation) AddContractorVoCount(i int) {
	if m.addcontractor_vo_count != nil {
		*m.addcontractor_vo_count += i
	} else {
		m.addcontractor_vo_count = &i
	}
}

// AddedContractorVoCount returns the value that was added to the "contractor_vo_count" field in this mutation.
func (m *ProjectMutation) AddedContractorVoCount() (r int, exists bool) {
	v := m.addcontractor_vo_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractorVoCount clears the value of the "contractor_vo_count" field.
func (m *ProjectMutation) ClearContractorVoCount() {
	m.contractor_vo_count = nil
	m.addcontractor_vo_count = nil
	m.clearedFields[project.FieldContractorVoCount] = struct{}{}
}

// ContractorVoCountCleared returns if the "contractor_vo_count" field was cleared in this mutation.
func (m *ProjectMutation) ContractorVoCountCleared() bool {
	_, ok := m.clearedFields[project.FieldContractorVoCount]
	return ok
}

// ResetContractorVoCount resets all changes to the "contractor_vo_count" field.
func (m *ProjectMutation) ResetContractorVoCount() {
	m.contractor_vo_count = nil
	m.addcontractor_vo_count = nil
	delete(m.clearedFields, project.FieldContractorVoCount)
}

// SetAccumulateDeduction sets the "accumulate_deduction" field.
func (m *ProjectMutation) SetAccumulateDeduction(f float64) {
	m.accumulate_deduction = &f
	m.addaccumulate_deduction = nil
}

// AccumulateDeduction returns the value of the "accumulate_deduction" field in the mutation.
func (m *ProjectMutation) AccumulateDeduction() (r float64, exists bool) {
	v := m.accumulate_deduction
	if v == nil {
		return
	}
	return *v, true
}

// OldAccumulateDeduction returns the old "accumulate_deduction" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAccumulateDeduction(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccumulateDeduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccumulateDeduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccumulateDeduction: %w", err)
	}
	return oldValue.AccumulateDeduction, nil
}

// AddAccumulateDeduction adds f to the "accumulate_deduction" field.
func (m *ProjectMutation) AddAccumulateDeduction(f float64) {
	if m.addaccumulate_deduction != nil {
		*m.addaccumulate_deduction += f
	} else {
		m.addaccumulate_deduction = &f
	}
}

// AddedAccumulateDeduction returns the value that was added to the "accumulate_deduction" field in this mutation.
func (m *ProjectMutation) AddedAccumulateDeduction() (r float64, exists bool) {
	v := m.addaccumulate_deduction
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccumulateDeduction clears the value of the "accumulate_deduction" field.
func (m *ProjectMutation) ClearAccumulateDeduction() {
	m.accumulate_deduction = nil
	m.addaccumulate_deduction = nil
	m.clearedFields[project.FieldAccumulateDeduction] = struct{}{}
}

// AccumulateDeductionCleared returns if the "accumulate_deduction" field was cleared in this mutation.
func (m *ProjectMutation) AccumulateDeductionCleared() bool {
	_, ok := m.clearedFields[project.FieldAccumulateDeduction]
	return ok
}

// ResetAccumulateDeduction resets all changes to the "accumulate_deduction" field.
func (m *ProjectMutation) ResetAccumulateDeduction() {
	m.accumulate_deduction = nil
	m.addaccumulate_deduction = nil
	delete(m.clearedFields, project.FieldAccumulateDeduction)
}

// SetSubcontractorVaCount sets the "subcontractor_va_count" field.
func (m *ProjectMutation) SetSubcontractorVaCount(i int) {
	m.subcontractor_va_count = &i
	m.addsubcontractor_va_count = nil
}

// SubcontractorVaCount returns the value of the "subcontractor_va_count" field in the mutation.
func (m *ProjectMutation) SubcontractorVaCount() (r int, exists bool) {
	v := m.subcontractor_va_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSubcontractorVaCount returns the old "subcontractor_va_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSubcontractorVaCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubcontractorVaCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubcontractorVaCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubcontractorVaCount: %w", err)
	}
	return oldValue.SubcontractorVaCount, nil
}

// AddSubcontractorVaCount adds i to the "subcontractor_va_count" field.
func (m *ProjectMutation) AddSubcontractorVaCount(i int) {
	if m.addsubcontractor_va_count != nil {
		*m.addsubcontractor_va_count += i
	} else {
		m.addsubcontractor_va_count = &i
	}
}

// AddedSubcontractorVaCount returns the value that was added to the "subcontractor_va_count" field in this mutation.
func (m *ProjectMutation) AddedSubcontractorVaCount() (r int, exists bool) {
	v := m.addsubcontractor_va_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubcontractorVaCount clears the value of the "subcontractor_va_count" field.
func (m *ProjectMutation) ClearSubcontractorVaCount() {
	m.subcontractor_va_count = nil
	m.addsubcontractor_va_count = nil
	m.clearedFields[project.FieldSubcontractorVaCount] = struct{}{}
}

// SubcontractorVaCountCleared returns if the "subcontractor_va_count" field was cleared in this mutation.
func (m *ProjectMutation) SubcontractorVaCountCleared() bool {
	_, ok := m.clearedFields[project.FieldSubcontractorVaCount]
	return ok
}

// ResetSubcontractorVaCount resets all changes to the "subcontractor_va_count" field.
func (m *ProjectMutation) ResetSubcontractorVaCount() {
	m.subcontractor_va_count = nil
	m.addsubcontractor_va_count = nil
	delete(m.clearedFields, project.FieldSubcontractorVaCount)
}

// SetContractSupplementaryCount sets the "contract_supplementary_count" field.
func (m *ProjectMutation) SetContractSupplementaryCount(i int) {
	m.contract_supplementary_count = &i
	m.addcontract_supplementary_count = nil
}

// ContractSupplementaryCount returns the value of the "contract_supplementary_count" field in the mutation.
func (m *ProjectMutation) ContractSupplementaryCount() (r int, exists bool) {
	v := m.contract_supplementary_count
	if v == nil {
		return
	}
	return *v, true
}

// OldContractSupplementaryCount returns the old "contract_supplementary_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldContractSupplementaryCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractSupplementaryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractSupplementaryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractSupplementaryCount: %w", err)
	}
	return oldValue.ContractSupplementaryCount, nil
}

// AddContractSupplementaryCount adds i to the "contract_supplementary_count" field.
func (m *ProjectMutation) AddContractSupplementaryCount(i int) {
	if m.addcontract_supplementary_count != nil {
		*m.addcontract_supplementary_count += i
	} else {
		m.addcontract_supplementary_count = &i
	}
}

// AddedContractSupplementaryCount returns the value that was added to the "contract_supplementary_count" field in this mutation.
func (m *ProjectMutation) AddedContractSupplementaryCount() (r int, exists bool) {
	v := m.addcontract_supplementary_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractSupplementaryCount clears the value of the "contract_supplementary_count" field.
func (m *ProjectMutation) ClearContractSupplementaryCount() {
	m.contract_supplementary_count = nil
	m.addcontract_supplementary_count = nil
	m.clearedFields[project.FieldContractSupplementaryCount] = struct{}{}
}

// ContractSupplementaryCountCleared returns if the "contract_supplementary_count" field was cleared in this mutation.
func (m *ProjectMutation) ContractSupplementaryCountCleared() bool {
	_, ok := m.clearedFields[project.FieldContractSupplementaryCount]
	return ok
}

// ResetContractSupplementaryCount resets all changes to the "contract_supplementary_count" field.
func (m *ProjectMutation) ResetContractSupplementaryCount() {
	m.contract_supplementary_count = nil
	m.addcontract_supplementary_count = nil
	delete(m.clearedFields, project.FieldContractSupplementaryCount)
}

// SetRepairFee sets the "repair_fee" field.
func (m *ProjectMutation) SetRepairFee(f float64) {
	m.repair_fee = &f
	m.addrepair_fee = nil
}

// RepairFee returns the value of the "repair_fee" field in the mutation.
func (m *ProjectMutation) RepairFee() (r float64, exists bool) {
	v := m.repair_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldRepairFee returns the old "repair_fee" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRepairFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepairFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepairFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepairFee: %w", err)
	}
	return oldValue.RepairFee, nil
}

// AddRepairFee adds f to the "repair_fee" field.
func (m *ProjectMutation) AddRepairFee(f float64) {
	if m.addrepair_fee != nil {
		*m.addrepair_fee += f
	} else {
		m.addrepair_fee = &f
	}
}

// AddedRepairFee returns the value that was added to the "repair_fee" field in this mutation.
func (m *ProjectMutation) AddedRepairFee() (r float64, exists bool) {
	v := m.addrepair_fee
	if v == nil {
		return
	}
	return *v, true
}

// ClearRepairFee clears the value of the "repair_fee" field.
func (m *ProjectMutation) ClearRepairFee() {
	m.repair_fee = nil
	m.addrepair_fee = nil
	m.clearedFields[project.FieldRepairFee] = struct{}{}
}

// RepairFeeCleared returns if the "repair_fee" field was cleared in this mutation.
func (m *ProjectMutation) RepairFeeCleared() bool {
	_, ok := m.clearedFields[project.FieldRepairFee]
	return ok
}

// ResetRepairFee resets all changes to the "repair_fee" field.
func (m *ProjectMutation) ResetRepairFee() {
	m.repair_fee = nil
	m.addrepair_fee = nil
	delete(m.clearedFields, project.FieldRepairFee)
}

// SetUnitInventoryTotal sets the "unit_inventory_total" field.
func (m *ProjectMutation) SetUnitInventoryTotal(f float64) {
	m.unit_inventory_total = &f
	m.addunit_inventory_total = nil
}

// UnitInventoryTotal returns the value of the "unit_inventory_total" field in the mutation.
func (m *ProjectMutation) UnitInventoryTotal() (r float64, exists bool) {
	v := m.unit_inventory_total
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitInventoryTotal returns the old "unit_inventory_total" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUnitInventoryTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitInventoryTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitInventoryTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitInventoryTotal: %w", err)
	}
	return oldValue.UnitInventoryTotal, nil
}

// AddUnitInventoryTotal adds f to the "unit_inventory_total" field.
func (m *ProjectMutation) AddUnitInventoryTotal(f float64) {
	if m.addunit_inventory_total != nil {
		*m.addunit_inventory_total += f
	} else {
		m.addunit_inventory_total = &f
	}
}

// AddedUnitInventoryTotal returns the value that was added to the "unit_inventory_total" field in this mutation.
func (m *ProjectMutation) AddedUnitInventoryTotal() (r float64, exists bool) {
	v := m.addunit_inventory_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitInventoryTotal clears the value of the "unit_inventory_total" field.
func (m *ProjectMutation) ClearUnitInventoryTotal() {
	m.unit_inventory_total = nil
	m.addunit_inventory_total = nil
	m.clearedFields[project.FieldUnitInventoryTotal] = struct{}{}
}

// UnitInventoryTotalCleared returns if the "unit_inventory_total" field was cleared in this mutation.
func (m *ProjectMutation) UnitInventoryTotalCleared() bool {
	_, ok := m.clearedFields[project.FieldUnitInventoryTotal]
	return ok
}

// ResetUnitInventoryTotal resets all changes to the "unit_inventory_total" field.
func (m *ProjectMutation) ResetUnitInventoryTotal() {
	m.unit_inventory_total = nil
	m.addunit_inventory_total = nil
	delete(m.clearedFields, project.FieldUnitInventoryTotal)
}

// SetUnitComponentTotal sets the "unit_component_total" field.
func (m *ProjectMutation) SetUnitComponentTotal(f float64) {
	m.unit_component_total = &f
	m.addunit_component_total = nil
}

// UnitComponentTotal returns the value of the "unit_component_total" field in the mutation.
func (m *ProjectMutation) UnitComponentTotal() (r float64, exists bool) {
	v := m.unit_component_total
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitComponentTotal returns the old "unit_component_total" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUnitComponentTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitComponentTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitComponentTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitComponentTotal: %w", err)
	}
	return oldValue.UnitComponentTotal, nil
}

// AddUnitComponentTotal adds f to the "unit_component_total" field.
func (m *ProjectMutation) AddUnitComponentTotal(f float64) {
	if m.addunit_component_total != nil {
		*m.addunit_component_total += f
	} else {
		m.addunit_component_total = &f
	}
}

// AddedUnitComponentTotal returns the value that was added to the "unit_component_total" field in this mutation.
func (m *ProjectMutation) AddedUnitComponentTotal() (r float64, exists bool) {
	v := m.addunit_component_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitComponentTotal clears the value of the "unit_component_total" field.
func (m *ProjectMutation) ClearUnitComponentTotal() {
	m.unit_component_total = nil
	m.addunit_component_total = nil
	m.clearedFields[project.FieldUnitComponentTotal] = struct{}{}
}

// UnitComponentTotalCleared returns if the "unit_component_total" field was cleared in this mutation.
func (m *ProjectMutation) UnitComponentTotalCleared() bool {
	_, ok := m.clearedFields[project.FieldUnitComponentTotal]
	return ok
}

// ResetUnitComponentTotal resets all changes to the "unit_component_total" field.
func (m *ProjectMutation) ResetUnitComponentTotal() {
	m.unit_component_total = nil
	m.addunit_component_total = nil
	delete(m.clearedFields, project.FieldUnitComponentTotal)
}

// SetUnitComponentProduction sets the "unit_component_production" field.
func (m *ProjectMutation) SetUnitComponentProduction(f float64) {
	m.unit_component_production = &f
	m.addunit_component_production = nil
}

// UnitComponentProduction returns the value of the "unit_component_production" field in the mutation.
func (m *ProjectMutation) UnitComponentProduction() (r float64, exists bool) {
	v := m.unit_component_production
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitComponentProduction returns the old "unit_component_production" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUnitComponentProduction(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitComponentProduction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitComponentProduction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitComponentProduction: %w", err)
	}
	return oldValue.UnitComponentProduction, nil
}

// AddUnitComponentProduction adds f to the "unit_component_production" field.
func (m *ProjectMutation) AddUnitComponentProduction(f float64) {
	if m.addunit_component_production != nil {
		*m.addunit_component_production += f
	} else {
		m.addunit_component_production = &f
	}
}

// AddedUnitComponentProduction returns the value that was added to the "unit_component_production" field in this mutation.
func (m *ProjectMutation) AddedUnitComponentProduction() (r float64, exists bool) {
	v := m.addunit_component_production
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitComponentProduction clears the value of the "unit_component_production" field.
func (m *ProjectMutation) ClearUnitComponentProduction() {
	m.unit_component_production = nil
	m.addunit_component_production = nil
	m.clearedFields[project.FieldUnitComponentProduction] = struct{}{}
}

// UnitComponentProductionCleared returns if the "unit_component_production" field was cleared in this mutation.
func (m *ProjectMutation) UnitComponentProductionCleared() bool {
	_, ok := m.clearedFields[project.FieldUnitComponentProduction]
	return ok
}

// ResetUnitComponentProduction resets all changes to the "unit_component_production" field.
func (m *ProjectMutation) ResetUnitComponentProduction() {
	m.unit_component_production = nil
	m.addunit_component_production = nil
	delete(m.clearedFields, project.FieldUnitComponentProduction)
}

// SetUnitComponentInstallation sets the "unit_component_installation" field.
func (m *ProjectMutation) SetUnitComponentInstallation(f float64) {
	m.unit_component_installation = &f
	m.addunit_component_installation = nil
}

// UnitComponentInstallation returns the value of the "unit_component_installation" field in the mutation.
func (m *ProjectMutation) UnitComponentInstallation() (r float64, exists bool) {
	v := m.unit_component_installation
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitComponentInstallation returns the old "unit_component_installation" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUnitComponentInstallation(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitComponentInstallation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitComponentInstallation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitComponentInstallation: %w", err)
	}
	return oldValue.UnitComponentInstallation, nil
}

// AddUnitComponentInstallation adds f to the "unit_component_installation" field.
func (m *ProjectMutation) AddUnitComponentInstallation(f float64) {
	if m.addunit_component_installation != nil {
		*m.addunit_component_installation += f
	} else {
		m.addunit_component_installation = &f
	}
}

// AddedUnitComponentInstallation returns the value that was added to the "unit_component_installation" field in this mutation.
func (m *ProjectMutation) AddedUnitComponentInstallation() (r float64, exists bool) {
	v := m.addunit_component_installation
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitComponentInstallation clears the value of the "unit_component_installation" field.
func (m *ProjectMutation) ClearUnitComponentInstallation() {
	m.unit_component_installation = nil
	m.addunit_component_installation = nil
	m.clearedFields[project.FieldUnitComponentInstallation] = struct{}{}
}

// UnitComponentInstallationCleared returns if the "unit_component_installation" field was cleared in this mutation.
func (m *ProjectMutation) UnitComponentInstallationCleared() bool {
	_, ok := m.clearedFields[project.FieldUnitComponentInstallation]
	return ok
}

// ResetUnitComponentInstallation resets all changes to the "unit_component_installation" field.
func (m *ProjectMutation) ResetUnitComponentInstallation() {
	m.unit_component_installation = nil
	m.addunit_component_installation = nil
	delete(m.clearedFields, project.FieldUnitComponentInstallation)
}

// SetBulkMaterialsTotalOrderQuantity sets the "bulk_materials_total_order_quantity" field.
func (m *ProjectMutation) SetBulkMaterialsTotalOrderQuantity(f float64) {
	m.bulk_materials_total_order_quantity = &f
	m.addbulk_materials_total_order_quantity = nil
}

// BulkMaterialsTotalOrderQuantity returns the value of the "bulk_materials_total_order_quantity" field in the mutation.
func (m *ProjectMutation) BulkMaterialsTotalOrderQuantity() (r float64, exists bool) {
	v := m.bulk_materials_total_order_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldBulkMaterialsTotalOrderQuantity returns the old "bulk_materials_total_order_quantity" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBulkMaterialsTotalOrderQuantity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBulkMaterialsTotalOrderQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBulkMaterialsTotalOrderQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulkMaterialsTotalOrderQuantity: %w", err)
	}
	return oldValue.BulkMaterialsTotalOrderQuantity, nil
}

// AddBulkMaterialsTotalOrderQuantity adds f to the "bulk_materials_total_order_quantity" field.
func (m *ProjectMutation) AddBulkMaterialsTotalOrderQuantity(f float64) {
	if m.addbulk_materials_total_order_quantity != nil {
		*m.addbulk_materials_total_order_quantity += f
	} else {
		m.addbulk_materials_total_order_quantity = &f
	}
}

// AddedBulkMaterialsTotalOrderQuantity returns the value that was added to the "bulk_materials_total_order_quantity" field in this mutation.
func (m *ProjectMutation) AddedBulkMaterialsTotalOrderQuantity() (r float64, exists bool) {
	v := m.addbulk_materials_total_order_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearBulkMaterialsTotalOrderQuantity clears the value of the "bulk_materials_total_order_quantity" field.
func (m *ProjectMutation) ClearBulkMaterialsTotalOrderQuantity() {
	m.bulk_materials_total_order_quantity = nil
	m.addbulk_materials_total_order_quantity = nil
	m.clearedFields[project.FieldBulkMaterialsTotalOrderQuantity] = struct{}{}
}

// BulkMaterialsTotalOrderQuantityCleared returns if the "bulk_materials_total_order_quantity" field was cleared in this mutation.
func (m *ProjectMutation) BulkMaterialsTotalOrderQuantityCleared() bool {
	_, ok := m.clearedFields[project.FieldBulkMaterialsTotalOrderQuantity]
	return ok
}

// ResetBulkMaterialsTotalOrderQuantity resets all changes to the "bulk_materials_total_order_quantity" field.
func (m *ProjectMutation) ResetBulkMaterialsTotalOrderQuantity() {
	m.bulk_materials_total_order_quantity = nil
	m.addbulk_materials_total_order_quantity = nil
	delete(m.clearedFields, project.FieldBulkMaterialsTotalOrderQuantity)
}

// SetBulkMaterialsCompletedQuantity sets the "bulk_materials_completed_quantity" field.
func (m *ProjectMutation) SetBulkMaterialsCompletedQuantity(f float64) {
	m.bulk_materials_completed_quantity = &f
	m.addbulk_materials_completed_quantity = nil
}

// BulkMaterialsCompletedQuantity returns the value of the "bulk_materials_completed_quantity" field in the mutation.
func (m *ProjectMutation) BulkMaterialsCompletedQuantity() (r float64, exists bool) {
	v := m.bulk_materials_completed_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldBulkMaterialsCompletedQuantity returns the old "bulk_materials_completed_quantity" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBulkMaterialsCompletedQuantity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBulkMaterialsCompletedQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBulkMaterialsCompletedQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulkMaterialsCompletedQuantity: %w", err)
	}
	return oldValue.BulkMaterialsCompletedQuantity, nil
}

// AddBulkMaterialsCompletedQuantity adds f to the "bulk_materials_completed_quantity" field.
func (m *ProjectMutation) AddBulkMaterialsCompletedQuantity(f float64) {
	if m.addbulk_materials_completed_quantity != nil {
		*m.addbulk_materials_completed_quantity += f
	} else {
		m.addbulk_materials_completed_quantity = &f
	}
}

// AddedBulkMaterialsCompletedQuantity returns the value that was added to the "bulk_materials_completed_quantity" field in this mutation.
func (m *ProjectMutation) AddedBulkMaterialsCompletedQuantity() (r float64, exists bool) {
	v := m.addbulk_materials_completed_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearBulkMaterialsCompletedQuantity clears the value of the "bulk_materials_completed_quantity" field.
func (m *ProjectMutation) ClearBulkMaterialsCompletedQuantity() {
	m.bulk_materials_completed_quantity = nil
	m.addbulk_materials_completed_quantity = nil
	m.clearedFields[project.FieldBulkMaterialsCompletedQuantity] = struct{}{}
}

// BulkMaterialsCompletedQuantityCleared returns if the "bulk_materials_completed_quantity" field was cleared in this mutation.
func (m *ProjectMutation) BulkMaterialsCompletedQuantityCleared() bool {
	_, ok := m.clearedFields[project.FieldBulkMaterialsCompletedQuantity]
	return ok
}

// ResetBulkMaterialsCompletedQuantity resets all changes to the "bulk_materials_completed_quantity" field.
func (m *ProjectMutation) ResetBulkMaterialsCompletedQuantity() {
	m.bulk_materials_completed_quantity = nil
	m.addbulk_materials_completed_quantity = nil
	delete(m.clearedFields, project.FieldBulkMaterialsCompletedQuantity)
}

// SetBulkMaterialsUncompletedQuantity sets the "bulk_materials_uncompleted_quantity" field.
func (m *ProjectMutation) SetBulkMaterialsUncompletedQuantity(f float64) {
	m.bulk_materials_uncompleted_quantity = &f
	m.addbulk_materials_uncompleted_quantity = nil
}

// BulkMaterialsUncompletedQuantity returns the value of the "bulk_materials_uncompleted_quantity" field in the mutation.
func (m *ProjectMutation) BulkMaterialsUncompletedQuantity() (r float64, exists bool) {
	v := m.bulk_materials_uncompleted_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldBulkMaterialsUncompletedQuantity returns the old "bulk_materials_uncompleted_quantity" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldBulkMaterialsUncompletedQuantity(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBulkMaterialsUncompletedQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBulkMaterialsUncompletedQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulkMaterialsUncompletedQuantity: %w", err)
	}
	return oldValue.BulkMaterialsUncompletedQuantity, nil
}

// AddBulkMaterialsUncompletedQuantity adds f to the "bulk_materials_uncompleted_quantity" field.
func (m *ProjectMutation) AddBulkMaterialsUncompletedQuantity(f float64) {
	if m.addbulk_materials_uncompleted_quantity != nil {
		*m.addbulk_materials_uncompleted_quantity += f
	} else {
		m.addbulk_materials_uncompleted_quantity = &f
	}
}

// AddedBulkMaterialsUncompletedQuantity returns the value that was added to the "bulk_materials_uncompleted_quantity" field in this mutation.
func (m *ProjectMutation) AddedBulkMaterialsUncompletedQuantity() (r float64, exists bool) {
	v := m.addbulk_materials_uncompleted_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearBulkMaterialsUncompletedQuantity clears the value of the "bulk_materials_uncompleted_quantity" field.
func (m *ProjectMutation) ClearBulkMaterialsUncompletedQuantity() {
	m.bulk_materials_uncompleted_quantity = nil
	m.addbulk_materials_uncompleted_quantity = nil
	m.clearedFields[project.FieldBulkMaterialsUncompletedQuantity] = struct{}{}
}

// BulkMaterialsUncompletedQuantityCleared returns if the "bulk_materials_uncompleted_quantity" field was cleared in this mutation.
func (m *ProjectMutation) BulkMaterialsUncompletedQuantityCleared() bool {
	_, ok := m.clearedFields[project.FieldBulkMaterialsUncompletedQuantity]
	return ok
}

// ResetBulkMaterialsUncompletedQuantity resets all changes to the "bulk_materials_uncompleted_quantity" field.
func (m *ProjectMutation) ResetBulkMaterialsUncompletedQuantity() {
	m.bulk_materials_uncompleted_quantity = nil
	m.addbulk_materials_uncompleted_quantity = nil
	delete(m.clearedFields, project.FieldBulkMaterialsUncompletedQuantity)
}

// SetDiagramBdFinishCount sets the "diagram_bd_finish_count" field.
func (m *ProjectMutation) SetDiagramBdFinishCount(i int) {
	m.diagram_bd_finish_count = &i
	m.adddiagram_bd_finish_count = nil
}

// DiagramBdFinishCount returns the value of the "diagram_bd_finish_count" field in the mutation.
func (m *ProjectMutation) DiagramBdFinishCount() (r int, exists bool) {
	v := m.diagram_bd_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramBdFinishCount returns the old "diagram_bd_finish_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramBdFinishCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramBdFinishCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramBdFinishCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramBdFinishCount: %w", err)
	}
	return oldValue.DiagramBdFinishCount, nil
}

// AddDiagramBdFinishCount adds i to the "diagram_bd_finish_count" field.
func (m *ProjectMutation) AddDiagramBdFinishCount(i int) {
	if m.adddiagram_bd_finish_count != nil {
		*m.adddiagram_bd_finish_count += i
	} else {
		m.adddiagram_bd_finish_count = &i
	}
}

// AddedDiagramBdFinishCount returns the value that was added to the "diagram_bd_finish_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramBdFinishCount() (r int, exists bool) {
	v := m.adddiagram_bd_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramBdFinishCount clears the value of the "diagram_bd_finish_count" field.
func (m *ProjectMutation) ClearDiagramBdFinishCount() {
	m.diagram_bd_finish_count = nil
	m.adddiagram_bd_finish_count = nil
	m.clearedFields[project.FieldDiagramBdFinishCount] = struct{}{}
}

// DiagramBdFinishCountCleared returns if the "diagram_bd_finish_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramBdFinishCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramBdFinishCount]
	return ok
}

// ResetDiagramBdFinishCount resets all changes to the "diagram_bd_finish_count" field.
func (m *ProjectMutation) ResetDiagramBdFinishCount() {
	m.diagram_bd_finish_count = nil
	m.adddiagram_bd_finish_count = nil
	delete(m.clearedFields, project.FieldDiagramBdFinishCount)
}

// SetDiagramBdTotalCount sets the "diagram_bd_total_count" field.
func (m *ProjectMutation) SetDiagramBdTotalCount(i int) {
	m.diagram_bd_total_count = &i
	m.adddiagram_bd_total_count = nil
}

// DiagramBdTotalCount returns the value of the "diagram_bd_total_count" field in the mutation.
func (m *ProjectMutation) DiagramBdTotalCount() (r int, exists bool) {
	v := m.diagram_bd_total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramBdTotalCount returns the old "diagram_bd_total_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramBdTotalCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramBdTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramBdTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramBdTotalCount: %w", err)
	}
	return oldValue.DiagramBdTotalCount, nil
}

// AddDiagramBdTotalCount adds i to the "diagram_bd_total_count" field.
func (m *ProjectMutation) AddDiagramBdTotalCount(i int) {
	if m.adddiagram_bd_total_count != nil {
		*m.adddiagram_bd_total_count += i
	} else {
		m.adddiagram_bd_total_count = &i
	}
}

// AddedDiagramBdTotalCount returns the value that was added to the "diagram_bd_total_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramBdTotalCount() (r int, exists bool) {
	v := m.adddiagram_bd_total_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramBdTotalCount clears the value of the "diagram_bd_total_count" field.
func (m *ProjectMutation) ClearDiagramBdTotalCount() {
	m.diagram_bd_total_count = nil
	m.adddiagram_bd_total_count = nil
	m.clearedFields[project.FieldDiagramBdTotalCount] = struct{}{}
}

// DiagramBdTotalCountCleared returns if the "diagram_bd_total_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramBdTotalCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramBdTotalCount]
	return ok
}

// ResetDiagramBdTotalCount resets all changes to the "diagram_bd_total_count" field.
func (m *ProjectMutation) ResetDiagramBdTotalCount() {
	m.diagram_bd_total_count = nil
	m.adddiagram_bd_total_count = nil
	delete(m.clearedFields, project.FieldDiagramBdTotalCount)
}

// SetDiagramConstructionFinishCount sets the "diagram_construction_finish_count" field.
func (m *ProjectMutation) SetDiagramConstructionFinishCount(i int) {
	m.diagram_construction_finish_count = &i
	m.adddiagram_construction_finish_count = nil
}

// DiagramConstructionFinishCount returns the value of the "diagram_construction_finish_count" field in the mutation.
func (m *ProjectMutation) DiagramConstructionFinishCount() (r int, exists bool) {
	v := m.diagram_construction_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramConstructionFinishCount returns the old "diagram_construction_finish_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramConstructionFinishCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramConstructionFinishCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramConstructionFinishCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramConstructionFinishCount: %w", err)
	}
	return oldValue.DiagramConstructionFinishCount, nil
}

// AddDiagramConstructionFinishCount adds i to the "diagram_construction_finish_count" field.
func (m *ProjectMutation) AddDiagramConstructionFinishCount(i int) {
	if m.adddiagram_construction_finish_count != nil {
		*m.adddiagram_construction_finish_count += i
	} else {
		m.adddiagram_construction_finish_count = &i
	}
}

// AddedDiagramConstructionFinishCount returns the value that was added to the "diagram_construction_finish_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramConstructionFinishCount() (r int, exists bool) {
	v := m.adddiagram_construction_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramConstructionFinishCount clears the value of the "diagram_construction_finish_count" field.
func (m *ProjectMutation) ClearDiagramConstructionFinishCount() {
	m.diagram_construction_finish_count = nil
	m.adddiagram_construction_finish_count = nil
	m.clearedFields[project.FieldDiagramConstructionFinishCount] = struct{}{}
}

// DiagramConstructionFinishCountCleared returns if the "diagram_construction_finish_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramConstructionFinishCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramConstructionFinishCount]
	return ok
}

// ResetDiagramConstructionFinishCount resets all changes to the "diagram_construction_finish_count" field.
func (m *ProjectMutation) ResetDiagramConstructionFinishCount() {
	m.diagram_construction_finish_count = nil
	m.adddiagram_construction_finish_count = nil
	delete(m.clearedFields, project.FieldDiagramConstructionFinishCount)
}

// SetDiagramConstructionTotalCount sets the "diagram_construction_total_count" field.
func (m *ProjectMutation) SetDiagramConstructionTotalCount(i int) {
	m.diagram_construction_total_count = &i
	m.adddiagram_construction_total_count = nil
}

// DiagramConstructionTotalCount returns the value of the "diagram_construction_total_count" field in the mutation.
func (m *ProjectMutation) DiagramConstructionTotalCount() (r int, exists bool) {
	v := m.diagram_construction_total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramConstructionTotalCount returns the old "diagram_construction_total_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramConstructionTotalCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramConstructionTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramConstructionTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramConstructionTotalCount: %w", err)
	}
	return oldValue.DiagramConstructionTotalCount, nil
}

// AddDiagramConstructionTotalCount adds i to the "diagram_construction_total_count" field.
func (m *ProjectMutation) AddDiagramConstructionTotalCount(i int) {
	if m.adddiagram_construction_total_count != nil {
		*m.adddiagram_construction_total_count += i
	} else {
		m.adddiagram_construction_total_count = &i
	}
}

// AddedDiagramConstructionTotalCount returns the value that was added to the "diagram_construction_total_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramConstructionTotalCount() (r int, exists bool) {
	v := m.adddiagram_construction_total_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramConstructionTotalCount clears the value of the "diagram_construction_total_count" field.
func (m *ProjectMutation) ClearDiagramConstructionTotalCount() {
	m.diagram_construction_total_count = nil
	m.adddiagram_construction_total_count = nil
	m.clearedFields[project.FieldDiagramConstructionTotalCount] = struct{}{}
}

// DiagramConstructionTotalCountCleared returns if the "diagram_construction_total_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramConstructionTotalCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramConstructionTotalCount]
	return ok
}

// ResetDiagramConstructionTotalCount resets all changes to the "diagram_construction_total_count" field.
func (m *ProjectMutation) ResetDiagramConstructionTotalCount() {
	m.diagram_construction_total_count = nil
	m.adddiagram_construction_total_count = nil
	delete(m.clearedFields, project.FieldDiagramConstructionTotalCount)
}

// SetDiagramProcessingFinishCount sets the "diagram_processing_finish_count" field.
func (m *ProjectMutation) SetDiagramProcessingFinishCount(i int) {
	m.diagram_processing_finish_count = &i
	m.adddiagram_processing_finish_count = nil
}

// DiagramProcessingFinishCount returns the value of the "diagram_processing_finish_count" field in the mutation.
func (m *ProjectMutation) DiagramProcessingFinishCount() (r int, exists bool) {
	v := m.diagram_processing_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramProcessingFinishCount returns the old "diagram_processing_finish_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramProcessingFinishCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramProcessingFinishCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramProcessingFinishCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramProcessingFinishCount: %w", err)
	}
	return oldValue.DiagramProcessingFinishCount, nil
}

// AddDiagramProcessingFinishCount adds i to the "diagram_processing_finish_count" field.
func (m *ProjectMutation) AddDiagramProcessingFinishCount(i int) {
	if m.adddiagram_processing_finish_count != nil {
		*m.adddiagram_processing_finish_count += i
	} else {
		m.adddiagram_processing_finish_count = &i
	}
}

// AddedDiagramProcessingFinishCount returns the value that was added to the "diagram_processing_finish_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramProcessingFinishCount() (r int, exists bool) {
	v := m.adddiagram_processing_finish_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramProcessingFinishCount clears the value of the "diagram_processing_finish_count" field.
func (m *ProjectMutation) ClearDiagramProcessingFinishCount() {
	m.diagram_processing_finish_count = nil
	m.adddiagram_processing_finish_count = nil
	m.clearedFields[project.FieldDiagramProcessingFinishCount] = struct{}{}
}

// DiagramProcessingFinishCountCleared returns if the "diagram_processing_finish_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramProcessingFinishCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramProcessingFinishCount]
	return ok
}

// ResetDiagramProcessingFinishCount resets all changes to the "diagram_processing_finish_count" field.
func (m *ProjectMutation) ResetDiagramProcessingFinishCount() {
	m.diagram_processing_finish_count = nil
	m.adddiagram_processing_finish_count = nil
	delete(m.clearedFields, project.FieldDiagramProcessingFinishCount)
}

// SetDiagramProcessingTotalCount sets the "diagram_processing_total_count" field.
func (m *ProjectMutation) SetDiagramProcessingTotalCount(i int) {
	m.diagram_processing_total_count = &i
	m.adddiagram_processing_total_count = nil
}

// DiagramProcessingTotalCount returns the value of the "diagram_processing_total_count" field in the mutation.
func (m *ProjectMutation) DiagramProcessingTotalCount() (r int, exists bool) {
	v := m.diagram_processing_total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramProcessingTotalCount returns the old "diagram_processing_total_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramProcessingTotalCount(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramProcessingTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramProcessingTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramProcessingTotalCount: %w", err)
	}
	return oldValue.DiagramProcessingTotalCount, nil
}

// AddDiagramProcessingTotalCount adds i to the "diagram_processing_total_count" field.
func (m *ProjectMutation) AddDiagramProcessingTotalCount(i int) {
	if m.adddiagram_processing_total_count != nil {
		*m.adddiagram_processing_total_count += i
	} else {
		m.adddiagram_processing_total_count = &i
	}
}

// AddedDiagramProcessingTotalCount returns the value that was added to the "diagram_processing_total_count" field in this mutation.
func (m *ProjectMutation) AddedDiagramProcessingTotalCount() (r int, exists bool) {
	v := m.adddiagram_processing_total_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramProcessingTotalCount clears the value of the "diagram_processing_total_count" field.
func (m *ProjectMutation) ClearDiagramProcessingTotalCount() {
	m.diagram_processing_total_count = nil
	m.adddiagram_processing_total_count = nil
	m.clearedFields[project.FieldDiagramProcessingTotalCount] = struct{}{}
}

// DiagramProcessingTotalCountCleared returns if the "diagram_processing_total_count" field was cleared in this mutation.
func (m *ProjectMutation) DiagramProcessingTotalCountCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramProcessingTotalCount]
	return ok
}

// ResetDiagramProcessingTotalCount resets all changes to the "diagram_processing_total_count" field.
func (m *ProjectMutation) ResetDiagramProcessingTotalCount() {
	m.diagram_processing_total_count = nil
	m.adddiagram_processing_total_count = nil
	delete(m.clearedFields, project.FieldDiagramProcessingTotalCount)
}

// SetDiagramCApprovalRatioNumerator sets the "diagram_c_approval_ratio_numerator" field.
func (m *ProjectMutation) SetDiagramCApprovalRatioNumerator(i int) {
	m.diagram_c_approval_ratio_numerator = &i
	m.adddiagram_c_approval_ratio_numerator = nil
}

// DiagramCApprovalRatioNumerator returns the value of the "diagram_c_approval_ratio_numerator" field in the mutation.
func (m *ProjectMutation) DiagramCApprovalRatioNumerator() (r int, exists bool) {
	v := m.diagram_c_approval_ratio_numerator
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramCApprovalRatioNumerator returns the old "diagram_c_approval_ratio_numerator" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramCApprovalRatioNumerator(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramCApprovalRatioNumerator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramCApprovalRatioNumerator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramCApprovalRatioNumerator: %w", err)
	}
	return oldValue.DiagramCApprovalRatioNumerator, nil
}

// AddDiagramCApprovalRatioNumerator adds i to the "diagram_c_approval_ratio_numerator" field.
func (m *ProjectMutation) AddDiagramCApprovalRatioNumerator(i int) {
	if m.adddiagram_c_approval_ratio_numerator != nil {
		*m.adddiagram_c_approval_ratio_numerator += i
	} else {
		m.adddiagram_c_approval_ratio_numerator = &i
	}
}

// AddedDiagramCApprovalRatioNumerator returns the value that was added to the "diagram_c_approval_ratio_numerator" field in this mutation.
func (m *ProjectMutation) AddedDiagramCApprovalRatioNumerator() (r int, exists bool) {
	v := m.adddiagram_c_approval_ratio_numerator
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramCApprovalRatioNumerator clears the value of the "diagram_c_approval_ratio_numerator" field.
func (m *ProjectMutation) ClearDiagramCApprovalRatioNumerator() {
	m.diagram_c_approval_ratio_numerator = nil
	m.adddiagram_c_approval_ratio_numerator = nil
	m.clearedFields[project.FieldDiagramCApprovalRatioNumerator] = struct{}{}
}

// DiagramCApprovalRatioNumeratorCleared returns if the "diagram_c_approval_ratio_numerator" field was cleared in this mutation.
func (m *ProjectMutation) DiagramCApprovalRatioNumeratorCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramCApprovalRatioNumerator]
	return ok
}

// ResetDiagramCApprovalRatioNumerator resets all changes to the "diagram_c_approval_ratio_numerator" field.
func (m *ProjectMutation) ResetDiagramCApprovalRatioNumerator() {
	m.diagram_c_approval_ratio_numerator = nil
	m.adddiagram_c_approval_ratio_numerator = nil
	delete(m.clearedFields, project.FieldDiagramCApprovalRatioNumerator)
}

// SetDiagramCApprovalRatioDenominator sets the "diagram_c_approval_ratio_denominator" field.
func (m *ProjectMutation) SetDiagramCApprovalRatioDenominator(i int) {
	m.diagram_c_approval_ratio_denominator = &i
	m.adddiagram_c_approval_ratio_denominator = nil
}

// DiagramCApprovalRatioDenominator returns the value of the "diagram_c_approval_ratio_denominator" field in the mutation.
func (m *ProjectMutation) DiagramCApprovalRatioDenominator() (r int, exists bool) {
	v := m.diagram_c_approval_ratio_denominator
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagramCApprovalRatioDenominator returns the old "diagram_c_approval_ratio_denominator" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDiagramCApprovalRatioDenominator(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiagramCApprovalRatioDenominator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiagramCApprovalRatioDenominator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagramCApprovalRatioDenominator: %w", err)
	}
	return oldValue.DiagramCApprovalRatioDenominator, nil
}

// AddDiagramCApprovalRatioDenominator adds i to the "diagram_c_approval_ratio_denominator" field.
func (m *ProjectMutation) AddDiagramCApprovalRatioDenominator(i int) {
	if m.adddiagram_c_approval_ratio_denominator != nil {
		*m.adddiagram_c_approval_ratio_denominator += i
	} else {
		m.adddiagram_c_approval_ratio_denominator = &i
	}
}

// AddedDiagramCApprovalRatioDenominator returns the value that was added to the "diagram_c_approval_ratio_denominator" field in this mutation.
func (m *ProjectMutation) AddedDiagramCApprovalRatioDenominator() (r int, exists bool) {
	v := m.adddiagram_c_approval_ratio_denominator
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiagramCApprovalRatioDenominator clears the value of the "diagram_c_approval_ratio_denominator" field.
func (m *ProjectMutation) ClearDiagramCApprovalRatioDenominator() {
	m.diagram_c_approval_ratio_denominator = nil
	m.adddiagram_c_approval_ratio_denominator = nil
	m.clearedFields[project.FieldDiagramCApprovalRatioDenominator] = struct{}{}
}

// DiagramCApprovalRatioDenominatorCleared returns if the "diagram_c_approval_ratio_denominator" field was cleared in this mutation.
func (m *ProjectMutation) DiagramCApprovalRatioDenominatorCleared() bool {
	_, ok := m.clearedFields[project.FieldDiagramCApprovalRatioDenominator]
	return ok
}

// ResetDiagramCApprovalRatioDenominator resets all changes to the "diagram_c_approval_ratio_denominator" field.
func (m *ProjectMutation) ResetDiagramCApprovalRatioDenominator() {
	m.diagram_c_approval_ratio_denominator = nil
	m.adddiagram_c_approval_ratio_denominator = nil
	delete(m.clearedFields, project.FieldDiagramCApprovalRatioDenominator)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *ProjectMutation) AddUserIDs(ids ...xid.ID) {
	if m.users == nil {
		m.users = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ProjectMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ProjectMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *ProjectMutation) RemoveUserIDs(ids ...xid.ID) {
	if m.removedusers == nil {
		m.removedusers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *ProjectMutation) RemovedUsersIDs() (ids []xid.ID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *ProjectMutation) UsersIDs() (ids []xid.ID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ProjectMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, project.FieldCode)
	}
	if m.is_finished != nil {
		fields = append(fields, project.FieldIsFinished)
	}
	if m.revenue_kpi != nil {
		fields = append(fields, project.FieldRevenueKpi)
	}
	if m.revenue_current_year_completed != nil {
		fields = append(fields, project.FieldRevenueCurrentYearCompleted)
	}
	if m.revenue_accumulated_completed != nil {
		fields = append(fields, project.FieldRevenueAccumulatedCompleted)
	}
	if m.pay_date != nil {
		fields = append(fields, project.FieldPayDate)
	}
	if m.owner_vo_count != nil {
		fields = append(fields, project.FieldOwnerVoCount)
	}
	if m.contractor_vo_count != nil {
		fields = append(fields, project.FieldContractorVoCount)
	}
	if m.accumulate_deduction != nil {
		fields = append(fields, project.FieldAccumulateDeduction)
	}
	if m.subcontractor_va_count != nil {
		fields = append(fields, project.FieldSubcontractorVaCount)
	}
	if m.contract_supplementary_count != nil {
		fields = append(fields, project.FieldContractSupplementaryCount)
	}
	if m.repair_fee != nil {
		fields = append(fields, project.FieldRepairFee)
	}
	if m.unit_inventory_total != nil {
		fields = append(fields, project.FieldUnitInventoryTotal)
	}
	if m.unit_component_total != nil {
		fields = append(fields, project.FieldUnitComponentTotal)
	}
	if m.unit_component_production != nil {
		fields = append(fields, project.FieldUnitComponentProduction)
	}
	if m.unit_component_installation != nil {
		fields = append(fields, project.FieldUnitComponentInstallation)
	}
	if m.bulk_materials_total_order_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsTotalOrderQuantity)
	}
	if m.bulk_materials_completed_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsCompletedQuantity)
	}
	if m.bulk_materials_uncompleted_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsUncompletedQuantity)
	}
	if m.diagram_bd_finish_count != nil {
		fields = append(fields, project.FieldDiagramBdFinishCount)
	}
	if m.diagram_bd_total_count != nil {
		fields = append(fields, project.FieldDiagramBdTotalCount)
	}
	if m.diagram_construction_finish_count != nil {
		fields = append(fields, project.FieldDiagramConstructionFinishCount)
	}
	if m.diagram_construction_total_count != nil {
		fields = append(fields, project.FieldDiagramConstructionTotalCount)
	}
	if m.diagram_processing_finish_count != nil {
		fields = append(fields, project.FieldDiagramProcessingFinishCount)
	}
	if m.diagram_processing_total_count != nil {
		fields = append(fields, project.FieldDiagramProcessingTotalCount)
	}
	if m.diagram_c_approval_ratio_numerator != nil {
		fields = append(fields, project.FieldDiagramCApprovalRatioNumerator)
	}
	if m.diagram_c_approval_ratio_denominator != nil {
		fields = append(fields, project.FieldDiagramCApprovalRatioDenominator)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldCode:
		return m.Code()
	case project.FieldIsFinished:
		return m.IsFinished()
	case project.FieldRevenueKpi:
		return m.RevenueKpi()
	case project.FieldRevenueCurrentYearCompleted:
		return m.RevenueCurrentYearCompleted()
	case project.FieldRevenueAccumulatedCompleted:
		return m.RevenueAccumulatedCompleted()
	case project.FieldPayDate:
		return m.PayDate()
	case project.FieldOwnerVoCount:
		return m.OwnerVoCount()
	case project.FieldContractorVoCount:
		return m.ContractorVoCount()
	case project.FieldAccumulateDeduction:
		return m.AccumulateDeduction()
	case project.FieldSubcontractorVaCount:
		return m.SubcontractorVaCount()
	case project.FieldContractSupplementaryCount:
		return m.ContractSupplementaryCount()
	case project.FieldRepairFee:
		return m.RepairFee()
	case project.FieldUnitInventoryTotal:
		return m.UnitInventoryTotal()
	case project.FieldUnitComponentTotal:
		return m.UnitComponentTotal()
	case project.FieldUnitComponentProduction:
		return m.UnitComponentProduction()
	case project.FieldUnitComponentInstallation:
		return m.UnitComponentInstallation()
	case project.FieldBulkMaterialsTotalOrderQuantity:
		return m.BulkMaterialsTotalOrderQuantity()
	case project.FieldBulkMaterialsCompletedQuantity:
		return m.BulkMaterialsCompletedQuantity()
	case project.FieldBulkMaterialsUncompletedQuantity:
		return m.BulkMaterialsUncompletedQuantity()
	case project.FieldDiagramBdFinishCount:
		return m.DiagramBdFinishCount()
	case project.FieldDiagramBdTotalCount:
		return m.DiagramBdTotalCount()
	case project.FieldDiagramConstructionFinishCount:
		return m.DiagramConstructionFinishCount()
	case project.FieldDiagramConstructionTotalCount:
		return m.DiagramConstructionTotalCount()
	case project.FieldDiagramProcessingFinishCount:
		return m.DiagramProcessingFinishCount()
	case project.FieldDiagramProcessingTotalCount:
		return m.DiagramProcessingTotalCount()
	case project.FieldDiagramCApprovalRatioNumerator:
		return m.DiagramCApprovalRatioNumerator()
	case project.FieldDiagramCApprovalRatioDenominator:
		return m.DiagramCApprovalRatioDenominator()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldCode:
		return m.OldCode(ctx)
	case project.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case project.FieldRevenueKpi:
		return m.OldRevenueKpi(ctx)
	case project.FieldRevenueCurrentYearCompleted:
		return m.OldRevenueCurrentYearCompleted(ctx)
	case project.FieldRevenueAccumulatedCompleted:
		return m.OldRevenueAccumulatedCompleted(ctx)
	case project.FieldPayDate:
		return m.OldPayDate(ctx)
	case project.FieldOwnerVoCount:
		return m.OldOwnerVoCount(ctx)
	case project.FieldContractorVoCount:
		return m.OldContractorVoCount(ctx)
	case project.FieldAccumulateDeduction:
		return m.OldAccumulateDeduction(ctx)
	case project.FieldSubcontractorVaCount:
		return m.OldSubcontractorVaCount(ctx)
	case project.FieldContractSupplementaryCount:
		return m.OldContractSupplementaryCount(ctx)
	case project.FieldRepairFee:
		return m.OldRepairFee(ctx)
	case project.FieldUnitInventoryTotal:
		return m.OldUnitInventoryTotal(ctx)
	case project.FieldUnitComponentTotal:
		return m.OldUnitComponentTotal(ctx)
	case project.FieldUnitComponentProduction:
		return m.OldUnitComponentProduction(ctx)
	case project.FieldUnitComponentInstallation:
		return m.OldUnitComponentInstallation(ctx)
	case project.FieldBulkMaterialsTotalOrderQuantity:
		return m.OldBulkMaterialsTotalOrderQuantity(ctx)
	case project.FieldBulkMaterialsCompletedQuantity:
		return m.OldBulkMaterialsCompletedQuantity(ctx)
	case project.FieldBulkMaterialsUncompletedQuantity:
		return m.OldBulkMaterialsUncompletedQuantity(ctx)
	case project.FieldDiagramBdFinishCount:
		return m.OldDiagramBdFinishCount(ctx)
	case project.FieldDiagramBdTotalCount:
		return m.OldDiagramBdTotalCount(ctx)
	case project.FieldDiagramConstructionFinishCount:
		return m.OldDiagramConstructionFinishCount(ctx)
	case project.FieldDiagramConstructionTotalCount:
		return m.OldDiagramConstructionTotalCount(ctx)
	case project.FieldDiagramProcessingFinishCount:
		return m.OldDiagramProcessingFinishCount(ctx)
	case project.FieldDiagramProcessingTotalCount:
		return m.OldDiagramProcessingTotalCount(ctx)
	case project.FieldDiagramCApprovalRatioNumerator:
		return m.OldDiagramCApprovalRatioNumerator(ctx)
	case project.FieldDiagramCApprovalRatioDenominator:
		return m.OldDiagramCApprovalRatioDenominator(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case project.FieldIsFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case project.FieldRevenueKpi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueKpi(v)
		return nil
	case project.FieldRevenueCurrentYearCompleted:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueCurrentYearCompleted(v)
		return nil
	case project.FieldRevenueAccumulatedCompleted:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueAccumulatedCompleted(v)
		return nil
	case project.FieldPayDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayDate(v)
		return nil
	case project.FieldOwnerVoCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerVoCount(v)
		return nil
	case project.FieldContractorVoCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractorVoCount(v)
		return nil
	case project.FieldAccumulateDeduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccumulateDeduction(v)
		return nil
	case project.FieldSubcontractorVaCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubcontractorVaCount(v)
		return nil
	case project.FieldContractSupplementaryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractSupplementaryCount(v)
		return nil
	case project.FieldRepairFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepairFee(v)
		return nil
	case project.FieldUnitInventoryTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitInventoryTotal(v)
		return nil
	case project.FieldUnitComponentTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitComponentTotal(v)
		return nil
	case project.FieldUnitComponentProduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitComponentProduction(v)
		return nil
	case project.FieldUnitComponentInstallation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitComponentInstallation(v)
		return nil
	case project.FieldBulkMaterialsTotalOrderQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulkMaterialsTotalOrderQuantity(v)
		return nil
	case project.FieldBulkMaterialsCompletedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulkMaterialsCompletedQuantity(v)
		return nil
	case project.FieldBulkMaterialsUncompletedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulkMaterialsUncompletedQuantity(v)
		return nil
	case project.FieldDiagramBdFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramBdFinishCount(v)
		return nil
	case project.FieldDiagramBdTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramBdTotalCount(v)
		return nil
	case project.FieldDiagramConstructionFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramConstructionFinishCount(v)
		return nil
	case project.FieldDiagramConstructionTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramConstructionTotalCount(v)
		return nil
	case project.FieldDiagramProcessingFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramProcessingFinishCount(v)
		return nil
	case project.FieldDiagramProcessingTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramProcessingTotalCount(v)
		return nil
	case project.FieldDiagramCApprovalRatioNumerator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramCApprovalRatioNumerator(v)
		return nil
	case project.FieldDiagramCApprovalRatioDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagramCApprovalRatioDenominator(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addrevenue_kpi != nil {
		fields = append(fields, project.FieldRevenueKpi)
	}
	if m.addrevenue_current_year_completed != nil {
		fields = append(fields, project.FieldRevenueCurrentYearCompleted)
	}
	if m.addrevenue_accumulated_completed != nil {
		fields = append(fields, project.FieldRevenueAccumulatedCompleted)
	}
	if m.addowner_vo_count != nil {
		fields = append(fields, project.FieldOwnerVoCount)
	}
	if m.addcontractor_vo_count != nil {
		fields = append(fields, project.FieldContractorVoCount)
	}
	if m.addaccumulate_deduction != nil {
		fields = append(fields, project.FieldAccumulateDeduction)
	}
	if m.addsubcontractor_va_count != nil {
		fields = append(fields, project.FieldSubcontractorVaCount)
	}
	if m.addcontract_supplementary_count != nil {
		fields = append(fields, project.FieldContractSupplementaryCount)
	}
	if m.addrepair_fee != nil {
		fields = append(fields, project.FieldRepairFee)
	}
	if m.addunit_inventory_total != nil {
		fields = append(fields, project.FieldUnitInventoryTotal)
	}
	if m.addunit_component_total != nil {
		fields = append(fields, project.FieldUnitComponentTotal)
	}
	if m.addunit_component_production != nil {
		fields = append(fields, project.FieldUnitComponentProduction)
	}
	if m.addunit_component_installation != nil {
		fields = append(fields, project.FieldUnitComponentInstallation)
	}
	if m.addbulk_materials_total_order_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsTotalOrderQuantity)
	}
	if m.addbulk_materials_completed_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsCompletedQuantity)
	}
	if m.addbulk_materials_uncompleted_quantity != nil {
		fields = append(fields, project.FieldBulkMaterialsUncompletedQuantity)
	}
	if m.adddiagram_bd_finish_count != nil {
		fields = append(fields, project.FieldDiagramBdFinishCount)
	}
	if m.adddiagram_bd_total_count != nil {
		fields = append(fields, project.FieldDiagramBdTotalCount)
	}
	if m.adddiagram_construction_finish_count != nil {
		fields = append(fields, project.FieldDiagramConstructionFinishCount)
	}
	if m.adddiagram_construction_total_count != nil {
		fields = append(fields, project.FieldDiagramConstructionTotalCount)
	}
	if m.adddiagram_processing_finish_count != nil {
		fields = append(fields, project.FieldDiagramProcessingFinishCount)
	}
	if m.adddiagram_processing_total_count != nil {
		fields = append(fields, project.FieldDiagramProcessingTotalCount)
	}
	if m.adddiagram_c_approval_ratio_numerator != nil {
		fields = append(fields, project.FieldDiagramCApprovalRatioNumerator)
	}
	if m.adddiagram_c_approval_ratio_denominator != nil {
		fields = append(fields, project.FieldDiagramCApprovalRatioDenominator)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldRevenueKpi:
		return m.AddedRevenueKpi()
	case project.FieldRevenueCurrentYearCompleted:
		return m.AddedRevenueCurrentYearCompleted()
	case project.FieldRevenueAccumulatedCompleted:
		return m.AddedRevenueAccumulatedCompleted()
	case project.FieldOwnerVoCount:
		return m.AddedOwnerVoCount()
	case project.FieldContractorVoCount:
		return m.AddedContractorVoCount()
	case project.FieldAccumulateDeduction:
		return m.AddedAccumulateDeduction()
	case project.FieldSubcontractorVaCount:
		return m.AddedSubcontractorVaCount()
	case project.FieldContractSupplementaryCount:
		return m.AddedContractSupplementaryCount()
	case project.FieldRepairFee:
		return m.AddedRepairFee()
	case project.FieldUnitInventoryTotal:
		return m.AddedUnitInventoryTotal()
	case project.FieldUnitComponentTotal:
		return m.AddedUnitComponentTotal()
	case project.FieldUnitComponentProduction:
		return m.AddedUnitComponentProduction()
	case project.FieldUnitComponentInstallation:
		return m.AddedUnitComponentInstallation()
	case project.FieldBulkMaterialsTotalOrderQuantity:
		return m.AddedBulkMaterialsTotalOrderQuantity()
	case project.FieldBulkMaterialsCompletedQuantity:
		return m.AddedBulkMaterialsCompletedQuantity()
	case project.FieldBulkMaterialsUncompletedQuantity:
		return m.AddedBulkMaterialsUncompletedQuantity()
	case project.FieldDiagramBdFinishCount:
		return m.AddedDiagramBdFinishCount()
	case project.FieldDiagramBdTotalCount:
		return m.AddedDiagramBdTotalCount()
	case project.FieldDiagramConstructionFinishCount:
		return m.AddedDiagramConstructionFinishCount()
	case project.FieldDiagramConstructionTotalCount:
		return m.AddedDiagramConstructionTotalCount()
	case project.FieldDiagramProcessingFinishCount:
		return m.AddedDiagramProcessingFinishCount()
	case project.FieldDiagramProcessingTotalCount:
		return m.AddedDiagramProcessingTotalCount()
	case project.FieldDiagramCApprovalRatioNumerator:
		return m.AddedDiagramCApprovalRatioNumerator()
	case project.FieldDiagramCApprovalRatioDenominator:
		return m.AddedDiagramCApprovalRatioDenominator()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldRevenueKpi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueKpi(v)
		return nil
	case project.FieldRevenueCurrentYearCompleted:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueCurrentYearCompleted(v)
		return nil
	case project.FieldRevenueAccumulatedCompleted:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueAccumulatedCompleted(v)
		return nil
	case project.FieldOwnerVoCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerVoCount(v)
		return nil
	case project.FieldContractorVoCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractorVoCount(v)
		return nil
	case project.FieldAccumulateDeduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccumulateDeduction(v)
		return nil
	case project.FieldSubcontractorVaCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubcontractorVaCount(v)
		return nil
	case project.FieldContractSupplementaryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractSupplementaryCount(v)
		return nil
	case project.FieldRepairFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRepairFee(v)
		return nil
	case project.FieldUnitInventoryTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitInventoryTotal(v)
		return nil
	case project.FieldUnitComponentTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitComponentTotal(v)
		return nil
	case project.FieldUnitComponentProduction:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitComponentProduction(v)
		return nil
	case project.FieldUnitComponentInstallation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitComponentInstallation(v)
		return nil
	case project.FieldBulkMaterialsTotalOrderQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBulkMaterialsTotalOrderQuantity(v)
		return nil
	case project.FieldBulkMaterialsCompletedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBulkMaterialsCompletedQuantity(v)
		return nil
	case project.FieldBulkMaterialsUncompletedQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBulkMaterialsUncompletedQuantity(v)
		return nil
	case project.FieldDiagramBdFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramBdFinishCount(v)
		return nil
	case project.FieldDiagramBdTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramBdTotalCount(v)
		return nil
	case project.FieldDiagramConstructionFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramConstructionFinishCount(v)
		return nil
	case project.FieldDiagramConstructionTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramConstructionTotalCount(v)
		return nil
	case project.FieldDiagramProcessingFinishCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramProcessingFinishCount(v)
		return nil
	case project.FieldDiagramProcessingTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramProcessingTotalCount(v)
		return nil
	case project.FieldDiagramCApprovalRatioNumerator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramCApprovalRatioNumerator(v)
		return nil
	case project.FieldDiagramCApprovalRatioDenominator:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiagramCApprovalRatioDenominator(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldRevenueKpi) {
		fields = append(fields, project.FieldRevenueKpi)
	}
	if m.FieldCleared(project.FieldRevenueCurrentYearCompleted) {
		fields = append(fields, project.FieldRevenueCurrentYearCompleted)
	}
	if m.FieldCleared(project.FieldRevenueAccumulatedCompleted) {
		fields = append(fields, project.FieldRevenueAccumulatedCompleted)
	}
	if m.FieldCleared(project.FieldPayDate) {
		fields = append(fields, project.FieldPayDate)
	}
	if m.FieldCleared(project.FieldOwnerVoCount) {
		fields = append(fields, project.FieldOwnerVoCount)
	}
	if m.FieldCleared(project.FieldContractorVoCount) {
		fields = append(fields, project.FieldContractorVoCount)
	}
	if m.FieldCleared(project.FieldAccumulateDeduction) {
		fields = append(fields, project.FieldAccumulateDeduction)
	}
	if m.FieldCleared(project.FieldSubcontractorVaCount) {
		fields = append(fields, project.FieldSubcontractorVaCount)
	}
	if m.FieldCleared(project.FieldContractSupplementaryCount) {
		fields = append(fields, project.FieldContractSupplementaryCount)
	}
	if m.FieldCleared(project.FieldRepairFee) {
		fields = append(fields, project.FieldRepairFee)
	}
	if m.FieldCleared(project.FieldUnitInventoryTotal) {
		fields = append(fields, project.FieldUnitInventoryTotal)
	}
	if m.FieldCleared(project.FieldUnitComponentTotal) {
		fields = append(fields, project.FieldUnitComponentTotal)
	}
	if m.FieldCleared(project.FieldUnitComponentProduction) {
		fields = append(fields, project.FieldUnitComponentProduction)
	}
	if m.FieldCleared(project.FieldUnitComponentInstallation) {
		fields = append(fields, project.FieldUnitComponentInstallation)
	}
	if m.FieldCleared(project.FieldBulkMaterialsTotalOrderQuantity) {
		fields = append(fields, project.FieldBulkMaterialsTotalOrderQuantity)
	}
	if m.FieldCleared(project.FieldBulkMaterialsCompletedQuantity) {
		fields = append(fields, project.FieldBulkMaterialsCompletedQuantity)
	}
	if m.FieldCleared(project.FieldBulkMaterialsUncompletedQuantity) {
		fields = append(fields, project.FieldBulkMaterialsUncompletedQuantity)
	}
	if m.FieldCleared(project.FieldDiagramBdFinishCount) {
		fields = append(fields, project.FieldDiagramBdFinishCount)
	}
	if m.FieldCleared(project.FieldDiagramBdTotalCount) {
		fields = append(fields, project.FieldDiagramBdTotalCount)
	}
	if m.FieldCleared(project.FieldDiagramConstructionFinishCount) {
		fields = append(fields, project.FieldDiagramConstructionFinishCount)
	}
	if m.FieldCleared(project.FieldDiagramConstructionTotalCount) {
		fields = append(fields, project.FieldDiagramConstructionTotalCount)
	}
	if m.FieldCleared(project.FieldDiagramProcessingFinishCount) {
		fields = append(fields, project.FieldDiagramProcessingFinishCount)
	}
	if m.FieldCleared(project.FieldDiagramProcessingTotalCount) {
		fields = append(fields, project.FieldDiagramProcessingTotalCount)
	}
	if m.FieldCleared(project.FieldDiagramCApprovalRatioNumerator) {
		fields = append(fields, project.FieldDiagramCApprovalRatioNumerator)
	}
	if m.FieldCleared(project.FieldDiagramCApprovalRatioDenominator) {
		fields = append(fields, project.FieldDiagramCApprovalRatioDenominator)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldRevenueKpi:
		m.ClearRevenueKpi()
		return nil
	case project.FieldRevenueCurrentYearCompleted:
		m.ClearRevenueCurrentYearCompleted()
		return nil
	case project.FieldRevenueAccumulatedCompleted:
		m.ClearRevenueAccumulatedCompleted()
		return nil
	case project.FieldPayDate:
		m.ClearPayDate()
		return nil
	case project.FieldOwnerVoCount:
		m.ClearOwnerVoCount()
		return nil
	case project.FieldContractorVoCount:
		m.ClearContractorVoCount()
		return nil
	case project.FieldAccumulateDeduction:
		m.ClearAccumulateDeduction()
		return nil
	case project.FieldSubcontractorVaCount:
		m.ClearSubcontractorVaCount()
		return nil
	case project.FieldContractSupplementaryCount:
		m.ClearContractSupplementaryCount()
		return nil
	case project.FieldRepairFee:
		m.ClearRepairFee()
		return nil
	case project.FieldUnitInventoryTotal:
		m.ClearUnitInventoryTotal()
		return nil
	case project.FieldUnitComponentTotal:
		m.ClearUnitComponentTotal()
		return nil
	case project.FieldUnitComponentProduction:
		m.ClearUnitComponentProduction()
		return nil
	case project.FieldUnitComponentInstallation:
		m.ClearUnitComponentInstallation()
		return nil
	case project.FieldBulkMaterialsTotalOrderQuantity:
		m.ClearBulkMaterialsTotalOrderQuantity()
		return nil
	case project.FieldBulkMaterialsCompletedQuantity:
		m.ClearBulkMaterialsCompletedQuantity()
		return nil
	case project.FieldBulkMaterialsUncompletedQuantity:
		m.ClearBulkMaterialsUncompletedQuantity()
		return nil
	case project.FieldDiagramBdFinishCount:
		m.ClearDiagramBdFinishCount()
		return nil
	case project.FieldDiagramBdTotalCount:
		m.ClearDiagramBdTotalCount()
		return nil
	case project.FieldDiagramConstructionFinishCount:
		m.ClearDiagramConstructionFinishCount()
		return nil
	case project.FieldDiagramConstructionTotalCount:
		m.ClearDiagramConstructionTotalCount()
		return nil
	case project.FieldDiagramProcessingFinishCount:
		m.ClearDiagramProcessingFinishCount()
		return nil
	case project.FieldDiagramProcessingTotalCount:
		m.ClearDiagramProcessingTotalCount()
		return nil
	case project.FieldDiagramCApprovalRatioNumerator:
		m.ClearDiagramCApprovalRatioNumerator()
		return nil
	case project.FieldDiagramCApprovalRatioDenominator:
		m.ClearDiagramCApprovalRatioDenominator()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldCode:
		m.ResetCode()
		return nil
	case project.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case project.FieldRevenueKpi:
		m.ResetRevenueKpi()
		return nil
	case project.FieldRevenueCurrentYearCompleted:
		m.ResetRevenueCurrentYearCompleted()
		return nil
	case project.FieldRevenueAccumulatedCompleted:
		m.ResetRevenueAccumulatedCompleted()
		return nil
	case project.FieldPayDate:
		m.ResetPayDate()
		return nil
	case project.FieldOwnerVoCount:
		m.ResetOwnerVoCount()
		return nil
	case project.FieldContractorVoCount:
		m.ResetContractorVoCount()
		return nil
	case project.FieldAccumulateDeduction:
		m.ResetAccumulateDeduction()
		return nil
	case project.FieldSubcontractorVaCount:
		m.ResetSubcontractorVaCount()
		return nil
	case project.FieldContractSupplementaryCount:
		m.ResetContractSupplementaryCount()
		return nil
	case project.FieldRepairFee:
		m.ResetRepairFee()
		return nil
	case project.FieldUnitInventoryTotal:
		m.ResetUnitInventoryTotal()
		return nil
	case project.FieldUnitComponentTotal:
		m.ResetUnitComponentTotal()
		return nil
	case project.FieldUnitComponentProduction:
		m.ResetUnitComponentProduction()
		return nil
	case project.FieldUnitComponentInstallation:
		m.ResetUnitComponentInstallation()
		return nil
	case project.FieldBulkMaterialsTotalOrderQuantity:
		m.ResetBulkMaterialsTotalOrderQuantity()
		return nil
	case project.FieldBulkMaterialsCompletedQuantity:
		m.ResetBulkMaterialsCompletedQuantity()
		return nil
	case project.FieldBulkMaterialsUncompletedQuantity:
		m.ResetBulkMaterialsUncompletedQuantity()
		return nil
	case project.FieldDiagramBdFinishCount:
		m.ResetDiagramBdFinishCount()
		return nil
	case project.FieldDiagramBdTotalCount:
		m.ResetDiagramBdTotalCount()
		return nil
	case project.FieldDiagramConstructionFinishCount:
		m.ResetDiagramConstructionFinishCount()
		return nil
	case project.FieldDiagramConstructionTotalCount:
		m.ResetDiagramConstructionTotalCount()
		return nil
	case project.FieldDiagramProcessingFinishCount:
		m.ResetDiagramProcessingFinishCount()
		return nil
	case project.FieldDiagramProcessingTotalCount:
		m.ResetDiagramProcessingTotalCount()
		return nil
	case project.FieldDiagramCApprovalRatioNumerator:
		m.ResetDiagramCApprovalRatioNumerator()
		return nil
	case project.FieldDiagramCApprovalRatioDenominator:
		m.ResetDiagramCApprovalRatioDenominator()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, project.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, project.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, project.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProvinceMutation represents an operation that mutates the Province nodes in the graph.
type ProvinceMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	created_at       *time.Time
	updated_at       *time.Time
	adcode           *int
	addadcode        *int
	name             *string
	center           **geo.GeoJson
	clearedFields    map[string]struct{}
	districts        map[xid.ID]struct{}
	removeddistricts map[xid.ID]struct{}
	cleareddistricts bool
	cities           map[xid.ID]struct{}
	removedcities    map[xid.ID]struct{}
	clearedcities    bool
	country          *xid.ID
	clearedcountry   bool
	tenders          map[xid.ID]struct{}
	removedtenders   map[xid.ID]struct{}
	clearedtenders   bool
	area             *xid.ID
	clearedarea      bool
	done             bool
	oldValue         func(context.Context) (*Province, error)
	predicates       []predicate.Province
}

var _ ent.Mutation = (*ProvinceMutation)(nil)

// provinceOption allows management of the mutation configuration using functional options.
type provinceOption func(*ProvinceMutation)

// newProvinceMutation creates new mutation for the Province entity.
func newProvinceMutation(c config, op Op, opts ...provinceOption) *ProvinceMutation {
	m := &ProvinceMutation{
		config:        c,
		op:            op,
		typ:           TypeProvince,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvinceID sets the ID field of the mutation.
func withProvinceID(id xid.ID) provinceOption {
	return func(m *ProvinceMutation) {
		var (
			err   error
			once  sync.Once
			value *Province
		)
		m.oldValue = func(ctx context.Context) (*Province, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Province.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvince sets the old Province of the mutation.
func withProvince(node *Province) provinceOption {
	return func(m *ProvinceMutation) {
		m.oldValue = func(context.Context) (*Province, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvinceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvinceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Province entities.
func (m *ProvinceMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvinceMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvinceMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Province.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProvinceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProvinceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProvinceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProvinceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProvinceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProvinceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdcode sets the "adcode" field.
func (m *ProvinceMutation) SetAdcode(i int) {
	m.adcode = &i
	m.addadcode = nil
}

// Adcode returns the value of the "adcode" field in the mutation.
func (m *ProvinceMutation) Adcode() (r int, exists bool) {
	v := m.adcode
	if v == nil {
		return
	}
	return *v, true
}

// OldAdcode returns the old "adcode" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldAdcode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdcode: %w", err)
	}
	return oldValue.Adcode, nil
}

// AddAdcode adds i to the "adcode" field.
func (m *ProvinceMutation) AddAdcode(i int) {
	if m.addadcode != nil {
		*m.addadcode += i
	} else {
		m.addadcode = &i
	}
}

// AddedAdcode returns the value that was added to the "adcode" field in this mutation.
func (m *ProvinceMutation) AddedAdcode() (r int, exists bool) {
	v := m.addadcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdcode resets all changes to the "adcode" field.
func (m *ProvinceMutation) ResetAdcode() {
	m.adcode = nil
	m.addadcode = nil
}

// SetName sets the "name" field.
func (m *ProvinceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvinceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvinceMutation) ResetName() {
	m.name = nil
}

// SetCenter sets the "center" field.
func (m *ProvinceMutation) SetCenter(gj *geo.GeoJson) {
	m.center = &gj
}

// Center returns the value of the "center" field in the mutation.
func (m *ProvinceMutation) Center() (r *geo.GeoJson, exists bool) {
	v := m.center
	if v == nil {
		return
	}
	return *v, true
}

// OldCenter returns the old "center" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCenter(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCenter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCenter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCenter: %w", err)
	}
	return oldValue.Center, nil
}

// ResetCenter resets all changes to the "center" field.
func (m *ProvinceMutation) ResetCenter() {
	m.center = nil
}

// SetCountryID sets the "country_id" field.
func (m *ProvinceMutation) SetCountryID(x xid.ID) {
	m.country = &x
}

// CountryID returns the value of the "country_id" field in the mutation.
func (m *ProvinceMutation) CountryID() (r xid.ID, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryID returns the old "country_id" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldCountryID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryID: %w", err)
	}
	return oldValue.CountryID, nil
}

// ResetCountryID resets all changes to the "country_id" field.
func (m *ProvinceMutation) ResetCountryID() {
	m.country = nil
}

// SetAreaID sets the "area_id" field.
func (m *ProvinceMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *ProvinceMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Province entity.
// If the Province object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvinceMutation) OldAreaID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ClearAreaID clears the value of the "area_id" field.
func (m *ProvinceMutation) ClearAreaID() {
	m.area = nil
	m.clearedFields[province.FieldAreaID] = struct{}{}
}

// AreaIDCleared returns if the "area_id" field was cleared in this mutation.
func (m *ProvinceMutation) AreaIDCleared() bool {
	_, ok := m.clearedFields[province.FieldAreaID]
	return ok
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *ProvinceMutation) ResetAreaID() {
	m.area = nil
	delete(m.clearedFields, province.FieldAreaID)
}

// AddDistrictIDs adds the "districts" edge to the District entity by ids.
func (m *ProvinceMutation) AddDistrictIDs(ids ...xid.ID) {
	if m.districts == nil {
		m.districts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.districts[ids[i]] = struct{}{}
	}
}

// ClearDistricts clears the "districts" edge to the District entity.
func (m *ProvinceMutation) ClearDistricts() {
	m.cleareddistricts = true
}

// DistrictsCleared reports if the "districts" edge to the District entity was cleared.
func (m *ProvinceMutation) DistrictsCleared() bool {
	return m.cleareddistricts
}

// RemoveDistrictIDs removes the "districts" edge to the District entity by IDs.
func (m *ProvinceMutation) RemoveDistrictIDs(ids ...xid.ID) {
	if m.removeddistricts == nil {
		m.removeddistricts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.districts, ids[i])
		m.removeddistricts[ids[i]] = struct{}{}
	}
}

// RemovedDistricts returns the removed IDs of the "districts" edge to the District entity.
func (m *ProvinceMutation) RemovedDistrictsIDs() (ids []xid.ID) {
	for id := range m.removeddistricts {
		ids = append(ids, id)
	}
	return
}

// DistrictsIDs returns the "districts" edge IDs in the mutation.
func (m *ProvinceMutation) DistrictsIDs() (ids []xid.ID) {
	for id := range m.districts {
		ids = append(ids, id)
	}
	return
}

// ResetDistricts resets all changes to the "districts" edge.
func (m *ProvinceMutation) ResetDistricts() {
	m.districts = nil
	m.cleareddistricts = false
	m.removeddistricts = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *ProvinceMutation) AddCityIDs(ids ...xid.ID) {
	if m.cities == nil {
		m.cities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *ProvinceMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *ProvinceMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *ProvinceMutation) RemoveCityIDs(ids ...xid.ID) {
	if m.removedcities == nil {
		m.removedcities = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *ProvinceMutation) RemovedCitiesIDs() (ids []xid.ID) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *ProvinceMutation) CitiesIDs() (ids []xid.ID) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *ProvinceMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ProvinceMutation) ClearCountry() {
	m.clearedcountry = true
	m.clearedFields[province.FieldCountryID] = struct{}{}
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ProvinceMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) CountryIDs() (ids []xid.ID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ProvinceMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *ProvinceMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *ProvinceMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *ProvinceMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *ProvinceMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *ProvinceMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *ProvinceMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *ProvinceMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// ClearArea clears the "area" edge to the Area entity.
func (m *ProvinceMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[province.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *ProvinceMutation) AreaCleared() bool {
	return m.AreaIDCleared() || m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *ProvinceMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *ProvinceMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// Where appends a list predicates to the ProvinceMutation builder.
func (m *ProvinceMutation) Where(ps ...predicate.Province) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvinceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvinceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Province, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvinceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvinceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Province).
func (m *ProvinceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvinceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, province.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, province.FieldUpdatedAt)
	}
	if m.adcode != nil {
		fields = append(fields, province.FieldAdcode)
	}
	if m.name != nil {
		fields = append(fields, province.FieldName)
	}
	if m.center != nil {
		fields = append(fields, province.FieldCenter)
	}
	if m.country != nil {
		fields = append(fields, province.FieldCountryID)
	}
	if m.area != nil {
		fields = append(fields, province.FieldAreaID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvinceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case province.FieldCreatedAt:
		return m.CreatedAt()
	case province.FieldUpdatedAt:
		return m.UpdatedAt()
	case province.FieldAdcode:
		return m.Adcode()
	case province.FieldName:
		return m.Name()
	case province.FieldCenter:
		return m.Center()
	case province.FieldCountryID:
		return m.CountryID()
	case province.FieldAreaID:
		return m.AreaID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvinceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case province.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case province.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case province.FieldAdcode:
		return m.OldAdcode(ctx)
	case province.FieldName:
		return m.OldName(ctx)
	case province.FieldCenter:
		return m.OldCenter(ctx)
	case province.FieldCountryID:
		return m.OldCountryID(ctx)
	case province.FieldAreaID:
		return m.OldAreaID(ctx)
	}
	return nil, fmt.Errorf("unknown Province field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case province.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case province.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case province.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdcode(v)
		return nil
	case province.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case province.FieldCenter:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCenter(v)
		return nil
	case province.FieldCountryID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryID(v)
		return nil
	case province.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvinceMutation) AddedFields() []string {
	var fields []string
	if m.addadcode != nil {
		fields = append(fields, province.FieldAdcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvinceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case province.FieldAdcode:
		return m.AddedAdcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvinceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case province.FieldAdcode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdcode(v)
		return nil
	}
	return fmt.Errorf("unknown Province numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvinceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(province.FieldAreaID) {
		fields = append(fields, province.FieldAreaID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvinceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvinceMutation) ClearField(name string) error {
	switch name {
	case province.FieldAreaID:
		m.ClearAreaID()
		return nil
	}
	return fmt.Errorf("unknown Province nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvinceMutation) ResetField(name string) error {
	switch name {
	case province.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case province.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case province.FieldAdcode:
		m.ResetAdcode()
		return nil
	case province.FieldName:
		m.ResetName()
		return nil
	case province.FieldCenter:
		m.ResetCenter()
		return nil
	case province.FieldCountryID:
		m.ResetCountryID()
		return nil
	case province.FieldAreaID:
		m.ResetAreaID()
		return nil
	}
	return fmt.Errorf("unknown Province field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvinceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.districts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.cities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.country != nil {
		edges = append(edges, province.EdgeCountry)
	}
	if m.tenders != nil {
		edges = append(edges, province.EdgeTenders)
	}
	if m.area != nil {
		edges = append(edges, province.EdgeArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvinceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.districts))
		for id := range m.districts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case province.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvinceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddistricts != nil {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.removedcities != nil {
		edges = append(edges, province.EdgeCities)
	}
	if m.removedtenders != nil {
		edges = append(edges, province.EdgeTenders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvinceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case province.EdgeDistricts:
		ids := make([]ent.Value, 0, len(m.removeddistricts))
		for id := range m.removeddistricts {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case province.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvinceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareddistricts {
		edges = append(edges, province.EdgeDistricts)
	}
	if m.clearedcities {
		edges = append(edges, province.EdgeCities)
	}
	if m.clearedcountry {
		edges = append(edges, province.EdgeCountry)
	}
	if m.clearedtenders {
		edges = append(edges, province.EdgeTenders)
	}
	if m.clearedarea {
		edges = append(edges, province.EdgeArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvinceMutation) EdgeCleared(name string) bool {
	switch name {
	case province.EdgeDistricts:
		return m.cleareddistricts
	case province.EdgeCities:
		return m.clearedcities
	case province.EdgeCountry:
		return m.clearedcountry
	case province.EdgeTenders:
		return m.clearedtenders
	case province.EdgeArea:
		return m.clearedarea
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvinceMutation) ClearEdge(name string) error {
	switch name {
	case province.EdgeCountry:
		m.ClearCountry()
		return nil
	case province.EdgeArea:
		m.ClearArea()
		return nil
	}
	return fmt.Errorf("unknown Province unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvinceMutation) ResetEdge(name string) error {
	switch name {
	case province.EdgeDistricts:
		m.ResetDistricts()
		return nil
	case province.EdgeCities:
		m.ResetCities()
		return nil
	case province.EdgeCountry:
		m.ResetCountry()
		return nil
	case province.EdgeTenders:
		m.ResetTenders()
		return nil
	case province.EdgeArea:
		m.ResetArea()
		return nil
	}
	return fmt.Errorf("unknown Province edge %s", name)
}

// TenderMutation represents an operation that mutates the Tender nodes in the graph.
type TenderMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *xid.ID
	created_at                              *time.Time
	updated_at                              *time.Time
	code                                    *string
	status                                  *int
	addstatus                               *int
	approval_status                         *int
	addapproval_status                      *int
	approval_msg_id                         *string
	name                                    *string
	estimated_amount                        *float64
	addestimated_amount                     *float64
	tender_date                             *time.Time
	classify                                *int
	addclassify                             *int
	discovery_date                          *time.Time
	address                                 *string
	full_address                            *string
	contractor                              *string
	level_involved                          *int
	addlevel_involved                       *int
	size_and_value_rating                   *int
	addsize_and_value_rating                *int
	size_and_value_rating_overview          *string
	credit_and_payment_rating               *int
	addcredit_and_payment_rating            *int
	credit_and_payment_rating_overview      *string
	time_limit_rating                       *int
	addtime_limit_rating                    *int
	time_limit_rating_overview              *string
	customer_relationship_rating            *int
	addcustomer_relationship_rating         *int
	customer_relationship_rating_overview   *string
	competitive_partnership_rating          *int
	addcompetitive_partnership_rating       *int
	competitive_partnership_rating_overview *string
	prepare_to_bid                          *bool
	project_code                            *string
	project_type                            *string
	project_definition                      *string
	estimated_project_start_date            *time.Time
	estimated_project_end_date              *time.Time
	attachements                            *[]string
	appendattachements                      []string
	geo_coordinate                          **geo.GeoJson
	geo_bounds                              *[][]float64
	appendgeo_bounds                        [][]float64
	remark                                  *string
	images                                  *[]string
	appendimages                            []string
	tender_situations                       *string
	owner_situations                        *string
	bidding_instructions                    *string
	competitor_situations                   *string
	cost_engineer                           *string
	tender_form                             *string
	contract_form                           *string
	management_company                      *string
	tendering_agency                        *string
	bidding_date                            *time.Time
	facade_consultant                       *string
	design_unit                             *string
	consulting_firm                         *string
	key_project                             *bool
	current_progress                        *string
	tender_win_company                      *string
	tender_code                             *string
	architect                               *string
	developer                               *string
	tender_closing_date                     *time.Time
	construction_area                       *string
	tender_win_date                         *time.Time
	tender_win_amount                       *float64
	addtender_win_amount                    *float64
	last_tender_amount                      *float64
	addlast_tender_amount                   *float64
	clearedFields                           map[string]struct{}
	area                                    *xid.ID
	clearedarea                             bool
	profiles                                map[xid.ID]struct{}
	removedprofiles                         map[xid.ID]struct{}
	clearedprofiles                         bool
	competitors                             map[xid.ID]struct{}
	removedcompetitors                      map[xid.ID]struct{}
	clearedcompetitors                      bool
	customer                                *xid.ID
	clearedcustomer                         bool
	finder                                  *xid.ID
	clearedfinder                           bool
	created_by                              *xid.ID
	clearedcreated_by                       bool
	following_sales                         map[xid.ID]struct{}
	removedfollowing_sales                  map[xid.ID]struct{}
	clearedfollowing_sales                  bool
	province                                *xid.ID
	clearedprovince                         bool
	city                                    *xid.ID
	clearedcity                             bool
	district                                *xid.ID
	cleareddistrict                         bool
	visit_records                           map[xid.ID]struct{}
	removedvisit_records                    map[xid.ID]struct{}
	clearedvisit_records                    bool
	approver                                *xid.ID
	clearedapprover                         bool
	active_profile                          *xid.ID
	clearedactive_profile                   bool
	pending_profile                         *xid.ID
	clearedpending_profile                  bool
	done                                    bool
	oldValue                                func(context.Context) (*Tender, error)
	predicates                              []predicate.Tender
}

var _ ent.Mutation = (*TenderMutation)(nil)

// tenderOption allows management of the mutation configuration using functional options.
type tenderOption func(*TenderMutation)

// newTenderMutation creates new mutation for the Tender entity.
func newTenderMutation(c config, op Op, opts ...tenderOption) *TenderMutation {
	m := &TenderMutation{
		config:        c,
		op:            op,
		typ:           TypeTender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenderID sets the ID field of the mutation.
func withTenderID(id xid.ID) tenderOption {
	return func(m *TenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Tender
		)
		m.oldValue = func(ctx context.Context) (*Tender, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTender sets the old Tender of the mutation.
func withTender(node *Tender) tenderOption {
	return func(m *TenderMutation) {
		m.oldValue = func(context.Context) (*Tender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tender entities.
func (m *TenderMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenderMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenderMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tender.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *TenderMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TenderMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TenderMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *TenderMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TenderMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TenderMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TenderMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TenderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetApprovalStatus sets the "approval_status" field.
func (m *TenderMutation) SetApprovalStatus(i int) {
	m.approval_status = &i
	m.addapproval_status = nil
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *TenderMutation) ApprovalStatus() (r int, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldApprovalStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// AddApprovalStatus adds i to the "approval_status" field.
func (m *TenderMutation) AddApprovalStatus(i int) {
	if m.addapproval_status != nil {
		*m.addapproval_status += i
	} else {
		m.addapproval_status = &i
	}
}

// AddedApprovalStatus returns the value that was added to the "approval_status" field in this mutation.
func (m *TenderMutation) AddedApprovalStatus() (r int, exists bool) {
	v := m.addapproval_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *TenderMutation) ResetApprovalStatus() {
	m.approval_status = nil
	m.addapproval_status = nil
}

// SetApprovalMsgID sets the "approval_msg_id" field.
func (m *TenderMutation) SetApprovalMsgID(s string) {
	m.approval_msg_id = &s
}

// ApprovalMsgID returns the value of the "approval_msg_id" field in the mutation.
func (m *TenderMutation) ApprovalMsgID() (r string, exists bool) {
	v := m.approval_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalMsgID returns the old "approval_msg_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldApprovalMsgID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalMsgID: %w", err)
	}
	return oldValue.ApprovalMsgID, nil
}

// ClearApprovalMsgID clears the value of the "approval_msg_id" field.
func (m *TenderMutation) ClearApprovalMsgID() {
	m.approval_msg_id = nil
	m.clearedFields[tender.FieldApprovalMsgID] = struct{}{}
}

// ApprovalMsgIDCleared returns if the "approval_msg_id" field was cleared in this mutation.
func (m *TenderMutation) ApprovalMsgIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldApprovalMsgID]
	return ok
}

// ResetApprovalMsgID resets all changes to the "approval_msg_id" field.
func (m *TenderMutation) ResetApprovalMsgID() {
	m.approval_msg_id = nil
	delete(m.clearedFields, tender.FieldApprovalMsgID)
}

// SetName sets the "name" field.
func (m *TenderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenderMutation) ResetName() {
	m.name = nil
}

// SetEstimatedAmount sets the "estimated_amount" field.
func (m *TenderMutation) SetEstimatedAmount(f float64) {
	m.estimated_amount = &f
	m.addestimated_amount = nil
}

// EstimatedAmount returns the value of the "estimated_amount" field in the mutation.
func (m *TenderMutation) EstimatedAmount() (r float64, exists bool) {
	v := m.estimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedAmount returns the old "estimated_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedAmount: %w", err)
	}
	return oldValue.EstimatedAmount, nil
}

// AddEstimatedAmount adds f to the "estimated_amount" field.
func (m *TenderMutation) AddEstimatedAmount(f float64) {
	if m.addestimated_amount != nil {
		*m.addestimated_amount += f
	} else {
		m.addestimated_amount = &f
	}
}

// AddedEstimatedAmount returns the value that was added to the "estimated_amount" field in this mutation.
func (m *TenderMutation) AddedEstimatedAmount() (r float64, exists bool) {
	v := m.addestimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedAmount clears the value of the "estimated_amount" field.
func (m *TenderMutation) ClearEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	m.clearedFields[tender.FieldEstimatedAmount] = struct{}{}
}

// EstimatedAmountCleared returns if the "estimated_amount" field was cleared in this mutation.
func (m *TenderMutation) EstimatedAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedAmount]
	return ok
}

// ResetEstimatedAmount resets all changes to the "estimated_amount" field.
func (m *TenderMutation) ResetEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	delete(m.clearedFields, tender.FieldEstimatedAmount)
}

// SetTenderDate sets the "tender_date" field.
func (m *TenderMutation) SetTenderDate(t time.Time) {
	m.tender_date = &t
}

// TenderDate returns the value of the "tender_date" field in the mutation.
func (m *TenderMutation) TenderDate() (r time.Time, exists bool) {
	v := m.tender_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderDate returns the old "tender_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderDate: %w", err)
	}
	return oldValue.TenderDate, nil
}

// ClearTenderDate clears the value of the "tender_date" field.
func (m *TenderMutation) ClearTenderDate() {
	m.tender_date = nil
	m.clearedFields[tender.FieldTenderDate] = struct{}{}
}

// TenderDateCleared returns if the "tender_date" field was cleared in this mutation.
func (m *TenderMutation) TenderDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderDate]
	return ok
}

// ResetTenderDate resets all changes to the "tender_date" field.
func (m *TenderMutation) ResetTenderDate() {
	m.tender_date = nil
	delete(m.clearedFields, tender.FieldTenderDate)
}

// SetClassify sets the "classify" field.
func (m *TenderMutation) SetClassify(i int) {
	m.classify = &i
	m.addclassify = nil
}

// Classify returns the value of the "classify" field in the mutation.
func (m *TenderMutation) Classify() (r int, exists bool) {
	v := m.classify
	if v == nil {
		return
	}
	return *v, true
}

// OldClassify returns the old "classify" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldClassify(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassify: %w", err)
	}
	return oldValue.Classify, nil
}

// AddClassify adds i to the "classify" field.
func (m *TenderMutation) AddClassify(i int) {
	if m.addclassify != nil {
		*m.addclassify += i
	} else {
		m.addclassify = &i
	}
}

// AddedClassify returns the value that was added to the "classify" field in this mutation.
func (m *TenderMutation) AddedClassify() (r int, exists bool) {
	v := m.addclassify
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassify clears the value of the "classify" field.
func (m *TenderMutation) ClearClassify() {
	m.classify = nil
	m.addclassify = nil
	m.clearedFields[tender.FieldClassify] = struct{}{}
}

// ClassifyCleared returns if the "classify" field was cleared in this mutation.
func (m *TenderMutation) ClassifyCleared() bool {
	_, ok := m.clearedFields[tender.FieldClassify]
	return ok
}

// ResetClassify resets all changes to the "classify" field.
func (m *TenderMutation) ResetClassify() {
	m.classify = nil
	m.addclassify = nil
	delete(m.clearedFields, tender.FieldClassify)
}

// SetDiscoveryDate sets the "discovery_date" field.
func (m *TenderMutation) SetDiscoveryDate(t time.Time) {
	m.discovery_date = &t
}

// DiscoveryDate returns the value of the "discovery_date" field in the mutation.
func (m *TenderMutation) DiscoveryDate() (r time.Time, exists bool) {
	v := m.discovery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryDate returns the old "discovery_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDiscoveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryDate: %w", err)
	}
	return oldValue.DiscoveryDate, nil
}

// ResetDiscoveryDate resets all changes to the "discovery_date" field.
func (m *TenderMutation) ResetDiscoveryDate() {
	m.discovery_date = nil
}

// SetAddress sets the "address" field.
func (m *TenderMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TenderMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *TenderMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[tender.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *TenderMutation) AddressCleared() bool {
	_, ok := m.clearedFields[tender.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *TenderMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, tender.FieldAddress)
}

// SetFullAddress sets the "full_address" field.
func (m *TenderMutation) SetFullAddress(s string) {
	m.full_address = &s
}

// FullAddress returns the value of the "full_address" field in the mutation.
func (m *TenderMutation) FullAddress() (r string, exists bool) {
	v := m.full_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFullAddress returns the old "full_address" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFullAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullAddress: %w", err)
	}
	return oldValue.FullAddress, nil
}

// ClearFullAddress clears the value of the "full_address" field.
func (m *TenderMutation) ClearFullAddress() {
	m.full_address = nil
	m.clearedFields[tender.FieldFullAddress] = struct{}{}
}

// FullAddressCleared returns if the "full_address" field was cleared in this mutation.
func (m *TenderMutation) FullAddressCleared() bool {
	_, ok := m.clearedFields[tender.FieldFullAddress]
	return ok
}

// ResetFullAddress resets all changes to the "full_address" field.
func (m *TenderMutation) ResetFullAddress() {
	m.full_address = nil
	delete(m.clearedFields, tender.FieldFullAddress)
}

// SetContractor sets the "contractor" field.
func (m *TenderMutation) SetContractor(s string) {
	m.contractor = &s
}

// Contractor returns the value of the "contractor" field in the mutation.
func (m *TenderMutation) Contractor() (r string, exists bool) {
	v := m.contractor
	if v == nil {
		return
	}
	return *v, true
}

// OldContractor returns the old "contractor" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldContractor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractor: %w", err)
	}
	return oldValue.Contractor, nil
}

// ClearContractor clears the value of the "contractor" field.
func (m *TenderMutation) ClearContractor() {
	m.contractor = nil
	m.clearedFields[tender.FieldContractor] = struct{}{}
}

// ContractorCleared returns if the "contractor" field was cleared in this mutation.
func (m *TenderMutation) ContractorCleared() bool {
	_, ok := m.clearedFields[tender.FieldContractor]
	return ok
}

// ResetContractor resets all changes to the "contractor" field.
func (m *TenderMutation) ResetContractor() {
	m.contractor = nil
	delete(m.clearedFields, tender.FieldContractor)
}

// SetLevelInvolved sets the "level_involved" field.
func (m *TenderMutation) SetLevelInvolved(i int) {
	m.level_involved = &i
	m.addlevel_involved = nil
}

// LevelInvolved returns the value of the "level_involved" field in the mutation.
func (m *TenderMutation) LevelInvolved() (r int, exists bool) {
	v := m.level_involved
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelInvolved returns the old "level_involved" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldLevelInvolved(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelInvolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelInvolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelInvolved: %w", err)
	}
	return oldValue.LevelInvolved, nil
}

// AddLevelInvolved adds i to the "level_involved" field.
func (m *TenderMutation) AddLevelInvolved(i int) {
	if m.addlevel_involved != nil {
		*m.addlevel_involved += i
	} else {
		m.addlevel_involved = &i
	}
}

// AddedLevelInvolved returns the value that was added to the "level_involved" field in this mutation.
func (m *TenderMutation) AddedLevelInvolved() (r int, exists bool) {
	v := m.addlevel_involved
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevelInvolved clears the value of the "level_involved" field.
func (m *TenderMutation) ClearLevelInvolved() {
	m.level_involved = nil
	m.addlevel_involved = nil
	m.clearedFields[tender.FieldLevelInvolved] = struct{}{}
}

// LevelInvolvedCleared returns if the "level_involved" field was cleared in this mutation.
func (m *TenderMutation) LevelInvolvedCleared() bool {
	_, ok := m.clearedFields[tender.FieldLevelInvolved]
	return ok
}

// ResetLevelInvolved resets all changes to the "level_involved" field.
func (m *TenderMutation) ResetLevelInvolved() {
	m.level_involved = nil
	m.addlevel_involved = nil
	delete(m.clearedFields, tender.FieldLevelInvolved)
}

// SetSizeAndValueRating sets the "size_and_value_rating" field.
func (m *TenderMutation) SetSizeAndValueRating(i int) {
	m.size_and_value_rating = &i
	m.addsize_and_value_rating = nil
}

// SizeAndValueRating returns the value of the "size_and_value_rating" field in the mutation.
func (m *TenderMutation) SizeAndValueRating() (r int, exists bool) {
	v := m.size_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRating returns the old "size_and_value_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldSizeAndValueRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRating: %w", err)
	}
	return oldValue.SizeAndValueRating, nil
}

// AddSizeAndValueRating adds i to the "size_and_value_rating" field.
func (m *TenderMutation) AddSizeAndValueRating(i int) {
	if m.addsize_and_value_rating != nil {
		*m.addsize_and_value_rating += i
	} else {
		m.addsize_and_value_rating = &i
	}
}

// AddedSizeAndValueRating returns the value that was added to the "size_and_value_rating" field in this mutation.
func (m *TenderMutation) AddedSizeAndValueRating() (r int, exists bool) {
	v := m.addsize_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeAndValueRating clears the value of the "size_and_value_rating" field.
func (m *TenderMutation) ClearSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	m.clearedFields[tender.FieldSizeAndValueRating] = struct{}{}
}

// SizeAndValueRatingCleared returns if the "size_and_value_rating" field was cleared in this mutation.
func (m *TenderMutation) SizeAndValueRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldSizeAndValueRating]
	return ok
}

// ResetSizeAndValueRating resets all changes to the "size_and_value_rating" field.
func (m *TenderMutation) ResetSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	delete(m.clearedFields, tender.FieldSizeAndValueRating)
}

// SetSizeAndValueRatingOverview sets the "size_and_value_rating_overview" field.
func (m *TenderMutation) SetSizeAndValueRatingOverview(s string) {
	m.size_and_value_rating_overview = &s
}

// SizeAndValueRatingOverview returns the value of the "size_and_value_rating_overview" field in the mutation.
func (m *TenderMutation) SizeAndValueRatingOverview() (r string, exists bool) {
	v := m.size_and_value_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRatingOverview returns the old "size_and_value_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldSizeAndValueRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRatingOverview: %w", err)
	}
	return oldValue.SizeAndValueRatingOverview, nil
}

// ClearSizeAndValueRatingOverview clears the value of the "size_and_value_rating_overview" field.
func (m *TenderMutation) ClearSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	m.clearedFields[tender.FieldSizeAndValueRatingOverview] = struct{}{}
}

// SizeAndValueRatingOverviewCleared returns if the "size_and_value_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) SizeAndValueRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldSizeAndValueRatingOverview]
	return ok
}

// ResetSizeAndValueRatingOverview resets all changes to the "size_and_value_rating_overview" field.
func (m *TenderMutation) ResetSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	delete(m.clearedFields, tender.FieldSizeAndValueRatingOverview)
}

// SetCreditAndPaymentRating sets the "credit_and_payment_rating" field.
func (m *TenderMutation) SetCreditAndPaymentRating(i int) {
	m.credit_and_payment_rating = &i
	m.addcredit_and_payment_rating = nil
}

// CreditAndPaymentRating returns the value of the "credit_and_payment_rating" field in the mutation.
func (m *TenderMutation) CreditAndPaymentRating() (r int, exists bool) {
	v := m.credit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRating returns the old "credit_and_payment_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreditAndPaymentRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRating: %w", err)
	}
	return oldValue.CreditAndPaymentRating, nil
}

// AddCreditAndPaymentRating adds i to the "credit_and_payment_rating" field.
func (m *TenderMutation) AddCreditAndPaymentRating(i int) {
	if m.addcredit_and_payment_rating != nil {
		*m.addcredit_and_payment_rating += i
	} else {
		m.addcredit_and_payment_rating = &i
	}
}

// AddedCreditAndPaymentRating returns the value that was added to the "credit_and_payment_rating" field in this mutation.
func (m *TenderMutation) AddedCreditAndPaymentRating() (r int, exists bool) {
	v := m.addcredit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditAndPaymentRating clears the value of the "credit_and_payment_rating" field.
func (m *TenderMutation) ClearCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	m.clearedFields[tender.FieldCreditAndPaymentRating] = struct{}{}
}

// CreditAndPaymentRatingCleared returns if the "credit_and_payment_rating" field was cleared in this mutation.
func (m *TenderMutation) CreditAndPaymentRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCreditAndPaymentRating]
	return ok
}

// ResetCreditAndPaymentRating resets all changes to the "credit_and_payment_rating" field.
func (m *TenderMutation) ResetCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	delete(m.clearedFields, tender.FieldCreditAndPaymentRating)
}

// SetCreditAndPaymentRatingOverview sets the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) SetCreditAndPaymentRatingOverview(s string) {
	m.credit_and_payment_rating_overview = &s
}

// CreditAndPaymentRatingOverview returns the value of the "credit_and_payment_rating_overview" field in the mutation.
func (m *TenderMutation) CreditAndPaymentRatingOverview() (r string, exists bool) {
	v := m.credit_and_payment_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRatingOverview returns the old "credit_and_payment_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreditAndPaymentRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRatingOverview: %w", err)
	}
	return oldValue.CreditAndPaymentRatingOverview, nil
}

// ClearCreditAndPaymentRatingOverview clears the value of the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) ClearCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	m.clearedFields[tender.FieldCreditAndPaymentRatingOverview] = struct{}{}
}

// CreditAndPaymentRatingOverviewCleared returns if the "credit_and_payment_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CreditAndPaymentRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCreditAndPaymentRatingOverview]
	return ok
}

// ResetCreditAndPaymentRatingOverview resets all changes to the "credit_and_payment_rating_overview" field.
func (m *TenderMutation) ResetCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	delete(m.clearedFields, tender.FieldCreditAndPaymentRatingOverview)
}

// SetTimeLimitRating sets the "time_limit_rating" field.
func (m *TenderMutation) SetTimeLimitRating(i int) {
	m.time_limit_rating = &i
	m.addtime_limit_rating = nil
}

// TimeLimitRating returns the value of the "time_limit_rating" field in the mutation.
func (m *TenderMutation) TimeLimitRating() (r int, exists bool) {
	v := m.time_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRating returns the old "time_limit_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTimeLimitRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRating: %w", err)
	}
	return oldValue.TimeLimitRating, nil
}

// AddTimeLimitRating adds i to the "time_limit_rating" field.
func (m *TenderMutation) AddTimeLimitRating(i int) {
	if m.addtime_limit_rating != nil {
		*m.addtime_limit_rating += i
	} else {
		m.addtime_limit_rating = &i
	}
}

// AddedTimeLimitRating returns the value that was added to the "time_limit_rating" field in this mutation.
func (m *TenderMutation) AddedTimeLimitRating() (r int, exists bool) {
	v := m.addtime_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeLimitRating clears the value of the "time_limit_rating" field.
func (m *TenderMutation) ClearTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	m.clearedFields[tender.FieldTimeLimitRating] = struct{}{}
}

// TimeLimitRatingCleared returns if the "time_limit_rating" field was cleared in this mutation.
func (m *TenderMutation) TimeLimitRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldTimeLimitRating]
	return ok
}

// ResetTimeLimitRating resets all changes to the "time_limit_rating" field.
func (m *TenderMutation) ResetTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	delete(m.clearedFields, tender.FieldTimeLimitRating)
}

// SetTimeLimitRatingOverview sets the "time_limit_rating_overview" field.
func (m *TenderMutation) SetTimeLimitRatingOverview(s string) {
	m.time_limit_rating_overview = &s
}

// TimeLimitRatingOverview returns the value of the "time_limit_rating_overview" field in the mutation.
func (m *TenderMutation) TimeLimitRatingOverview() (r string, exists bool) {
	v := m.time_limit_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRatingOverview returns the old "time_limit_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTimeLimitRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRatingOverview: %w", err)
	}
	return oldValue.TimeLimitRatingOverview, nil
}

// ClearTimeLimitRatingOverview clears the value of the "time_limit_rating_overview" field.
func (m *TenderMutation) ClearTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	m.clearedFields[tender.FieldTimeLimitRatingOverview] = struct{}{}
}

// TimeLimitRatingOverviewCleared returns if the "time_limit_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) TimeLimitRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldTimeLimitRatingOverview]
	return ok
}

// ResetTimeLimitRatingOverview resets all changes to the "time_limit_rating_overview" field.
func (m *TenderMutation) ResetTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	delete(m.clearedFields, tender.FieldTimeLimitRatingOverview)
}

// SetCustomerRelationshipRating sets the "customer_relationship_rating" field.
func (m *TenderMutation) SetCustomerRelationshipRating(i int) {
	m.customer_relationship_rating = &i
	m.addcustomer_relationship_rating = nil
}

// CustomerRelationshipRating returns the value of the "customer_relationship_rating" field in the mutation.
func (m *TenderMutation) CustomerRelationshipRating() (r int, exists bool) {
	v := m.customer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRating returns the old "customer_relationship_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerRelationshipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRating: %w", err)
	}
	return oldValue.CustomerRelationshipRating, nil
}

// AddCustomerRelationshipRating adds i to the "customer_relationship_rating" field.
func (m *TenderMutation) AddCustomerRelationshipRating(i int) {
	if m.addcustomer_relationship_rating != nil {
		*m.addcustomer_relationship_rating += i
	} else {
		m.addcustomer_relationship_rating = &i
	}
}

// AddedCustomerRelationshipRating returns the value that was added to the "customer_relationship_rating" field in this mutation.
func (m *TenderMutation) AddedCustomerRelationshipRating() (r int, exists bool) {
	v := m.addcustomer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerRelationshipRating clears the value of the "customer_relationship_rating" field.
func (m *TenderMutation) ClearCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	m.clearedFields[tender.FieldCustomerRelationshipRating] = struct{}{}
}

// CustomerRelationshipRatingCleared returns if the "customer_relationship_rating" field was cleared in this mutation.
func (m *TenderMutation) CustomerRelationshipRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCustomerRelationshipRating]
	return ok
}

// ResetCustomerRelationshipRating resets all changes to the "customer_relationship_rating" field.
func (m *TenderMutation) ResetCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	delete(m.clearedFields, tender.FieldCustomerRelationshipRating)
}

// SetCustomerRelationshipRatingOverview sets the "customer_relationship_rating_overview" field.
func (m *TenderMutation) SetCustomerRelationshipRatingOverview(s string) {
	m.customer_relationship_rating_overview = &s
}

// CustomerRelationshipRatingOverview returns the value of the "customer_relationship_rating_overview" field in the mutation.
func (m *TenderMutation) CustomerRelationshipRatingOverview() (r string, exists bool) {
	v := m.customer_relationship_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRatingOverview returns the old "customer_relationship_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerRelationshipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRatingOverview: %w", err)
	}
	return oldValue.CustomerRelationshipRatingOverview, nil
}

// ClearCustomerRelationshipRatingOverview clears the value of the "customer_relationship_rating_overview" field.
func (m *TenderMutation) ClearCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	m.clearedFields[tender.FieldCustomerRelationshipRatingOverview] = struct{}{}
}

// CustomerRelationshipRatingOverviewCleared returns if the "customer_relationship_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CustomerRelationshipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCustomerRelationshipRatingOverview]
	return ok
}

// ResetCustomerRelationshipRatingOverview resets all changes to the "customer_relationship_rating_overview" field.
func (m *TenderMutation) ResetCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	delete(m.clearedFields, tender.FieldCustomerRelationshipRatingOverview)
}

// SetCompetitivePartnershipRating sets the "competitive_partnership_rating" field.
func (m *TenderMutation) SetCompetitivePartnershipRating(i int) {
	m.competitive_partnership_rating = &i
	m.addcompetitive_partnership_rating = nil
}

// CompetitivePartnershipRating returns the value of the "competitive_partnership_rating" field in the mutation.
func (m *TenderMutation) CompetitivePartnershipRating() (r int, exists bool) {
	v := m.competitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRating returns the old "competitive_partnership_rating" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitivePartnershipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRating: %w", err)
	}
	return oldValue.CompetitivePartnershipRating, nil
}

// AddCompetitivePartnershipRating adds i to the "competitive_partnership_rating" field.
func (m *TenderMutation) AddCompetitivePartnershipRating(i int) {
	if m.addcompetitive_partnership_rating != nil {
		*m.addcompetitive_partnership_rating += i
	} else {
		m.addcompetitive_partnership_rating = &i
	}
}

// AddedCompetitivePartnershipRating returns the value that was added to the "competitive_partnership_rating" field in this mutation.
func (m *TenderMutation) AddedCompetitivePartnershipRating() (r int, exists bool) {
	v := m.addcompetitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompetitivePartnershipRating clears the value of the "competitive_partnership_rating" field.
func (m *TenderMutation) ClearCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	m.clearedFields[tender.FieldCompetitivePartnershipRating] = struct{}{}
}

// CompetitivePartnershipRatingCleared returns if the "competitive_partnership_rating" field was cleared in this mutation.
func (m *TenderMutation) CompetitivePartnershipRatingCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitivePartnershipRating]
	return ok
}

// ResetCompetitivePartnershipRating resets all changes to the "competitive_partnership_rating" field.
func (m *TenderMutation) ResetCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	delete(m.clearedFields, tender.FieldCompetitivePartnershipRating)
}

// SetCompetitivePartnershipRatingOverview sets the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) SetCompetitivePartnershipRatingOverview(s string) {
	m.competitive_partnership_rating_overview = &s
}

// CompetitivePartnershipRatingOverview returns the value of the "competitive_partnership_rating_overview" field in the mutation.
func (m *TenderMutation) CompetitivePartnershipRatingOverview() (r string, exists bool) {
	v := m.competitive_partnership_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRatingOverview returns the old "competitive_partnership_rating_overview" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitivePartnershipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRatingOverview: %w", err)
	}
	return oldValue.CompetitivePartnershipRatingOverview, nil
}

// ClearCompetitivePartnershipRatingOverview clears the value of the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) ClearCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	m.clearedFields[tender.FieldCompetitivePartnershipRatingOverview] = struct{}{}
}

// CompetitivePartnershipRatingOverviewCleared returns if the "competitive_partnership_rating_overview" field was cleared in this mutation.
func (m *TenderMutation) CompetitivePartnershipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitivePartnershipRatingOverview]
	return ok
}

// ResetCompetitivePartnershipRatingOverview resets all changes to the "competitive_partnership_rating_overview" field.
func (m *TenderMutation) ResetCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	delete(m.clearedFields, tender.FieldCompetitivePartnershipRatingOverview)
}

// SetPrepareToBid sets the "prepare_to_bid" field.
func (m *TenderMutation) SetPrepareToBid(b bool) {
	m.prepare_to_bid = &b
}

// PrepareToBid returns the value of the "prepare_to_bid" field in the mutation.
func (m *TenderMutation) PrepareToBid() (r bool, exists bool) {
	v := m.prepare_to_bid
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepareToBid returns the old "prepare_to_bid" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldPrepareToBid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepareToBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepareToBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepareToBid: %w", err)
	}
	return oldValue.PrepareToBid, nil
}

// ResetPrepareToBid resets all changes to the "prepare_to_bid" field.
func (m *TenderMutation) ResetPrepareToBid() {
	m.prepare_to_bid = nil
}

// SetProjectCode sets the "project_code" field.
func (m *TenderMutation) SetProjectCode(s string) {
	m.project_code = &s
}

// ProjectCode returns the value of the "project_code" field in the mutation.
func (m *TenderMutation) ProjectCode() (r string, exists bool) {
	v := m.project_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectCode returns the old "project_code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectCode: %w", err)
	}
	return oldValue.ProjectCode, nil
}

// ClearProjectCode clears the value of the "project_code" field.
func (m *TenderMutation) ClearProjectCode() {
	m.project_code = nil
	m.clearedFields[tender.FieldProjectCode] = struct{}{}
}

// ProjectCodeCleared returns if the "project_code" field was cleared in this mutation.
func (m *TenderMutation) ProjectCodeCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectCode]
	return ok
}

// ResetProjectCode resets all changes to the "project_code" field.
func (m *TenderMutation) ResetProjectCode() {
	m.project_code = nil
	delete(m.clearedFields, tender.FieldProjectCode)
}

// SetProjectType sets the "project_type" field.
func (m *TenderMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *TenderMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ClearProjectType clears the value of the "project_type" field.
func (m *TenderMutation) ClearProjectType() {
	m.project_type = nil
	m.clearedFields[tender.FieldProjectType] = struct{}{}
}

// ProjectTypeCleared returns if the "project_type" field was cleared in this mutation.
func (m *TenderMutation) ProjectTypeCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectType]
	return ok
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *TenderMutation) ResetProjectType() {
	m.project_type = nil
	delete(m.clearedFields, tender.FieldProjectType)
}

// SetProjectDefinition sets the "project_definition" field.
func (m *TenderMutation) SetProjectDefinition(s string) {
	m.project_definition = &s
}

// ProjectDefinition returns the value of the "project_definition" field in the mutation.
func (m *TenderMutation) ProjectDefinition() (r string, exists bool) {
	v := m.project_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectDefinition returns the old "project_definition" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProjectDefinition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectDefinition: %w", err)
	}
	return oldValue.ProjectDefinition, nil
}

// ClearProjectDefinition clears the value of the "project_definition" field.
func (m *TenderMutation) ClearProjectDefinition() {
	m.project_definition = nil
	m.clearedFields[tender.FieldProjectDefinition] = struct{}{}
}

// ProjectDefinitionCleared returns if the "project_definition" field was cleared in this mutation.
func (m *TenderMutation) ProjectDefinitionCleared() bool {
	_, ok := m.clearedFields[tender.FieldProjectDefinition]
	return ok
}

// ResetProjectDefinition resets all changes to the "project_definition" field.
func (m *TenderMutation) ResetProjectDefinition() {
	m.project_definition = nil
	delete(m.clearedFields, tender.FieldProjectDefinition)
}

// SetEstimatedProjectStartDate sets the "estimated_project_start_date" field.
func (m *TenderMutation) SetEstimatedProjectStartDate(t time.Time) {
	m.estimated_project_start_date = &t
}

// EstimatedProjectStartDate returns the value of the "estimated_project_start_date" field in the mutation.
func (m *TenderMutation) EstimatedProjectStartDate() (r time.Time, exists bool) {
	v := m.estimated_project_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectStartDate returns the old "estimated_project_start_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedProjectStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectStartDate: %w", err)
	}
	return oldValue.EstimatedProjectStartDate, nil
}

// ClearEstimatedProjectStartDate clears the value of the "estimated_project_start_date" field.
func (m *TenderMutation) ClearEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	m.clearedFields[tender.FieldEstimatedProjectStartDate] = struct{}{}
}

// EstimatedProjectStartDateCleared returns if the "estimated_project_start_date" field was cleared in this mutation.
func (m *TenderMutation) EstimatedProjectStartDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedProjectStartDate]
	return ok
}

// ResetEstimatedProjectStartDate resets all changes to the "estimated_project_start_date" field.
func (m *TenderMutation) ResetEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	delete(m.clearedFields, tender.FieldEstimatedProjectStartDate)
}

// SetEstimatedProjectEndDate sets the "estimated_project_end_date" field.
func (m *TenderMutation) SetEstimatedProjectEndDate(t time.Time) {
	m.estimated_project_end_date = &t
}

// EstimatedProjectEndDate returns the value of the "estimated_project_end_date" field in the mutation.
func (m *TenderMutation) EstimatedProjectEndDate() (r time.Time, exists bool) {
	v := m.estimated_project_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectEndDate returns the old "estimated_project_end_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldEstimatedProjectEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectEndDate: %w", err)
	}
	return oldValue.EstimatedProjectEndDate, nil
}

// ClearEstimatedProjectEndDate clears the value of the "estimated_project_end_date" field.
func (m *TenderMutation) ClearEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	m.clearedFields[tender.FieldEstimatedProjectEndDate] = struct{}{}
}

// EstimatedProjectEndDateCleared returns if the "estimated_project_end_date" field was cleared in this mutation.
func (m *TenderMutation) EstimatedProjectEndDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldEstimatedProjectEndDate]
	return ok
}

// ResetEstimatedProjectEndDate resets all changes to the "estimated_project_end_date" field.
func (m *TenderMutation) ResetEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	delete(m.clearedFields, tender.FieldEstimatedProjectEndDate)
}

// SetAttachements sets the "attachements" field.
func (m *TenderMutation) SetAttachements(s []string) {
	m.attachements = &s
	m.appendattachements = nil
}

// Attachements returns the value of the "attachements" field in the mutation.
func (m *TenderMutation) Attachements() (r []string, exists bool) {
	v := m.attachements
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachements returns the old "attachements" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAttachements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachements: %w", err)
	}
	return oldValue.Attachements, nil
}

// AppendAttachements adds s to the "attachements" field.
func (m *TenderMutation) AppendAttachements(s []string) {
	m.appendattachements = append(m.appendattachements, s...)
}

// AppendedAttachements returns the list of values that were appended to the "attachements" field in this mutation.
func (m *TenderMutation) AppendedAttachements() ([]string, bool) {
	if len(m.appendattachements) == 0 {
		return nil, false
	}
	return m.appendattachements, true
}

// ClearAttachements clears the value of the "attachements" field.
func (m *TenderMutation) ClearAttachements() {
	m.attachements = nil
	m.appendattachements = nil
	m.clearedFields[tender.FieldAttachements] = struct{}{}
}

// AttachementsCleared returns if the "attachements" field was cleared in this mutation.
func (m *TenderMutation) AttachementsCleared() bool {
	_, ok := m.clearedFields[tender.FieldAttachements]
	return ok
}

// ResetAttachements resets all changes to the "attachements" field.
func (m *TenderMutation) ResetAttachements() {
	m.attachements = nil
	m.appendattachements = nil
	delete(m.clearedFields, tender.FieldAttachements)
}

// SetGeoCoordinate sets the "geo_coordinate" field.
func (m *TenderMutation) SetGeoCoordinate(gj *geo.GeoJson) {
	m.geo_coordinate = &gj
}

// GeoCoordinate returns the value of the "geo_coordinate" field in the mutation.
func (m *TenderMutation) GeoCoordinate() (r *geo.GeoJson, exists bool) {
	v := m.geo_coordinate
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoCoordinate returns the old "geo_coordinate" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldGeoCoordinate(ctx context.Context) (v *geo.GeoJson, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoCoordinate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoCoordinate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoCoordinate: %w", err)
	}
	return oldValue.GeoCoordinate, nil
}

// ClearGeoCoordinate clears the value of the "geo_coordinate" field.
func (m *TenderMutation) ClearGeoCoordinate() {
	m.geo_coordinate = nil
	m.clearedFields[tender.FieldGeoCoordinate] = struct{}{}
}

// GeoCoordinateCleared returns if the "geo_coordinate" field was cleared in this mutation.
func (m *TenderMutation) GeoCoordinateCleared() bool {
	_, ok := m.clearedFields[tender.FieldGeoCoordinate]
	return ok
}

// ResetGeoCoordinate resets all changes to the "geo_coordinate" field.
func (m *TenderMutation) ResetGeoCoordinate() {
	m.geo_coordinate = nil
	delete(m.clearedFields, tender.FieldGeoCoordinate)
}

// SetGeoBounds sets the "geo_bounds" field.
func (m *TenderMutation) SetGeoBounds(f [][]float64) {
	m.geo_bounds = &f
	m.appendgeo_bounds = nil
}

// GeoBounds returns the value of the "geo_bounds" field in the mutation.
func (m *TenderMutation) GeoBounds() (r [][]float64, exists bool) {
	v := m.geo_bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoBounds returns the old "geo_bounds" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldGeoBounds(ctx context.Context) (v [][]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoBounds: %w", err)
	}
	return oldValue.GeoBounds, nil
}

// AppendGeoBounds adds f to the "geo_bounds" field.
func (m *TenderMutation) AppendGeoBounds(f [][]float64) {
	m.appendgeo_bounds = append(m.appendgeo_bounds, f...)
}

// AppendedGeoBounds returns the list of values that were appended to the "geo_bounds" field in this mutation.
func (m *TenderMutation) AppendedGeoBounds() ([][]float64, bool) {
	if len(m.appendgeo_bounds) == 0 {
		return nil, false
	}
	return m.appendgeo_bounds, true
}

// ClearGeoBounds clears the value of the "geo_bounds" field.
func (m *TenderMutation) ClearGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	m.clearedFields[tender.FieldGeoBounds] = struct{}{}
}

// GeoBoundsCleared returns if the "geo_bounds" field was cleared in this mutation.
func (m *TenderMutation) GeoBoundsCleared() bool {
	_, ok := m.clearedFields[tender.FieldGeoBounds]
	return ok
}

// ResetGeoBounds resets all changes to the "geo_bounds" field.
func (m *TenderMutation) ResetGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	delete(m.clearedFields, tender.FieldGeoBounds)
}

// SetRemark sets the "remark" field.
func (m *TenderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TenderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TenderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[tender.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TenderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[tender.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TenderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, tender.FieldRemark)
}

// SetImages sets the "images" field.
func (m *TenderMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *TenderMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *TenderMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *TenderMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *TenderMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[tender.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *TenderMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[tender.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *TenderMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, tender.FieldImages)
}

// SetTenderSituations sets the "tender_situations" field.
func (m *TenderMutation) SetTenderSituations(s string) {
	m.tender_situations = &s
}

// TenderSituations returns the value of the "tender_situations" field in the mutation.
func (m *TenderMutation) TenderSituations() (r string, exists bool) {
	v := m.tender_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderSituations returns the old "tender_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderSituations: %w", err)
	}
	return oldValue.TenderSituations, nil
}

// ClearTenderSituations clears the value of the "tender_situations" field.
func (m *TenderMutation) ClearTenderSituations() {
	m.tender_situations = nil
	m.clearedFields[tender.FieldTenderSituations] = struct{}{}
}

// TenderSituationsCleared returns if the "tender_situations" field was cleared in this mutation.
func (m *TenderMutation) TenderSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderSituations]
	return ok
}

// ResetTenderSituations resets all changes to the "tender_situations" field.
func (m *TenderMutation) ResetTenderSituations() {
	m.tender_situations = nil
	delete(m.clearedFields, tender.FieldTenderSituations)
}

// SetOwnerSituations sets the "owner_situations" field.
func (m *TenderMutation) SetOwnerSituations(s string) {
	m.owner_situations = &s
}

// OwnerSituations returns the value of the "owner_situations" field in the mutation.
func (m *TenderMutation) OwnerSituations() (r string, exists bool) {
	v := m.owner_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSituations returns the old "owner_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldOwnerSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSituations: %w", err)
	}
	return oldValue.OwnerSituations, nil
}

// ClearOwnerSituations clears the value of the "owner_situations" field.
func (m *TenderMutation) ClearOwnerSituations() {
	m.owner_situations = nil
	m.clearedFields[tender.FieldOwnerSituations] = struct{}{}
}

// OwnerSituationsCleared returns if the "owner_situations" field was cleared in this mutation.
func (m *TenderMutation) OwnerSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldOwnerSituations]
	return ok
}

// ResetOwnerSituations resets all changes to the "owner_situations" field.
func (m *TenderMutation) ResetOwnerSituations() {
	m.owner_situations = nil
	delete(m.clearedFields, tender.FieldOwnerSituations)
}

// SetBiddingInstructions sets the "bidding_instructions" field.
func (m *TenderMutation) SetBiddingInstructions(s string) {
	m.bidding_instructions = &s
}

// BiddingInstructions returns the value of the "bidding_instructions" field in the mutation.
func (m *TenderMutation) BiddingInstructions() (r string, exists bool) {
	v := m.bidding_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingInstructions returns the old "bidding_instructions" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldBiddingInstructions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingInstructions: %w", err)
	}
	return oldValue.BiddingInstructions, nil
}

// ClearBiddingInstructions clears the value of the "bidding_instructions" field.
func (m *TenderMutation) ClearBiddingInstructions() {
	m.bidding_instructions = nil
	m.clearedFields[tender.FieldBiddingInstructions] = struct{}{}
}

// BiddingInstructionsCleared returns if the "bidding_instructions" field was cleared in this mutation.
func (m *TenderMutation) BiddingInstructionsCleared() bool {
	_, ok := m.clearedFields[tender.FieldBiddingInstructions]
	return ok
}

// ResetBiddingInstructions resets all changes to the "bidding_instructions" field.
func (m *TenderMutation) ResetBiddingInstructions() {
	m.bidding_instructions = nil
	delete(m.clearedFields, tender.FieldBiddingInstructions)
}

// SetCompetitorSituations sets the "competitor_situations" field.
func (m *TenderMutation) SetCompetitorSituations(s string) {
	m.competitor_situations = &s
}

// CompetitorSituations returns the value of the "competitor_situations" field in the mutation.
func (m *TenderMutation) CompetitorSituations() (r string, exists bool) {
	v := m.competitor_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitorSituations returns the old "competitor_situations" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCompetitorSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitorSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitorSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitorSituations: %w", err)
	}
	return oldValue.CompetitorSituations, nil
}

// ClearCompetitorSituations clears the value of the "competitor_situations" field.
func (m *TenderMutation) ClearCompetitorSituations() {
	m.competitor_situations = nil
	m.clearedFields[tender.FieldCompetitorSituations] = struct{}{}
}

// CompetitorSituationsCleared returns if the "competitor_situations" field was cleared in this mutation.
func (m *TenderMutation) CompetitorSituationsCleared() bool {
	_, ok := m.clearedFields[tender.FieldCompetitorSituations]
	return ok
}

// ResetCompetitorSituations resets all changes to the "competitor_situations" field.
func (m *TenderMutation) ResetCompetitorSituations() {
	m.competitor_situations = nil
	delete(m.clearedFields, tender.FieldCompetitorSituations)
}

// SetCostEngineer sets the "cost_engineer" field.
func (m *TenderMutation) SetCostEngineer(s string) {
	m.cost_engineer = &s
}

// CostEngineer returns the value of the "cost_engineer" field in the mutation.
func (m *TenderMutation) CostEngineer() (r string, exists bool) {
	v := m.cost_engineer
	if v == nil {
		return
	}
	return *v, true
}

// OldCostEngineer returns the old "cost_engineer" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCostEngineer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostEngineer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostEngineer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostEngineer: %w", err)
	}
	return oldValue.CostEngineer, nil
}

// ClearCostEngineer clears the value of the "cost_engineer" field.
func (m *TenderMutation) ClearCostEngineer() {
	m.cost_engineer = nil
	m.clearedFields[tender.FieldCostEngineer] = struct{}{}
}

// CostEngineerCleared returns if the "cost_engineer" field was cleared in this mutation.
func (m *TenderMutation) CostEngineerCleared() bool {
	_, ok := m.clearedFields[tender.FieldCostEngineer]
	return ok
}

// ResetCostEngineer resets all changes to the "cost_engineer" field.
func (m *TenderMutation) ResetCostEngineer() {
	m.cost_engineer = nil
	delete(m.clearedFields, tender.FieldCostEngineer)
}

// SetTenderForm sets the "tender_form" field.
func (m *TenderMutation) SetTenderForm(s string) {
	m.tender_form = &s
}

// TenderForm returns the value of the "tender_form" field in the mutation.
func (m *TenderMutation) TenderForm() (r string, exists bool) {
	v := m.tender_form
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderForm returns the old "tender_form" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderForm: %w", err)
	}
	return oldValue.TenderForm, nil
}

// ClearTenderForm clears the value of the "tender_form" field.
func (m *TenderMutation) ClearTenderForm() {
	m.tender_form = nil
	m.clearedFields[tender.FieldTenderForm] = struct{}{}
}

// TenderFormCleared returns if the "tender_form" field was cleared in this mutation.
func (m *TenderMutation) TenderFormCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderForm]
	return ok
}

// ResetTenderForm resets all changes to the "tender_form" field.
func (m *TenderMutation) ResetTenderForm() {
	m.tender_form = nil
	delete(m.clearedFields, tender.FieldTenderForm)
}

// SetContractForm sets the "contract_form" field.
func (m *TenderMutation) SetContractForm(s string) {
	m.contract_form = &s
}

// ContractForm returns the value of the "contract_form" field in the mutation.
func (m *TenderMutation) ContractForm() (r string, exists bool) {
	v := m.contract_form
	if v == nil {
		return
	}
	return *v, true
}

// OldContractForm returns the old "contract_form" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldContractForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractForm: %w", err)
	}
	return oldValue.ContractForm, nil
}

// ClearContractForm clears the value of the "contract_form" field.
func (m *TenderMutation) ClearContractForm() {
	m.contract_form = nil
	m.clearedFields[tender.FieldContractForm] = struct{}{}
}

// ContractFormCleared returns if the "contract_form" field was cleared in this mutation.
func (m *TenderMutation) ContractFormCleared() bool {
	_, ok := m.clearedFields[tender.FieldContractForm]
	return ok
}

// ResetContractForm resets all changes to the "contract_form" field.
func (m *TenderMutation) ResetContractForm() {
	m.contract_form = nil
	delete(m.clearedFields, tender.FieldContractForm)
}

// SetManagementCompany sets the "management_company" field.
func (m *TenderMutation) SetManagementCompany(s string) {
	m.management_company = &s
}

// ManagementCompany returns the value of the "management_company" field in the mutation.
func (m *TenderMutation) ManagementCompany() (r string, exists bool) {
	v := m.management_company
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementCompany returns the old "management_company" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldManagementCompany(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementCompany: %w", err)
	}
	return oldValue.ManagementCompany, nil
}

// ClearManagementCompany clears the value of the "management_company" field.
func (m *TenderMutation) ClearManagementCompany() {
	m.management_company = nil
	m.clearedFields[tender.FieldManagementCompany] = struct{}{}
}

// ManagementCompanyCleared returns if the "management_company" field was cleared in this mutation.
func (m *TenderMutation) ManagementCompanyCleared() bool {
	_, ok := m.clearedFields[tender.FieldManagementCompany]
	return ok
}

// ResetManagementCompany resets all changes to the "management_company" field.
func (m *TenderMutation) ResetManagementCompany() {
	m.management_company = nil
	delete(m.clearedFields, tender.FieldManagementCompany)
}

// SetTenderingAgency sets the "tendering_agency" field.
func (m *TenderMutation) SetTenderingAgency(s string) {
	m.tendering_agency = &s
}

// TenderingAgency returns the value of the "tendering_agency" field in the mutation.
func (m *TenderMutation) TenderingAgency() (r string, exists bool) {
	v := m.tendering_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderingAgency returns the old "tendering_agency" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderingAgency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderingAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderingAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderingAgency: %w", err)
	}
	return oldValue.TenderingAgency, nil
}

// ClearTenderingAgency clears the value of the "tendering_agency" field.
func (m *TenderMutation) ClearTenderingAgency() {
	m.tendering_agency = nil
	m.clearedFields[tender.FieldTenderingAgency] = struct{}{}
}

// TenderingAgencyCleared returns if the "tendering_agency" field was cleared in this mutation.
func (m *TenderMutation) TenderingAgencyCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderingAgency]
	return ok
}

// ResetTenderingAgency resets all changes to the "tendering_agency" field.
func (m *TenderMutation) ResetTenderingAgency() {
	m.tendering_agency = nil
	delete(m.clearedFields, tender.FieldTenderingAgency)
}

// SetBiddingDate sets the "bidding_date" field.
func (m *TenderMutation) SetBiddingDate(t time.Time) {
	m.bidding_date = &t
}

// BiddingDate returns the value of the "bidding_date" field in the mutation.
func (m *TenderMutation) BiddingDate() (r time.Time, exists bool) {
	v := m.bidding_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingDate returns the old "bidding_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldBiddingDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingDate: %w", err)
	}
	return oldValue.BiddingDate, nil
}

// ClearBiddingDate clears the value of the "bidding_date" field.
func (m *TenderMutation) ClearBiddingDate() {
	m.bidding_date = nil
	m.clearedFields[tender.FieldBiddingDate] = struct{}{}
}

// BiddingDateCleared returns if the "bidding_date" field was cleared in this mutation.
func (m *TenderMutation) BiddingDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldBiddingDate]
	return ok
}

// ResetBiddingDate resets all changes to the "bidding_date" field.
func (m *TenderMutation) ResetBiddingDate() {
	m.bidding_date = nil
	delete(m.clearedFields, tender.FieldBiddingDate)
}

// SetFacadeConsultant sets the "facade_consultant" field.
func (m *TenderMutation) SetFacadeConsultant(s string) {
	m.facade_consultant = &s
}

// FacadeConsultant returns the value of the "facade_consultant" field in the mutation.
func (m *TenderMutation) FacadeConsultant() (r string, exists bool) {
	v := m.facade_consultant
	if v == nil {
		return
	}
	return *v, true
}

// OldFacadeConsultant returns the old "facade_consultant" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFacadeConsultant(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacadeConsultant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacadeConsultant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacadeConsultant: %w", err)
	}
	return oldValue.FacadeConsultant, nil
}

// ClearFacadeConsultant clears the value of the "facade_consultant" field.
func (m *TenderMutation) ClearFacadeConsultant() {
	m.facade_consultant = nil
	m.clearedFields[tender.FieldFacadeConsultant] = struct{}{}
}

// FacadeConsultantCleared returns if the "facade_consultant" field was cleared in this mutation.
func (m *TenderMutation) FacadeConsultantCleared() bool {
	_, ok := m.clearedFields[tender.FieldFacadeConsultant]
	return ok
}

// ResetFacadeConsultant resets all changes to the "facade_consultant" field.
func (m *TenderMutation) ResetFacadeConsultant() {
	m.facade_consultant = nil
	delete(m.clearedFields, tender.FieldFacadeConsultant)
}

// SetDesignUnit sets the "design_unit" field.
func (m *TenderMutation) SetDesignUnit(s string) {
	m.design_unit = &s
}

// DesignUnit returns the value of the "design_unit" field in the mutation.
func (m *TenderMutation) DesignUnit() (r string, exists bool) {
	v := m.design_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignUnit returns the old "design_unit" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDesignUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignUnit: %w", err)
	}
	return oldValue.DesignUnit, nil
}

// ClearDesignUnit clears the value of the "design_unit" field.
func (m *TenderMutation) ClearDesignUnit() {
	m.design_unit = nil
	m.clearedFields[tender.FieldDesignUnit] = struct{}{}
}

// DesignUnitCleared returns if the "design_unit" field was cleared in this mutation.
func (m *TenderMutation) DesignUnitCleared() bool {
	_, ok := m.clearedFields[tender.FieldDesignUnit]
	return ok
}

// ResetDesignUnit resets all changes to the "design_unit" field.
func (m *TenderMutation) ResetDesignUnit() {
	m.design_unit = nil
	delete(m.clearedFields, tender.FieldDesignUnit)
}

// SetConsultingFirm sets the "consulting_firm" field.
func (m *TenderMutation) SetConsultingFirm(s string) {
	m.consulting_firm = &s
}

// ConsultingFirm returns the value of the "consulting_firm" field in the mutation.
func (m *TenderMutation) ConsultingFirm() (r string, exists bool) {
	v := m.consulting_firm
	if v == nil {
		return
	}
	return *v, true
}

// OldConsultingFirm returns the old "consulting_firm" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldConsultingFirm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsultingFirm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsultingFirm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsultingFirm: %w", err)
	}
	return oldValue.ConsultingFirm, nil
}

// ClearConsultingFirm clears the value of the "consulting_firm" field.
func (m *TenderMutation) ClearConsultingFirm() {
	m.consulting_firm = nil
	m.clearedFields[tender.FieldConsultingFirm] = struct{}{}
}

// ConsultingFirmCleared returns if the "consulting_firm" field was cleared in this mutation.
func (m *TenderMutation) ConsultingFirmCleared() bool {
	_, ok := m.clearedFields[tender.FieldConsultingFirm]
	return ok
}

// ResetConsultingFirm resets all changes to the "consulting_firm" field.
func (m *TenderMutation) ResetConsultingFirm() {
	m.consulting_firm = nil
	delete(m.clearedFields, tender.FieldConsultingFirm)
}

// SetKeyProject sets the "key_project" field.
func (m *TenderMutation) SetKeyProject(b bool) {
	m.key_project = &b
}

// KeyProject returns the value of the "key_project" field in the mutation.
func (m *TenderMutation) KeyProject() (r bool, exists bool) {
	v := m.key_project
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyProject returns the old "key_project" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldKeyProject(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyProject: %w", err)
	}
	return oldValue.KeyProject, nil
}

// ResetKeyProject resets all changes to the "key_project" field.
func (m *TenderMutation) ResetKeyProject() {
	m.key_project = nil
}

// SetCurrentProgress sets the "current_progress" field.
func (m *TenderMutation) SetCurrentProgress(s string) {
	m.current_progress = &s
}

// CurrentProgress returns the value of the "current_progress" field in the mutation.
func (m *TenderMutation) CurrentProgress() (r string, exists bool) {
	v := m.current_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentProgress returns the old "current_progress" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCurrentProgress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentProgress: %w", err)
	}
	return oldValue.CurrentProgress, nil
}

// ClearCurrentProgress clears the value of the "current_progress" field.
func (m *TenderMutation) ClearCurrentProgress() {
	m.current_progress = nil
	m.clearedFields[tender.FieldCurrentProgress] = struct{}{}
}

// CurrentProgressCleared returns if the "current_progress" field was cleared in this mutation.
func (m *TenderMutation) CurrentProgressCleared() bool {
	_, ok := m.clearedFields[tender.FieldCurrentProgress]
	return ok
}

// ResetCurrentProgress resets all changes to the "current_progress" field.
func (m *TenderMutation) ResetCurrentProgress() {
	m.current_progress = nil
	delete(m.clearedFields, tender.FieldCurrentProgress)
}

// SetTenderWinCompany sets the "tender_win_company" field.
func (m *TenderMutation) SetTenderWinCompany(s string) {
	m.tender_win_company = &s
}

// TenderWinCompany returns the value of the "tender_win_company" field in the mutation.
func (m *TenderMutation) TenderWinCompany() (r string, exists bool) {
	v := m.tender_win_company
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinCompany returns the old "tender_win_company" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderWinCompany(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinCompany: %w", err)
	}
	return oldValue.TenderWinCompany, nil
}

// ClearTenderWinCompany clears the value of the "tender_win_company" field.
func (m *TenderMutation) ClearTenderWinCompany() {
	m.tender_win_company = nil
	m.clearedFields[tender.FieldTenderWinCompany] = struct{}{}
}

// TenderWinCompanyCleared returns if the "tender_win_company" field was cleared in this mutation.
func (m *TenderMutation) TenderWinCompanyCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderWinCompany]
	return ok
}

// ResetTenderWinCompany resets all changes to the "tender_win_company" field.
func (m *TenderMutation) ResetTenderWinCompany() {
	m.tender_win_company = nil
	delete(m.clearedFields, tender.FieldTenderWinCompany)
}

// SetTenderCode sets the "tender_code" field.
func (m *TenderMutation) SetTenderCode(s string) {
	m.tender_code = &s
}

// TenderCode returns the value of the "tender_code" field in the mutation.
func (m *TenderMutation) TenderCode() (r string, exists bool) {
	v := m.tender_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderCode returns the old "tender_code" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderCode: %w", err)
	}
	return oldValue.TenderCode, nil
}

// ClearTenderCode clears the value of the "tender_code" field.
func (m *TenderMutation) ClearTenderCode() {
	m.tender_code = nil
	m.clearedFields[tender.FieldTenderCode] = struct{}{}
}

// TenderCodeCleared returns if the "tender_code" field was cleared in this mutation.
func (m *TenderMutation) TenderCodeCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderCode]
	return ok
}

// ResetTenderCode resets all changes to the "tender_code" field.
func (m *TenderMutation) ResetTenderCode() {
	m.tender_code = nil
	delete(m.clearedFields, tender.FieldTenderCode)
}

// SetArchitect sets the "architect" field.
func (m *TenderMutation) SetArchitect(s string) {
	m.architect = &s
}

// Architect returns the value of the "architect" field in the mutation.
func (m *TenderMutation) Architect() (r string, exists bool) {
	v := m.architect
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitect returns the old "architect" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldArchitect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitect: %w", err)
	}
	return oldValue.Architect, nil
}

// ClearArchitect clears the value of the "architect" field.
func (m *TenderMutation) ClearArchitect() {
	m.architect = nil
	m.clearedFields[tender.FieldArchitect] = struct{}{}
}

// ArchitectCleared returns if the "architect" field was cleared in this mutation.
func (m *TenderMutation) ArchitectCleared() bool {
	_, ok := m.clearedFields[tender.FieldArchitect]
	return ok
}

// ResetArchitect resets all changes to the "architect" field.
func (m *TenderMutation) ResetArchitect() {
	m.architect = nil
	delete(m.clearedFields, tender.FieldArchitect)
}

// SetDeveloper sets the "developer" field.
func (m *TenderMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *TenderMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *TenderMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[tender.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *TenderMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[tender.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *TenderMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, tender.FieldDeveloper)
}

// SetTenderClosingDate sets the "tender_closing_date" field.
func (m *TenderMutation) SetTenderClosingDate(t time.Time) {
	m.tender_closing_date = &t
}

// TenderClosingDate returns the value of the "tender_closing_date" field in the mutation.
func (m *TenderMutation) TenderClosingDate() (r time.Time, exists bool) {
	v := m.tender_closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderClosingDate returns the old "tender_closing_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderClosingDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderClosingDate: %w", err)
	}
	return oldValue.TenderClosingDate, nil
}

// ClearTenderClosingDate clears the value of the "tender_closing_date" field.
func (m *TenderMutation) ClearTenderClosingDate() {
	m.tender_closing_date = nil
	m.clearedFields[tender.FieldTenderClosingDate] = struct{}{}
}

// TenderClosingDateCleared returns if the "tender_closing_date" field was cleared in this mutation.
func (m *TenderMutation) TenderClosingDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderClosingDate]
	return ok
}

// ResetTenderClosingDate resets all changes to the "tender_closing_date" field.
func (m *TenderMutation) ResetTenderClosingDate() {
	m.tender_closing_date = nil
	delete(m.clearedFields, tender.FieldTenderClosingDate)
}

// SetConstructionArea sets the "construction_area" field.
func (m *TenderMutation) SetConstructionArea(s string) {
	m.construction_area = &s
}

// ConstructionArea returns the value of the "construction_area" field in the mutation.
func (m *TenderMutation) ConstructionArea() (r string, exists bool) {
	v := m.construction_area
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionArea returns the old "construction_area" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldConstructionArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionArea: %w", err)
	}
	return oldValue.ConstructionArea, nil
}

// ClearConstructionArea clears the value of the "construction_area" field.
func (m *TenderMutation) ClearConstructionArea() {
	m.construction_area = nil
	m.clearedFields[tender.FieldConstructionArea] = struct{}{}
}

// ConstructionAreaCleared returns if the "construction_area" field was cleared in this mutation.
func (m *TenderMutation) ConstructionAreaCleared() bool {
	_, ok := m.clearedFields[tender.FieldConstructionArea]
	return ok
}

// ResetConstructionArea resets all changes to the "construction_area" field.
func (m *TenderMutation) ResetConstructionArea() {
	m.construction_area = nil
	delete(m.clearedFields, tender.FieldConstructionArea)
}

// SetTenderWinDate sets the "tender_win_date" field.
func (m *TenderMutation) SetTenderWinDate(t time.Time) {
	m.tender_win_date = &t
}

// TenderWinDate returns the value of the "tender_win_date" field in the mutation.
func (m *TenderMutation) TenderWinDate() (r time.Time, exists bool) {
	v := m.tender_win_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinDate returns the old "tender_win_date" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderWinDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinDate: %w", err)
	}
	return oldValue.TenderWinDate, nil
}

// ClearTenderWinDate clears the value of the "tender_win_date" field.
func (m *TenderMutation) ClearTenderWinDate() {
	m.tender_win_date = nil
	m.clearedFields[tender.FieldTenderWinDate] = struct{}{}
}

// TenderWinDateCleared returns if the "tender_win_date" field was cleared in this mutation.
func (m *TenderMutation) TenderWinDateCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderWinDate]
	return ok
}

// ResetTenderWinDate resets all changes to the "tender_win_date" field.
func (m *TenderMutation) ResetTenderWinDate() {
	m.tender_win_date = nil
	delete(m.clearedFields, tender.FieldTenderWinDate)
}

// SetTenderWinAmount sets the "tender_win_amount" field.
func (m *TenderMutation) SetTenderWinAmount(f float64) {
	m.tender_win_amount = &f
	m.addtender_win_amount = nil
}

// TenderWinAmount returns the value of the "tender_win_amount" field in the mutation.
func (m *TenderMutation) TenderWinAmount() (r float64, exists bool) {
	v := m.tender_win_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinAmount returns the old "tender_win_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldTenderWinAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinAmount: %w", err)
	}
	return oldValue.TenderWinAmount, nil
}

// AddTenderWinAmount adds f to the "tender_win_amount" field.
func (m *TenderMutation) AddTenderWinAmount(f float64) {
	if m.addtender_win_amount != nil {
		*m.addtender_win_amount += f
	} else {
		m.addtender_win_amount = &f
	}
}

// AddedTenderWinAmount returns the value that was added to the "tender_win_amount" field in this mutation.
func (m *TenderMutation) AddedTenderWinAmount() (r float64, exists bool) {
	v := m.addtender_win_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenderWinAmount clears the value of the "tender_win_amount" field.
func (m *TenderMutation) ClearTenderWinAmount() {
	m.tender_win_amount = nil
	m.addtender_win_amount = nil
	m.clearedFields[tender.FieldTenderWinAmount] = struct{}{}
}

// TenderWinAmountCleared returns if the "tender_win_amount" field was cleared in this mutation.
func (m *TenderMutation) TenderWinAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldTenderWinAmount]
	return ok
}

// ResetTenderWinAmount resets all changes to the "tender_win_amount" field.
func (m *TenderMutation) ResetTenderWinAmount() {
	m.tender_win_amount = nil
	m.addtender_win_amount = nil
	delete(m.clearedFields, tender.FieldTenderWinAmount)
}

// SetLastTenderAmount sets the "last_tender_amount" field.
func (m *TenderMutation) SetLastTenderAmount(f float64) {
	m.last_tender_amount = &f
	m.addlast_tender_amount = nil
}

// LastTenderAmount returns the value of the "last_tender_amount" field in the mutation.
func (m *TenderMutation) LastTenderAmount() (r float64, exists bool) {
	v := m.last_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTenderAmount returns the old "last_tender_amount" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldLastTenderAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTenderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTenderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTenderAmount: %w", err)
	}
	return oldValue.LastTenderAmount, nil
}

// AddLastTenderAmount adds f to the "last_tender_amount" field.
func (m *TenderMutation) AddLastTenderAmount(f float64) {
	if m.addlast_tender_amount != nil {
		*m.addlast_tender_amount += f
	} else {
		m.addlast_tender_amount = &f
	}
}

// AddedLastTenderAmount returns the value that was added to the "last_tender_amount" field in this mutation.
func (m *TenderMutation) AddedLastTenderAmount() (r float64, exists bool) {
	v := m.addlast_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastTenderAmount clears the value of the "last_tender_amount" field.
func (m *TenderMutation) ClearLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	m.clearedFields[tender.FieldLastTenderAmount] = struct{}{}
}

// LastTenderAmountCleared returns if the "last_tender_amount" field was cleared in this mutation.
func (m *TenderMutation) LastTenderAmountCleared() bool {
	_, ok := m.clearedFields[tender.FieldLastTenderAmount]
	return ok
}

// ResetLastTenderAmount resets all changes to the "last_tender_amount" field.
func (m *TenderMutation) ResetLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	delete(m.clearedFields, tender.FieldLastTenderAmount)
}

// SetAreaID sets the "area_id" field.
func (m *TenderMutation) SetAreaID(x xid.ID) {
	m.area = &x
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *TenderMutation) AreaID() (r xid.ID, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldAreaID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *TenderMutation) ResetAreaID() {
	m.area = nil
}

// SetProvinceID sets the "province_id" field.
func (m *TenderMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *TenderMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldProvinceID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ClearProvinceID clears the value of the "province_id" field.
func (m *TenderMutation) ClearProvinceID() {
	m.province = nil
	m.clearedFields[tender.FieldProvinceID] = struct{}{}
}

// ProvinceIDCleared returns if the "province_id" field was cleared in this mutation.
func (m *TenderMutation) ProvinceIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldProvinceID]
	return ok
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *TenderMutation) ResetProvinceID() {
	m.province = nil
	delete(m.clearedFields, tender.FieldProvinceID)
}

// SetCityID sets the "city_id" field.
func (m *TenderMutation) SetCityID(x xid.ID) {
	m.city = &x
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *TenderMutation) CityID() (r xid.ID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCityID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *TenderMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[tender.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *TenderMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *TenderMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, tender.FieldCityID)
}

// SetDistrictID sets the "district_id" field.
func (m *TenderMutation) SetDistrictID(x xid.ID) {
	m.district = &x
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *TenderMutation) DistrictID() (r xid.ID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldDistrictID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ClearDistrictID clears the value of the "district_id" field.
func (m *TenderMutation) ClearDistrictID() {
	m.district = nil
	m.clearedFields[tender.FieldDistrictID] = struct{}{}
}

// DistrictIDCleared returns if the "district_id" field was cleared in this mutation.
func (m *TenderMutation) DistrictIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldDistrictID]
	return ok
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *TenderMutation) ResetDistrictID() {
	m.district = nil
	delete(m.clearedFields, tender.FieldDistrictID)
}

// SetCustomerID sets the "customer_id" field.
func (m *TenderMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *TenderMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCustomerID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *TenderMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[tender.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *TenderMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *TenderMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, tender.FieldCustomerID)
}

// SetFinderID sets the "finder_id" field.
func (m *TenderMutation) SetFinderID(x xid.ID) {
	m.finder = &x
}

// FinderID returns the value of the "finder_id" field in the mutation.
func (m *TenderMutation) FinderID() (r xid.ID, exists bool) {
	v := m.finder
	if v == nil {
		return
	}
	return *v, true
}

// OldFinderID returns the old "finder_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldFinderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinderID: %w", err)
	}
	return oldValue.FinderID, nil
}

// ClearFinderID clears the value of the "finder_id" field.
func (m *TenderMutation) ClearFinderID() {
	m.finder = nil
	m.clearedFields[tender.FieldFinderID] = struct{}{}
}

// FinderIDCleared returns if the "finder_id" field was cleared in this mutation.
func (m *TenderMutation) FinderIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldFinderID]
	return ok
}

// ResetFinderID resets all changes to the "finder_id" field.
func (m *TenderMutation) ResetFinderID() {
	m.finder = nil
	delete(m.clearedFields, tender.FieldFinderID)
}

// SetCreatedByID sets the "created_by_id" field.
func (m *TenderMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *TenderMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldCreatedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ClearCreatedByID clears the value of the "created_by_id" field.
func (m *TenderMutation) ClearCreatedByID() {
	m.created_by = nil
	m.clearedFields[tender.FieldCreatedByID] = struct{}{}
}

// CreatedByIDCleared returns if the "created_by_id" field was cleared in this mutation.
func (m *TenderMutation) CreatedByIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldCreatedByID]
	return ok
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *TenderMutation) ResetCreatedByID() {
	m.created_by = nil
	delete(m.clearedFields, tender.FieldCreatedByID)
}

// SetApproverID sets the "approver_id" field.
func (m *TenderMutation) SetApproverID(x xid.ID) {
	m.approver = &x
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *TenderMutation) ApproverID() (r xid.ID, exists bool) {
	v := m.approver
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldApproverID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *TenderMutation) ClearApproverID() {
	m.approver = nil
	m.clearedFields[tender.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *TenderMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *TenderMutation) ResetApproverID() {
	m.approver = nil
	delete(m.clearedFields, tender.FieldApproverID)
}

// SetActiveProfileID sets the "active_profile_id" field.
func (m *TenderMutation) SetActiveProfileID(x xid.ID) {
	m.active_profile = &x
}

// ActiveProfileID returns the value of the "active_profile_id" field in the mutation.
func (m *TenderMutation) ActiveProfileID() (r xid.ID, exists bool) {
	v := m.active_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveProfileID returns the old "active_profile_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldActiveProfileID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveProfileID: %w", err)
	}
	return oldValue.ActiveProfileID, nil
}

// ClearActiveProfileID clears the value of the "active_profile_id" field.
func (m *TenderMutation) ClearActiveProfileID() {
	m.active_profile = nil
	m.clearedFields[tender.FieldActiveProfileID] = struct{}{}
}

// ActiveProfileIDCleared returns if the "active_profile_id" field was cleared in this mutation.
func (m *TenderMutation) ActiveProfileIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldActiveProfileID]
	return ok
}

// ResetActiveProfileID resets all changes to the "active_profile_id" field.
func (m *TenderMutation) ResetActiveProfileID() {
	m.active_profile = nil
	delete(m.clearedFields, tender.FieldActiveProfileID)
}

// SetPendingProfileID sets the "pending_profile_id" field.
func (m *TenderMutation) SetPendingProfileID(x xid.ID) {
	m.pending_profile = &x
}

// PendingProfileID returns the value of the "pending_profile_id" field in the mutation.
func (m *TenderMutation) PendingProfileID() (r xid.ID, exists bool) {
	v := m.pending_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldPendingProfileID returns the old "pending_profile_id" field's value of the Tender entity.
// If the Tender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderMutation) OldPendingProfileID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPendingProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPendingProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPendingProfileID: %w", err)
	}
	return oldValue.PendingProfileID, nil
}

// ClearPendingProfileID clears the value of the "pending_profile_id" field.
func (m *TenderMutation) ClearPendingProfileID() {
	m.pending_profile = nil
	m.clearedFields[tender.FieldPendingProfileID] = struct{}{}
}

// PendingProfileIDCleared returns if the "pending_profile_id" field was cleared in this mutation.
func (m *TenderMutation) PendingProfileIDCleared() bool {
	_, ok := m.clearedFields[tender.FieldPendingProfileID]
	return ok
}

// ResetPendingProfileID resets all changes to the "pending_profile_id" field.
func (m *TenderMutation) ResetPendingProfileID() {
	m.pending_profile = nil
	delete(m.clearedFields, tender.FieldPendingProfileID)
}

// ClearArea clears the "area" edge to the Area entity.
func (m *TenderMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[tender.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *TenderMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) AreaIDs() (ids []xid.ID) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *TenderMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// AddProfileIDs adds the "profiles" edge to the TenderProfile entity by ids.
func (m *TenderMutation) AddProfileIDs(ids ...xid.ID) {
	if m.profiles == nil {
		m.profiles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "profiles" edge to the TenderProfile entity.
func (m *TenderMutation) ClearProfiles() {
	m.clearedprofiles = true
}

// ProfilesCleared reports if the "profiles" edge to the TenderProfile entity was cleared.
func (m *TenderMutation) ProfilesCleared() bool {
	return m.clearedprofiles
}

// RemoveProfileIDs removes the "profiles" edge to the TenderProfile entity by IDs.
func (m *TenderMutation) RemoveProfileIDs(ids ...xid.ID) {
	if m.removedprofiles == nil {
		m.removedprofiles = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.profiles, ids[i])
		m.removedprofiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "profiles" edge to the TenderProfile entity.
func (m *TenderMutation) RemovedProfilesIDs() (ids []xid.ID) {
	for id := range m.removedprofiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "profiles" edge IDs in the mutation.
func (m *TenderMutation) ProfilesIDs() (ids []xid.ID) {
	for id := range m.profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "profiles" edge.
func (m *TenderMutation) ResetProfiles() {
	m.profiles = nil
	m.clearedprofiles = false
	m.removedprofiles = nil
}

// AddCompetitorIDs adds the "competitors" edge to the TenderCompetitor entity by ids.
func (m *TenderMutation) AddCompetitorIDs(ids ...xid.ID) {
	if m.competitors == nil {
		m.competitors = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.competitors[ids[i]] = struct{}{}
	}
}

// ClearCompetitors clears the "competitors" edge to the TenderCompetitor entity.
func (m *TenderMutation) ClearCompetitors() {
	m.clearedcompetitors = true
}

// CompetitorsCleared reports if the "competitors" edge to the TenderCompetitor entity was cleared.
func (m *TenderMutation) CompetitorsCleared() bool {
	return m.clearedcompetitors
}

// RemoveCompetitorIDs removes the "competitors" edge to the TenderCompetitor entity by IDs.
func (m *TenderMutation) RemoveCompetitorIDs(ids ...xid.ID) {
	if m.removedcompetitors == nil {
		m.removedcompetitors = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.competitors, ids[i])
		m.removedcompetitors[ids[i]] = struct{}{}
	}
}

// RemovedCompetitors returns the removed IDs of the "competitors" edge to the TenderCompetitor entity.
func (m *TenderMutation) RemovedCompetitorsIDs() (ids []xid.ID) {
	for id := range m.removedcompetitors {
		ids = append(ids, id)
	}
	return
}

// CompetitorsIDs returns the "competitors" edge IDs in the mutation.
func (m *TenderMutation) CompetitorsIDs() (ids []xid.ID) {
	for id := range m.competitors {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitors resets all changes to the "competitors" edge.
func (m *TenderMutation) ResetCompetitors() {
	m.competitors = nil
	m.clearedcompetitors = false
	m.removedcompetitors = nil
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *TenderMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[tender.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *TenderMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *TenderMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearFinder clears the "finder" edge to the User entity.
func (m *TenderMutation) ClearFinder() {
	m.clearedfinder = true
	m.clearedFields[tender.FieldFinderID] = struct{}{}
}

// FinderCleared reports if the "finder" edge to the User entity was cleared.
func (m *TenderMutation) FinderCleared() bool {
	return m.FinderIDCleared() || m.clearedfinder
}

// FinderIDs returns the "finder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FinderID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) FinderIDs() (ids []xid.ID) {
	if id := m.finder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFinder resets all changes to the "finder" edge.
func (m *TenderMutation) ResetFinder() {
	m.finder = nil
	m.clearedfinder = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *TenderMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[tender.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *TenderMutation) CreatedByCleared() bool {
	return m.CreatedByIDCleared() || m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *TenderMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// AddFollowingSaleIDs adds the "following_sales" edge to the User entity by ids.
func (m *TenderMutation) AddFollowingSaleIDs(ids ...xid.ID) {
	if m.following_sales == nil {
		m.following_sales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.following_sales[ids[i]] = struct{}{}
	}
}

// ClearFollowingSales clears the "following_sales" edge to the User entity.
func (m *TenderMutation) ClearFollowingSales() {
	m.clearedfollowing_sales = true
}

// FollowingSalesCleared reports if the "following_sales" edge to the User entity was cleared.
func (m *TenderMutation) FollowingSalesCleared() bool {
	return m.clearedfollowing_sales
}

// RemoveFollowingSaleIDs removes the "following_sales" edge to the User entity by IDs.
func (m *TenderMutation) RemoveFollowingSaleIDs(ids ...xid.ID) {
	if m.removedfollowing_sales == nil {
		m.removedfollowing_sales = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.following_sales, ids[i])
		m.removedfollowing_sales[ids[i]] = struct{}{}
	}
}

// RemovedFollowingSales returns the removed IDs of the "following_sales" edge to the User entity.
func (m *TenderMutation) RemovedFollowingSalesIDs() (ids []xid.ID) {
	for id := range m.removedfollowing_sales {
		ids = append(ids, id)
	}
	return
}

// FollowingSalesIDs returns the "following_sales" edge IDs in the mutation.
func (m *TenderMutation) FollowingSalesIDs() (ids []xid.ID) {
	for id := range m.following_sales {
		ids = append(ids, id)
	}
	return
}

// ResetFollowingSales resets all changes to the "following_sales" edge.
func (m *TenderMutation) ResetFollowingSales() {
	m.following_sales = nil
	m.clearedfollowing_sales = false
	m.removedfollowing_sales = nil
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *TenderMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[tender.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *TenderMutation) ProvinceCleared() bool {
	return m.ProvinceIDCleared() || m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *TenderMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *TenderMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[tender.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *TenderMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) CityIDs() (ids []xid.ID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *TenderMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *TenderMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[tender.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *TenderMutation) DistrictCleared() bool {
	return m.DistrictIDCleared() || m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) DistrictIDs() (ids []xid.ID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *TenderMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *TenderMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *TenderMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *TenderMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *TenderMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *TenderMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *TenderMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *TenderMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// ClearApprover clears the "approver" edge to the User entity.
func (m *TenderMutation) ClearApprover() {
	m.clearedapprover = true
	m.clearedFields[tender.FieldApproverID] = struct{}{}
}

// ApproverCleared reports if the "approver" edge to the User entity was cleared.
func (m *TenderMutation) ApproverCleared() bool {
	return m.ApproverIDCleared() || m.clearedapprover
}

// ApproverIDs returns the "approver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApproverID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) ApproverIDs() (ids []xid.ID) {
	if id := m.approver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprover resets all changes to the "approver" edge.
func (m *TenderMutation) ResetApprover() {
	m.approver = nil
	m.clearedapprover = false
}

// ClearActiveProfile clears the "active_profile" edge to the TenderProfile entity.
func (m *TenderMutation) ClearActiveProfile() {
	m.clearedactive_profile = true
	m.clearedFields[tender.FieldActiveProfileID] = struct{}{}
}

// ActiveProfileCleared reports if the "active_profile" edge to the TenderProfile entity was cleared.
func (m *TenderMutation) ActiveProfileCleared() bool {
	return m.ActiveProfileIDCleared() || m.clearedactive_profile
}

// ActiveProfileIDs returns the "active_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActiveProfileID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) ActiveProfileIDs() (ids []xid.ID) {
	if id := m.active_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActiveProfile resets all changes to the "active_profile" edge.
func (m *TenderMutation) ResetActiveProfile() {
	m.active_profile = nil
	m.clearedactive_profile = false
}

// ClearPendingProfile clears the "pending_profile" edge to the TenderProfile entity.
func (m *TenderMutation) ClearPendingProfile() {
	m.clearedpending_profile = true
	m.clearedFields[tender.FieldPendingProfileID] = struct{}{}
}

// PendingProfileCleared reports if the "pending_profile" edge to the TenderProfile entity was cleared.
func (m *TenderMutation) PendingProfileCleared() bool {
	return m.PendingProfileIDCleared() || m.clearedpending_profile
}

// PendingProfileIDs returns the "pending_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PendingProfileID instead. It exists only for internal usage by the builders.
func (m *TenderMutation) PendingProfileIDs() (ids []xid.ID) {
	if id := m.pending_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPendingProfile resets all changes to the "pending_profile" edge.
func (m *TenderMutation) ResetPendingProfile() {
	m.pending_profile = nil
	m.clearedpending_profile = false
}

// Where appends a list predicates to the TenderMutation builder.
func (m *TenderMutation) Where(ps ...predicate.Tender) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tender, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tender).
func (m *TenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenderMutation) Fields() []string {
	fields := make([]string, 0, 70)
	if m.created_at != nil {
		fields = append(fields, tender.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tender.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, tender.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, tender.FieldStatus)
	}
	if m.approval_status != nil {
		fields = append(fields, tender.FieldApprovalStatus)
	}
	if m.approval_msg_id != nil {
		fields = append(fields, tender.FieldApprovalMsgID)
	}
	if m.name != nil {
		fields = append(fields, tender.FieldName)
	}
	if m.estimated_amount != nil {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.tender_date != nil {
		fields = append(fields, tender.FieldTenderDate)
	}
	if m.classify != nil {
		fields = append(fields, tender.FieldClassify)
	}
	if m.discovery_date != nil {
		fields = append(fields, tender.FieldDiscoveryDate)
	}
	if m.address != nil {
		fields = append(fields, tender.FieldAddress)
	}
	if m.full_address != nil {
		fields = append(fields, tender.FieldFullAddress)
	}
	if m.contractor != nil {
		fields = append(fields, tender.FieldContractor)
	}
	if m.level_involved != nil {
		fields = append(fields, tender.FieldLevelInvolved)
	}
	if m.size_and_value_rating != nil {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.size_and_value_rating_overview != nil {
		fields = append(fields, tender.FieldSizeAndValueRatingOverview)
	}
	if m.credit_and_payment_rating != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.credit_and_payment_rating_overview != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRatingOverview)
	}
	if m.time_limit_rating != nil {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.time_limit_rating_overview != nil {
		fields = append(fields, tender.FieldTimeLimitRatingOverview)
	}
	if m.customer_relationship_rating != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.customer_relationship_rating_overview != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRatingOverview)
	}
	if m.competitive_partnership_rating != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.competitive_partnership_rating_overview != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRatingOverview)
	}
	if m.prepare_to_bid != nil {
		fields = append(fields, tender.FieldPrepareToBid)
	}
	if m.project_code != nil {
		fields = append(fields, tender.FieldProjectCode)
	}
	if m.project_type != nil {
		fields = append(fields, tender.FieldProjectType)
	}
	if m.project_definition != nil {
		fields = append(fields, tender.FieldProjectDefinition)
	}
	if m.estimated_project_start_date != nil {
		fields = append(fields, tender.FieldEstimatedProjectStartDate)
	}
	if m.estimated_project_end_date != nil {
		fields = append(fields, tender.FieldEstimatedProjectEndDate)
	}
	if m.attachements != nil {
		fields = append(fields, tender.FieldAttachements)
	}
	if m.geo_coordinate != nil {
		fields = append(fields, tender.FieldGeoCoordinate)
	}
	if m.geo_bounds != nil {
		fields = append(fields, tender.FieldGeoBounds)
	}
	if m.remark != nil {
		fields = append(fields, tender.FieldRemark)
	}
	if m.images != nil {
		fields = append(fields, tender.FieldImages)
	}
	if m.tender_situations != nil {
		fields = append(fields, tender.FieldTenderSituations)
	}
	if m.owner_situations != nil {
		fields = append(fields, tender.FieldOwnerSituations)
	}
	if m.bidding_instructions != nil {
		fields = append(fields, tender.FieldBiddingInstructions)
	}
	if m.competitor_situations != nil {
		fields = append(fields, tender.FieldCompetitorSituations)
	}
	if m.cost_engineer != nil {
		fields = append(fields, tender.FieldCostEngineer)
	}
	if m.tender_form != nil {
		fields = append(fields, tender.FieldTenderForm)
	}
	if m.contract_form != nil {
		fields = append(fields, tender.FieldContractForm)
	}
	if m.management_company != nil {
		fields = append(fields, tender.FieldManagementCompany)
	}
	if m.tendering_agency != nil {
		fields = append(fields, tender.FieldTenderingAgency)
	}
	if m.bidding_date != nil {
		fields = append(fields, tender.FieldBiddingDate)
	}
	if m.facade_consultant != nil {
		fields = append(fields, tender.FieldFacadeConsultant)
	}
	if m.design_unit != nil {
		fields = append(fields, tender.FieldDesignUnit)
	}
	if m.consulting_firm != nil {
		fields = append(fields, tender.FieldConsultingFirm)
	}
	if m.key_project != nil {
		fields = append(fields, tender.FieldKeyProject)
	}
	if m.current_progress != nil {
		fields = append(fields, tender.FieldCurrentProgress)
	}
	if m.tender_win_company != nil {
		fields = append(fields, tender.FieldTenderWinCompany)
	}
	if m.tender_code != nil {
		fields = append(fields, tender.FieldTenderCode)
	}
	if m.architect != nil {
		fields = append(fields, tender.FieldArchitect)
	}
	if m.developer != nil {
		fields = append(fields, tender.FieldDeveloper)
	}
	if m.tender_closing_date != nil {
		fields = append(fields, tender.FieldTenderClosingDate)
	}
	if m.construction_area != nil {
		fields = append(fields, tender.FieldConstructionArea)
	}
	if m.tender_win_date != nil {
		fields = append(fields, tender.FieldTenderWinDate)
	}
	if m.tender_win_amount != nil {
		fields = append(fields, tender.FieldTenderWinAmount)
	}
	if m.last_tender_amount != nil {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	if m.area != nil {
		fields = append(fields, tender.FieldAreaID)
	}
	if m.province != nil {
		fields = append(fields, tender.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, tender.FieldCityID)
	}
	if m.district != nil {
		fields = append(fields, tender.FieldDistrictID)
	}
	if m.customer != nil {
		fields = append(fields, tender.FieldCustomerID)
	}
	if m.finder != nil {
		fields = append(fields, tender.FieldFinderID)
	}
	if m.created_by != nil {
		fields = append(fields, tender.FieldCreatedByID)
	}
	if m.approver != nil {
		fields = append(fields, tender.FieldApproverID)
	}
	if m.active_profile != nil {
		fields = append(fields, tender.FieldActiveProfileID)
	}
	if m.pending_profile != nil {
		fields = append(fields, tender.FieldPendingProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tender.FieldCreatedAt:
		return m.CreatedAt()
	case tender.FieldUpdatedAt:
		return m.UpdatedAt()
	case tender.FieldCode:
		return m.Code()
	case tender.FieldStatus:
		return m.Status()
	case tender.FieldApprovalStatus:
		return m.ApprovalStatus()
	case tender.FieldApprovalMsgID:
		return m.ApprovalMsgID()
	case tender.FieldName:
		return m.Name()
	case tender.FieldEstimatedAmount:
		return m.EstimatedAmount()
	case tender.FieldTenderDate:
		return m.TenderDate()
	case tender.FieldClassify:
		return m.Classify()
	case tender.FieldDiscoveryDate:
		return m.DiscoveryDate()
	case tender.FieldAddress:
		return m.Address()
	case tender.FieldFullAddress:
		return m.FullAddress()
	case tender.FieldContractor:
		return m.Contractor()
	case tender.FieldLevelInvolved:
		return m.LevelInvolved()
	case tender.FieldSizeAndValueRating:
		return m.SizeAndValueRating()
	case tender.FieldSizeAndValueRatingOverview:
		return m.SizeAndValueRatingOverview()
	case tender.FieldCreditAndPaymentRating:
		return m.CreditAndPaymentRating()
	case tender.FieldCreditAndPaymentRatingOverview:
		return m.CreditAndPaymentRatingOverview()
	case tender.FieldTimeLimitRating:
		return m.TimeLimitRating()
	case tender.FieldTimeLimitRatingOverview:
		return m.TimeLimitRatingOverview()
	case tender.FieldCustomerRelationshipRating:
		return m.CustomerRelationshipRating()
	case tender.FieldCustomerRelationshipRatingOverview:
		return m.CustomerRelationshipRatingOverview()
	case tender.FieldCompetitivePartnershipRating:
		return m.CompetitivePartnershipRating()
	case tender.FieldCompetitivePartnershipRatingOverview:
		return m.CompetitivePartnershipRatingOverview()
	case tender.FieldPrepareToBid:
		return m.PrepareToBid()
	case tender.FieldProjectCode:
		return m.ProjectCode()
	case tender.FieldProjectType:
		return m.ProjectType()
	case tender.FieldProjectDefinition:
		return m.ProjectDefinition()
	case tender.FieldEstimatedProjectStartDate:
		return m.EstimatedProjectStartDate()
	case tender.FieldEstimatedProjectEndDate:
		return m.EstimatedProjectEndDate()
	case tender.FieldAttachements:
		return m.Attachements()
	case tender.FieldGeoCoordinate:
		return m.GeoCoordinate()
	case tender.FieldGeoBounds:
		return m.GeoBounds()
	case tender.FieldRemark:
		return m.Remark()
	case tender.FieldImages:
		return m.Images()
	case tender.FieldTenderSituations:
		return m.TenderSituations()
	case tender.FieldOwnerSituations:
		return m.OwnerSituations()
	case tender.FieldBiddingInstructions:
		return m.BiddingInstructions()
	case tender.FieldCompetitorSituations:
		return m.CompetitorSituations()
	case tender.FieldCostEngineer:
		return m.CostEngineer()
	case tender.FieldTenderForm:
		return m.TenderForm()
	case tender.FieldContractForm:
		return m.ContractForm()
	case tender.FieldManagementCompany:
		return m.ManagementCompany()
	case tender.FieldTenderingAgency:
		return m.TenderingAgency()
	case tender.FieldBiddingDate:
		return m.BiddingDate()
	case tender.FieldFacadeConsultant:
		return m.FacadeConsultant()
	case tender.FieldDesignUnit:
		return m.DesignUnit()
	case tender.FieldConsultingFirm:
		return m.ConsultingFirm()
	case tender.FieldKeyProject:
		return m.KeyProject()
	case tender.FieldCurrentProgress:
		return m.CurrentProgress()
	case tender.FieldTenderWinCompany:
		return m.TenderWinCompany()
	case tender.FieldTenderCode:
		return m.TenderCode()
	case tender.FieldArchitect:
		return m.Architect()
	case tender.FieldDeveloper:
		return m.Developer()
	case tender.FieldTenderClosingDate:
		return m.TenderClosingDate()
	case tender.FieldConstructionArea:
		return m.ConstructionArea()
	case tender.FieldTenderWinDate:
		return m.TenderWinDate()
	case tender.FieldTenderWinAmount:
		return m.TenderWinAmount()
	case tender.FieldLastTenderAmount:
		return m.LastTenderAmount()
	case tender.FieldAreaID:
		return m.AreaID()
	case tender.FieldProvinceID:
		return m.ProvinceID()
	case tender.FieldCityID:
		return m.CityID()
	case tender.FieldDistrictID:
		return m.DistrictID()
	case tender.FieldCustomerID:
		return m.CustomerID()
	case tender.FieldFinderID:
		return m.FinderID()
	case tender.FieldCreatedByID:
		return m.CreatedByID()
	case tender.FieldApproverID:
		return m.ApproverID()
	case tender.FieldActiveProfileID:
		return m.ActiveProfileID()
	case tender.FieldPendingProfileID:
		return m.PendingProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tender.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tender.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tender.FieldCode:
		return m.OldCode(ctx)
	case tender.FieldStatus:
		return m.OldStatus(ctx)
	case tender.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case tender.FieldApprovalMsgID:
		return m.OldApprovalMsgID(ctx)
	case tender.FieldName:
		return m.OldName(ctx)
	case tender.FieldEstimatedAmount:
		return m.OldEstimatedAmount(ctx)
	case tender.FieldTenderDate:
		return m.OldTenderDate(ctx)
	case tender.FieldClassify:
		return m.OldClassify(ctx)
	case tender.FieldDiscoveryDate:
		return m.OldDiscoveryDate(ctx)
	case tender.FieldAddress:
		return m.OldAddress(ctx)
	case tender.FieldFullAddress:
		return m.OldFullAddress(ctx)
	case tender.FieldContractor:
		return m.OldContractor(ctx)
	case tender.FieldLevelInvolved:
		return m.OldLevelInvolved(ctx)
	case tender.FieldSizeAndValueRating:
		return m.OldSizeAndValueRating(ctx)
	case tender.FieldSizeAndValueRatingOverview:
		return m.OldSizeAndValueRatingOverview(ctx)
	case tender.FieldCreditAndPaymentRating:
		return m.OldCreditAndPaymentRating(ctx)
	case tender.FieldCreditAndPaymentRatingOverview:
		return m.OldCreditAndPaymentRatingOverview(ctx)
	case tender.FieldTimeLimitRating:
		return m.OldTimeLimitRating(ctx)
	case tender.FieldTimeLimitRatingOverview:
		return m.OldTimeLimitRatingOverview(ctx)
	case tender.FieldCustomerRelationshipRating:
		return m.OldCustomerRelationshipRating(ctx)
	case tender.FieldCustomerRelationshipRatingOverview:
		return m.OldCustomerRelationshipRatingOverview(ctx)
	case tender.FieldCompetitivePartnershipRating:
		return m.OldCompetitivePartnershipRating(ctx)
	case tender.FieldCompetitivePartnershipRatingOverview:
		return m.OldCompetitivePartnershipRatingOverview(ctx)
	case tender.FieldPrepareToBid:
		return m.OldPrepareToBid(ctx)
	case tender.FieldProjectCode:
		return m.OldProjectCode(ctx)
	case tender.FieldProjectType:
		return m.OldProjectType(ctx)
	case tender.FieldProjectDefinition:
		return m.OldProjectDefinition(ctx)
	case tender.FieldEstimatedProjectStartDate:
		return m.OldEstimatedProjectStartDate(ctx)
	case tender.FieldEstimatedProjectEndDate:
		return m.OldEstimatedProjectEndDate(ctx)
	case tender.FieldAttachements:
		return m.OldAttachements(ctx)
	case tender.FieldGeoCoordinate:
		return m.OldGeoCoordinate(ctx)
	case tender.FieldGeoBounds:
		return m.OldGeoBounds(ctx)
	case tender.FieldRemark:
		return m.OldRemark(ctx)
	case tender.FieldImages:
		return m.OldImages(ctx)
	case tender.FieldTenderSituations:
		return m.OldTenderSituations(ctx)
	case tender.FieldOwnerSituations:
		return m.OldOwnerSituations(ctx)
	case tender.FieldBiddingInstructions:
		return m.OldBiddingInstructions(ctx)
	case tender.FieldCompetitorSituations:
		return m.OldCompetitorSituations(ctx)
	case tender.FieldCostEngineer:
		return m.OldCostEngineer(ctx)
	case tender.FieldTenderForm:
		return m.OldTenderForm(ctx)
	case tender.FieldContractForm:
		return m.OldContractForm(ctx)
	case tender.FieldManagementCompany:
		return m.OldManagementCompany(ctx)
	case tender.FieldTenderingAgency:
		return m.OldTenderingAgency(ctx)
	case tender.FieldBiddingDate:
		return m.OldBiddingDate(ctx)
	case tender.FieldFacadeConsultant:
		return m.OldFacadeConsultant(ctx)
	case tender.FieldDesignUnit:
		return m.OldDesignUnit(ctx)
	case tender.FieldConsultingFirm:
		return m.OldConsultingFirm(ctx)
	case tender.FieldKeyProject:
		return m.OldKeyProject(ctx)
	case tender.FieldCurrentProgress:
		return m.OldCurrentProgress(ctx)
	case tender.FieldTenderWinCompany:
		return m.OldTenderWinCompany(ctx)
	case tender.FieldTenderCode:
		return m.OldTenderCode(ctx)
	case tender.FieldArchitect:
		return m.OldArchitect(ctx)
	case tender.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case tender.FieldTenderClosingDate:
		return m.OldTenderClosingDate(ctx)
	case tender.FieldConstructionArea:
		return m.OldConstructionArea(ctx)
	case tender.FieldTenderWinDate:
		return m.OldTenderWinDate(ctx)
	case tender.FieldTenderWinAmount:
		return m.OldTenderWinAmount(ctx)
	case tender.FieldLastTenderAmount:
		return m.OldLastTenderAmount(ctx)
	case tender.FieldAreaID:
		return m.OldAreaID(ctx)
	case tender.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case tender.FieldCityID:
		return m.OldCityID(ctx)
	case tender.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case tender.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case tender.FieldFinderID:
		return m.OldFinderID(ctx)
	case tender.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	case tender.FieldApproverID:
		return m.OldApproverID(ctx)
	case tender.FieldActiveProfileID:
		return m.OldActiveProfileID(ctx)
	case tender.FieldPendingProfileID:
		return m.OldPendingProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown Tender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tender.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tender.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tender.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tender.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tender.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case tender.FieldApprovalMsgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalMsgID(v)
		return nil
	case tender.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tender.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedAmount(v)
		return nil
	case tender.FieldTenderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderDate(v)
		return nil
	case tender.FieldClassify:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassify(v)
		return nil
	case tender.FieldDiscoveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryDate(v)
		return nil
	case tender.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tender.FieldFullAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullAddress(v)
		return nil
	case tender.FieldContractor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractor(v)
		return nil
	case tender.FieldLevelInvolved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelInvolved(v)
		return nil
	case tender.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRating(v)
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRatingOverview(v)
		return nil
	case tender.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRating(v)
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRatingOverview(v)
		return nil
	case tender.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRating(v)
		return nil
	case tender.FieldTimeLimitRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRatingOverview(v)
		return nil
	case tender.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRating(v)
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRatingOverview(v)
		return nil
	case tender.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRating(v)
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRatingOverview(v)
		return nil
	case tender.FieldPrepareToBid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepareToBid(v)
		return nil
	case tender.FieldProjectCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectCode(v)
		return nil
	case tender.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case tender.FieldProjectDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectDefinition(v)
		return nil
	case tender.FieldEstimatedProjectStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectStartDate(v)
		return nil
	case tender.FieldEstimatedProjectEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectEndDate(v)
		return nil
	case tender.FieldAttachements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachements(v)
		return nil
	case tender.FieldGeoCoordinate:
		v, ok := value.(*geo.GeoJson)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoCoordinate(v)
		return nil
	case tender.FieldGeoBounds:
		v, ok := value.([][]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoBounds(v)
		return nil
	case tender.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case tender.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case tender.FieldTenderSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderSituations(v)
		return nil
	case tender.FieldOwnerSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSituations(v)
		return nil
	case tender.FieldBiddingInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingInstructions(v)
		return nil
	case tender.FieldCompetitorSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitorSituations(v)
		return nil
	case tender.FieldCostEngineer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostEngineer(v)
		return nil
	case tender.FieldTenderForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderForm(v)
		return nil
	case tender.FieldContractForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractForm(v)
		return nil
	case tender.FieldManagementCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementCompany(v)
		return nil
	case tender.FieldTenderingAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderingAgency(v)
		return nil
	case tender.FieldBiddingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingDate(v)
		return nil
	case tender.FieldFacadeConsultant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacadeConsultant(v)
		return nil
	case tender.FieldDesignUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignUnit(v)
		return nil
	case tender.FieldConsultingFirm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsultingFirm(v)
		return nil
	case tender.FieldKeyProject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyProject(v)
		return nil
	case tender.FieldCurrentProgress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentProgress(v)
		return nil
	case tender.FieldTenderWinCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinCompany(v)
		return nil
	case tender.FieldTenderCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderCode(v)
		return nil
	case tender.FieldArchitect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitect(v)
		return nil
	case tender.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case tender.FieldTenderClosingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderClosingDate(v)
		return nil
	case tender.FieldConstructionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionArea(v)
		return nil
	case tender.FieldTenderWinDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinDate(v)
		return nil
	case tender.FieldTenderWinAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinAmount(v)
		return nil
	case tender.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTenderAmount(v)
		return nil
	case tender.FieldAreaID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case tender.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case tender.FieldCityID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case tender.FieldDistrictID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case tender.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case tender.FieldFinderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinderID(v)
		return nil
	case tender.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	case tender.FieldApproverID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	case tender.FieldActiveProfileID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveProfileID(v)
		return nil
	case tender.FieldPendingProfileID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPendingProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown Tender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tender.FieldStatus)
	}
	if m.addapproval_status != nil {
		fields = append(fields, tender.FieldApprovalStatus)
	}
	if m.addestimated_amount != nil {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.addclassify != nil {
		fields = append(fields, tender.FieldClassify)
	}
	if m.addlevel_involved != nil {
		fields = append(fields, tender.FieldLevelInvolved)
	}
	if m.addsize_and_value_rating != nil {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.addcredit_and_payment_rating != nil {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.addtime_limit_rating != nil {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.addcustomer_relationship_rating != nil {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.addcompetitive_partnership_rating != nil {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.addtender_win_amount != nil {
		fields = append(fields, tender.FieldTenderWinAmount)
	}
	if m.addlast_tender_amount != nil {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tender.FieldStatus:
		return m.AddedStatus()
	case tender.FieldApprovalStatus:
		return m.AddedApprovalStatus()
	case tender.FieldEstimatedAmount:
		return m.AddedEstimatedAmount()
	case tender.FieldClassify:
		return m.AddedClassify()
	case tender.FieldLevelInvolved:
		return m.AddedLevelInvolved()
	case tender.FieldSizeAndValueRating:
		return m.AddedSizeAndValueRating()
	case tender.FieldCreditAndPaymentRating:
		return m.AddedCreditAndPaymentRating()
	case tender.FieldTimeLimitRating:
		return m.AddedTimeLimitRating()
	case tender.FieldCustomerRelationshipRating:
		return m.AddedCustomerRelationshipRating()
	case tender.FieldCompetitivePartnershipRating:
		return m.AddedCompetitivePartnershipRating()
	case tender.FieldTenderWinAmount:
		return m.AddedTenderWinAmount()
	case tender.FieldLastTenderAmount:
		return m.AddedLastTenderAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tender.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tender.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovalStatus(v)
		return nil
	case tender.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedAmount(v)
		return nil
	case tender.FieldClassify:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassify(v)
		return nil
	case tender.FieldLevelInvolved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevelInvolved(v)
		return nil
	case tender.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeAndValueRating(v)
		return nil
	case tender.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAndPaymentRating(v)
		return nil
	case tender.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeLimitRating(v)
		return nil
	case tender.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerRelationshipRating(v)
		return nil
	case tender.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompetitivePartnershipRating(v)
		return nil
	case tender.FieldTenderWinAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenderWinAmount(v)
		return nil
	case tender.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastTenderAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Tender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tender.FieldApprovalMsgID) {
		fields = append(fields, tender.FieldApprovalMsgID)
	}
	if m.FieldCleared(tender.FieldEstimatedAmount) {
		fields = append(fields, tender.FieldEstimatedAmount)
	}
	if m.FieldCleared(tender.FieldTenderDate) {
		fields = append(fields, tender.FieldTenderDate)
	}
	if m.FieldCleared(tender.FieldClassify) {
		fields = append(fields, tender.FieldClassify)
	}
	if m.FieldCleared(tender.FieldAddress) {
		fields = append(fields, tender.FieldAddress)
	}
	if m.FieldCleared(tender.FieldFullAddress) {
		fields = append(fields, tender.FieldFullAddress)
	}
	if m.FieldCleared(tender.FieldContractor) {
		fields = append(fields, tender.FieldContractor)
	}
	if m.FieldCleared(tender.FieldLevelInvolved) {
		fields = append(fields, tender.FieldLevelInvolved)
	}
	if m.FieldCleared(tender.FieldSizeAndValueRating) {
		fields = append(fields, tender.FieldSizeAndValueRating)
	}
	if m.FieldCleared(tender.FieldSizeAndValueRatingOverview) {
		fields = append(fields, tender.FieldSizeAndValueRatingOverview)
	}
	if m.FieldCleared(tender.FieldCreditAndPaymentRating) {
		fields = append(fields, tender.FieldCreditAndPaymentRating)
	}
	if m.FieldCleared(tender.FieldCreditAndPaymentRatingOverview) {
		fields = append(fields, tender.FieldCreditAndPaymentRatingOverview)
	}
	if m.FieldCleared(tender.FieldTimeLimitRating) {
		fields = append(fields, tender.FieldTimeLimitRating)
	}
	if m.FieldCleared(tender.FieldTimeLimitRatingOverview) {
		fields = append(fields, tender.FieldTimeLimitRatingOverview)
	}
	if m.FieldCleared(tender.FieldCustomerRelationshipRating) {
		fields = append(fields, tender.FieldCustomerRelationshipRating)
	}
	if m.FieldCleared(tender.FieldCustomerRelationshipRatingOverview) {
		fields = append(fields, tender.FieldCustomerRelationshipRatingOverview)
	}
	if m.FieldCleared(tender.FieldCompetitivePartnershipRating) {
		fields = append(fields, tender.FieldCompetitivePartnershipRating)
	}
	if m.FieldCleared(tender.FieldCompetitivePartnershipRatingOverview) {
		fields = append(fields, tender.FieldCompetitivePartnershipRatingOverview)
	}
	if m.FieldCleared(tender.FieldProjectCode) {
		fields = append(fields, tender.FieldProjectCode)
	}
	if m.FieldCleared(tender.FieldProjectType) {
		fields = append(fields, tender.FieldProjectType)
	}
	if m.FieldCleared(tender.FieldProjectDefinition) {
		fields = append(fields, tender.FieldProjectDefinition)
	}
	if m.FieldCleared(tender.FieldEstimatedProjectStartDate) {
		fields = append(fields, tender.FieldEstimatedProjectStartDate)
	}
	if m.FieldCleared(tender.FieldEstimatedProjectEndDate) {
		fields = append(fields, tender.FieldEstimatedProjectEndDate)
	}
	if m.FieldCleared(tender.FieldAttachements) {
		fields = append(fields, tender.FieldAttachements)
	}
	if m.FieldCleared(tender.FieldGeoCoordinate) {
		fields = append(fields, tender.FieldGeoCoordinate)
	}
	if m.FieldCleared(tender.FieldGeoBounds) {
		fields = append(fields, tender.FieldGeoBounds)
	}
	if m.FieldCleared(tender.FieldRemark) {
		fields = append(fields, tender.FieldRemark)
	}
	if m.FieldCleared(tender.FieldImages) {
		fields = append(fields, tender.FieldImages)
	}
	if m.FieldCleared(tender.FieldTenderSituations) {
		fields = append(fields, tender.FieldTenderSituations)
	}
	if m.FieldCleared(tender.FieldOwnerSituations) {
		fields = append(fields, tender.FieldOwnerSituations)
	}
	if m.FieldCleared(tender.FieldBiddingInstructions) {
		fields = append(fields, tender.FieldBiddingInstructions)
	}
	if m.FieldCleared(tender.FieldCompetitorSituations) {
		fields = append(fields, tender.FieldCompetitorSituations)
	}
	if m.FieldCleared(tender.FieldCostEngineer) {
		fields = append(fields, tender.FieldCostEngineer)
	}
	if m.FieldCleared(tender.FieldTenderForm) {
		fields = append(fields, tender.FieldTenderForm)
	}
	if m.FieldCleared(tender.FieldContractForm) {
		fields = append(fields, tender.FieldContractForm)
	}
	if m.FieldCleared(tender.FieldManagementCompany) {
		fields = append(fields, tender.FieldManagementCompany)
	}
	if m.FieldCleared(tender.FieldTenderingAgency) {
		fields = append(fields, tender.FieldTenderingAgency)
	}
	if m.FieldCleared(tender.FieldBiddingDate) {
		fields = append(fields, tender.FieldBiddingDate)
	}
	if m.FieldCleared(tender.FieldFacadeConsultant) {
		fields = append(fields, tender.FieldFacadeConsultant)
	}
	if m.FieldCleared(tender.FieldDesignUnit) {
		fields = append(fields, tender.FieldDesignUnit)
	}
	if m.FieldCleared(tender.FieldConsultingFirm) {
		fields = append(fields, tender.FieldConsultingFirm)
	}
	if m.FieldCleared(tender.FieldCurrentProgress) {
		fields = append(fields, tender.FieldCurrentProgress)
	}
	if m.FieldCleared(tender.FieldTenderWinCompany) {
		fields = append(fields, tender.FieldTenderWinCompany)
	}
	if m.FieldCleared(tender.FieldTenderCode) {
		fields = append(fields, tender.FieldTenderCode)
	}
	if m.FieldCleared(tender.FieldArchitect) {
		fields = append(fields, tender.FieldArchitect)
	}
	if m.FieldCleared(tender.FieldDeveloper) {
		fields = append(fields, tender.FieldDeveloper)
	}
	if m.FieldCleared(tender.FieldTenderClosingDate) {
		fields = append(fields, tender.FieldTenderClosingDate)
	}
	if m.FieldCleared(tender.FieldConstructionArea) {
		fields = append(fields, tender.FieldConstructionArea)
	}
	if m.FieldCleared(tender.FieldTenderWinDate) {
		fields = append(fields, tender.FieldTenderWinDate)
	}
	if m.FieldCleared(tender.FieldTenderWinAmount) {
		fields = append(fields, tender.FieldTenderWinAmount)
	}
	if m.FieldCleared(tender.FieldLastTenderAmount) {
		fields = append(fields, tender.FieldLastTenderAmount)
	}
	if m.FieldCleared(tender.FieldProvinceID) {
		fields = append(fields, tender.FieldProvinceID)
	}
	if m.FieldCleared(tender.FieldCityID) {
		fields = append(fields, tender.FieldCityID)
	}
	if m.FieldCleared(tender.FieldDistrictID) {
		fields = append(fields, tender.FieldDistrictID)
	}
	if m.FieldCleared(tender.FieldCustomerID) {
		fields = append(fields, tender.FieldCustomerID)
	}
	if m.FieldCleared(tender.FieldFinderID) {
		fields = append(fields, tender.FieldFinderID)
	}
	if m.FieldCleared(tender.FieldCreatedByID) {
		fields = append(fields, tender.FieldCreatedByID)
	}
	if m.FieldCleared(tender.FieldApproverID) {
		fields = append(fields, tender.FieldApproverID)
	}
	if m.FieldCleared(tender.FieldActiveProfileID) {
		fields = append(fields, tender.FieldActiveProfileID)
	}
	if m.FieldCleared(tender.FieldPendingProfileID) {
		fields = append(fields, tender.FieldPendingProfileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenderMutation) ClearField(name string) error {
	switch name {
	case tender.FieldApprovalMsgID:
		m.ClearApprovalMsgID()
		return nil
	case tender.FieldEstimatedAmount:
		m.ClearEstimatedAmount()
		return nil
	case tender.FieldTenderDate:
		m.ClearTenderDate()
		return nil
	case tender.FieldClassify:
		m.ClearClassify()
		return nil
	case tender.FieldAddress:
		m.ClearAddress()
		return nil
	case tender.FieldFullAddress:
		m.ClearFullAddress()
		return nil
	case tender.FieldContractor:
		m.ClearContractor()
		return nil
	case tender.FieldLevelInvolved:
		m.ClearLevelInvolved()
		return nil
	case tender.FieldSizeAndValueRating:
		m.ClearSizeAndValueRating()
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		m.ClearSizeAndValueRatingOverview()
		return nil
	case tender.FieldCreditAndPaymentRating:
		m.ClearCreditAndPaymentRating()
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		m.ClearCreditAndPaymentRatingOverview()
		return nil
	case tender.FieldTimeLimitRating:
		m.ClearTimeLimitRating()
		return nil
	case tender.FieldTimeLimitRatingOverview:
		m.ClearTimeLimitRatingOverview()
		return nil
	case tender.FieldCustomerRelationshipRating:
		m.ClearCustomerRelationshipRating()
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		m.ClearCustomerRelationshipRatingOverview()
		return nil
	case tender.FieldCompetitivePartnershipRating:
		m.ClearCompetitivePartnershipRating()
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		m.ClearCompetitivePartnershipRatingOverview()
		return nil
	case tender.FieldProjectCode:
		m.ClearProjectCode()
		return nil
	case tender.FieldProjectType:
		m.ClearProjectType()
		return nil
	case tender.FieldProjectDefinition:
		m.ClearProjectDefinition()
		return nil
	case tender.FieldEstimatedProjectStartDate:
		m.ClearEstimatedProjectStartDate()
		return nil
	case tender.FieldEstimatedProjectEndDate:
		m.ClearEstimatedProjectEndDate()
		return nil
	case tender.FieldAttachements:
		m.ClearAttachements()
		return nil
	case tender.FieldGeoCoordinate:
		m.ClearGeoCoordinate()
		return nil
	case tender.FieldGeoBounds:
		m.ClearGeoBounds()
		return nil
	case tender.FieldRemark:
		m.ClearRemark()
		return nil
	case tender.FieldImages:
		m.ClearImages()
		return nil
	case tender.FieldTenderSituations:
		m.ClearTenderSituations()
		return nil
	case tender.FieldOwnerSituations:
		m.ClearOwnerSituations()
		return nil
	case tender.FieldBiddingInstructions:
		m.ClearBiddingInstructions()
		return nil
	case tender.FieldCompetitorSituations:
		m.ClearCompetitorSituations()
		return nil
	case tender.FieldCostEngineer:
		m.ClearCostEngineer()
		return nil
	case tender.FieldTenderForm:
		m.ClearTenderForm()
		return nil
	case tender.FieldContractForm:
		m.ClearContractForm()
		return nil
	case tender.FieldManagementCompany:
		m.ClearManagementCompany()
		return nil
	case tender.FieldTenderingAgency:
		m.ClearTenderingAgency()
		return nil
	case tender.FieldBiddingDate:
		m.ClearBiddingDate()
		return nil
	case tender.FieldFacadeConsultant:
		m.ClearFacadeConsultant()
		return nil
	case tender.FieldDesignUnit:
		m.ClearDesignUnit()
		return nil
	case tender.FieldConsultingFirm:
		m.ClearConsultingFirm()
		return nil
	case tender.FieldCurrentProgress:
		m.ClearCurrentProgress()
		return nil
	case tender.FieldTenderWinCompany:
		m.ClearTenderWinCompany()
		return nil
	case tender.FieldTenderCode:
		m.ClearTenderCode()
		return nil
	case tender.FieldArchitect:
		m.ClearArchitect()
		return nil
	case tender.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case tender.FieldTenderClosingDate:
		m.ClearTenderClosingDate()
		return nil
	case tender.FieldConstructionArea:
		m.ClearConstructionArea()
		return nil
	case tender.FieldTenderWinDate:
		m.ClearTenderWinDate()
		return nil
	case tender.FieldTenderWinAmount:
		m.ClearTenderWinAmount()
		return nil
	case tender.FieldLastTenderAmount:
		m.ClearLastTenderAmount()
		return nil
	case tender.FieldProvinceID:
		m.ClearProvinceID()
		return nil
	case tender.FieldCityID:
		m.ClearCityID()
		return nil
	case tender.FieldDistrictID:
		m.ClearDistrictID()
		return nil
	case tender.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case tender.FieldFinderID:
		m.ClearFinderID()
		return nil
	case tender.FieldCreatedByID:
		m.ClearCreatedByID()
		return nil
	case tender.FieldApproverID:
		m.ClearApproverID()
		return nil
	case tender.FieldActiveProfileID:
		m.ClearActiveProfileID()
		return nil
	case tender.FieldPendingProfileID:
		m.ClearPendingProfileID()
		return nil
	}
	return fmt.Errorf("unknown Tender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenderMutation) ResetField(name string) error {
	switch name {
	case tender.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tender.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tender.FieldCode:
		m.ResetCode()
		return nil
	case tender.FieldStatus:
		m.ResetStatus()
		return nil
	case tender.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case tender.FieldApprovalMsgID:
		m.ResetApprovalMsgID()
		return nil
	case tender.FieldName:
		m.ResetName()
		return nil
	case tender.FieldEstimatedAmount:
		m.ResetEstimatedAmount()
		return nil
	case tender.FieldTenderDate:
		m.ResetTenderDate()
		return nil
	case tender.FieldClassify:
		m.ResetClassify()
		return nil
	case tender.FieldDiscoveryDate:
		m.ResetDiscoveryDate()
		return nil
	case tender.FieldAddress:
		m.ResetAddress()
		return nil
	case tender.FieldFullAddress:
		m.ResetFullAddress()
		return nil
	case tender.FieldContractor:
		m.ResetContractor()
		return nil
	case tender.FieldLevelInvolved:
		m.ResetLevelInvolved()
		return nil
	case tender.FieldSizeAndValueRating:
		m.ResetSizeAndValueRating()
		return nil
	case tender.FieldSizeAndValueRatingOverview:
		m.ResetSizeAndValueRatingOverview()
		return nil
	case tender.FieldCreditAndPaymentRating:
		m.ResetCreditAndPaymentRating()
		return nil
	case tender.FieldCreditAndPaymentRatingOverview:
		m.ResetCreditAndPaymentRatingOverview()
		return nil
	case tender.FieldTimeLimitRating:
		m.ResetTimeLimitRating()
		return nil
	case tender.FieldTimeLimitRatingOverview:
		m.ResetTimeLimitRatingOverview()
		return nil
	case tender.FieldCustomerRelationshipRating:
		m.ResetCustomerRelationshipRating()
		return nil
	case tender.FieldCustomerRelationshipRatingOverview:
		m.ResetCustomerRelationshipRatingOverview()
		return nil
	case tender.FieldCompetitivePartnershipRating:
		m.ResetCompetitivePartnershipRating()
		return nil
	case tender.FieldCompetitivePartnershipRatingOverview:
		m.ResetCompetitivePartnershipRatingOverview()
		return nil
	case tender.FieldPrepareToBid:
		m.ResetPrepareToBid()
		return nil
	case tender.FieldProjectCode:
		m.ResetProjectCode()
		return nil
	case tender.FieldProjectType:
		m.ResetProjectType()
		return nil
	case tender.FieldProjectDefinition:
		m.ResetProjectDefinition()
		return nil
	case tender.FieldEstimatedProjectStartDate:
		m.ResetEstimatedProjectStartDate()
		return nil
	case tender.FieldEstimatedProjectEndDate:
		m.ResetEstimatedProjectEndDate()
		return nil
	case tender.FieldAttachements:
		m.ResetAttachements()
		return nil
	case tender.FieldGeoCoordinate:
		m.ResetGeoCoordinate()
		return nil
	case tender.FieldGeoBounds:
		m.ResetGeoBounds()
		return nil
	case tender.FieldRemark:
		m.ResetRemark()
		return nil
	case tender.FieldImages:
		m.ResetImages()
		return nil
	case tender.FieldTenderSituations:
		m.ResetTenderSituations()
		return nil
	case tender.FieldOwnerSituations:
		m.ResetOwnerSituations()
		return nil
	case tender.FieldBiddingInstructions:
		m.ResetBiddingInstructions()
		return nil
	case tender.FieldCompetitorSituations:
		m.ResetCompetitorSituations()
		return nil
	case tender.FieldCostEngineer:
		m.ResetCostEngineer()
		return nil
	case tender.FieldTenderForm:
		m.ResetTenderForm()
		return nil
	case tender.FieldContractForm:
		m.ResetContractForm()
		return nil
	case tender.FieldManagementCompany:
		m.ResetManagementCompany()
		return nil
	case tender.FieldTenderingAgency:
		m.ResetTenderingAgency()
		return nil
	case tender.FieldBiddingDate:
		m.ResetBiddingDate()
		return nil
	case tender.FieldFacadeConsultant:
		m.ResetFacadeConsultant()
		return nil
	case tender.FieldDesignUnit:
		m.ResetDesignUnit()
		return nil
	case tender.FieldConsultingFirm:
		m.ResetConsultingFirm()
		return nil
	case tender.FieldKeyProject:
		m.ResetKeyProject()
		return nil
	case tender.FieldCurrentProgress:
		m.ResetCurrentProgress()
		return nil
	case tender.FieldTenderWinCompany:
		m.ResetTenderWinCompany()
		return nil
	case tender.FieldTenderCode:
		m.ResetTenderCode()
		return nil
	case tender.FieldArchitect:
		m.ResetArchitect()
		return nil
	case tender.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case tender.FieldTenderClosingDate:
		m.ResetTenderClosingDate()
		return nil
	case tender.FieldConstructionArea:
		m.ResetConstructionArea()
		return nil
	case tender.FieldTenderWinDate:
		m.ResetTenderWinDate()
		return nil
	case tender.FieldTenderWinAmount:
		m.ResetTenderWinAmount()
		return nil
	case tender.FieldLastTenderAmount:
		m.ResetLastTenderAmount()
		return nil
	case tender.FieldAreaID:
		m.ResetAreaID()
		return nil
	case tender.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case tender.FieldCityID:
		m.ResetCityID()
		return nil
	case tender.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case tender.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case tender.FieldFinderID:
		m.ResetFinderID()
		return nil
	case tender.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	case tender.FieldApproverID:
		m.ResetApproverID()
		return nil
	case tender.FieldActiveProfileID:
		m.ResetActiveProfileID()
		return nil
	case tender.FieldPendingProfileID:
		m.ResetPendingProfileID()
		return nil
	}
	return fmt.Errorf("unknown Tender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.area != nil {
		edges = append(edges, tender.EdgeArea)
	}
	if m.profiles != nil {
		edges = append(edges, tender.EdgeProfiles)
	}
	if m.competitors != nil {
		edges = append(edges, tender.EdgeCompetitors)
	}
	if m.customer != nil {
		edges = append(edges, tender.EdgeCustomer)
	}
	if m.finder != nil {
		edges = append(edges, tender.EdgeFinder)
	}
	if m.created_by != nil {
		edges = append(edges, tender.EdgeCreatedBy)
	}
	if m.following_sales != nil {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.province != nil {
		edges = append(edges, tender.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, tender.EdgeCity)
	}
	if m.district != nil {
		edges = append(edges, tender.EdgeDistrict)
	}
	if m.visit_records != nil {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	if m.approver != nil {
		edges = append(edges, tender.EdgeApprover)
	}
	if m.active_profile != nil {
		edges = append(edges, tender.EdgeActiveProfile)
	}
	if m.pending_profile != nil {
		edges = append(edges, tender.EdgePendingProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tender.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.profiles))
		for id := range m.profiles {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeCompetitors:
		ids := make([]ent.Value, 0, len(m.competitors))
		for id := range m.competitors {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeFinder:
		if id := m.finder; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeFollowingSales:
		ids := make([]ent.Value, 0, len(m.following_sales))
		for id := range m.following_sales {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeApprover:
		if id := m.approver; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgeActiveProfile:
		if id := m.active_profile; id != nil {
			return []ent.Value{*id}
		}
	case tender.EdgePendingProfile:
		if id := m.pending_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedprofiles != nil {
		edges = append(edges, tender.EdgeProfiles)
	}
	if m.removedcompetitors != nil {
		edges = append(edges, tender.EdgeCompetitors)
	}
	if m.removedfollowing_sales != nil {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tender.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removedprofiles))
		for id := range m.removedprofiles {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeCompetitors:
		ids := make([]ent.Value, 0, len(m.removedcompetitors))
		for id := range m.removedcompetitors {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeFollowingSales:
		ids := make([]ent.Value, 0, len(m.removedfollowing_sales))
		for id := range m.removedfollowing_sales {
			ids = append(ids, id)
		}
		return ids
	case tender.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedarea {
		edges = append(edges, tender.EdgeArea)
	}
	if m.clearedprofiles {
		edges = append(edges, tender.EdgeProfiles)
	}
	if m.clearedcompetitors {
		edges = append(edges, tender.EdgeCompetitors)
	}
	if m.clearedcustomer {
		edges = append(edges, tender.EdgeCustomer)
	}
	if m.clearedfinder {
		edges = append(edges, tender.EdgeFinder)
	}
	if m.clearedcreated_by {
		edges = append(edges, tender.EdgeCreatedBy)
	}
	if m.clearedfollowing_sales {
		edges = append(edges, tender.EdgeFollowingSales)
	}
	if m.clearedprovince {
		edges = append(edges, tender.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, tender.EdgeCity)
	}
	if m.cleareddistrict {
		edges = append(edges, tender.EdgeDistrict)
	}
	if m.clearedvisit_records {
		edges = append(edges, tender.EdgeVisitRecords)
	}
	if m.clearedapprover {
		edges = append(edges, tender.EdgeApprover)
	}
	if m.clearedactive_profile {
		edges = append(edges, tender.EdgeActiveProfile)
	}
	if m.clearedpending_profile {
		edges = append(edges, tender.EdgePendingProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenderMutation) EdgeCleared(name string) bool {
	switch name {
	case tender.EdgeArea:
		return m.clearedarea
	case tender.EdgeProfiles:
		return m.clearedprofiles
	case tender.EdgeCompetitors:
		return m.clearedcompetitors
	case tender.EdgeCustomer:
		return m.clearedcustomer
	case tender.EdgeFinder:
		return m.clearedfinder
	case tender.EdgeCreatedBy:
		return m.clearedcreated_by
	case tender.EdgeFollowingSales:
		return m.clearedfollowing_sales
	case tender.EdgeProvince:
		return m.clearedprovince
	case tender.EdgeCity:
		return m.clearedcity
	case tender.EdgeDistrict:
		return m.cleareddistrict
	case tender.EdgeVisitRecords:
		return m.clearedvisit_records
	case tender.EdgeApprover:
		return m.clearedapprover
	case tender.EdgeActiveProfile:
		return m.clearedactive_profile
	case tender.EdgePendingProfile:
		return m.clearedpending_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenderMutation) ClearEdge(name string) error {
	switch name {
	case tender.EdgeArea:
		m.ClearArea()
		return nil
	case tender.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case tender.EdgeFinder:
		m.ClearFinder()
		return nil
	case tender.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tender.EdgeProvince:
		m.ClearProvince()
		return nil
	case tender.EdgeCity:
		m.ClearCity()
		return nil
	case tender.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case tender.EdgeApprover:
		m.ClearApprover()
		return nil
	case tender.EdgeActiveProfile:
		m.ClearActiveProfile()
		return nil
	case tender.EdgePendingProfile:
		m.ClearPendingProfile()
		return nil
	}
	return fmt.Errorf("unknown Tender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenderMutation) ResetEdge(name string) error {
	switch name {
	case tender.EdgeArea:
		m.ResetArea()
		return nil
	case tender.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case tender.EdgeCompetitors:
		m.ResetCompetitors()
		return nil
	case tender.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case tender.EdgeFinder:
		m.ResetFinder()
		return nil
	case tender.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tender.EdgeFollowingSales:
		m.ResetFollowingSales()
		return nil
	case tender.EdgeProvince:
		m.ResetProvince()
		return nil
	case tender.EdgeCity:
		m.ResetCity()
		return nil
	case tender.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case tender.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	case tender.EdgeApprover:
		m.ResetApprover()
		return nil
	case tender.EdgeActiveProfile:
		m.ResetActiveProfile()
		return nil
	case tender.EdgePendingProfile:
		m.ResetPendingProfile()
		return nil
	}
	return fmt.Errorf("unknown Tender edge %s", name)
}

// TenderCompetitorMutation represents an operation that mutates the TenderCompetitor nodes in the graph.
type TenderCompetitorMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	created_at        *time.Time
	updated_at        *time.Time
	amount            *float64
	addamount         *float64
	result            *bool
	clearedFields     map[string]struct{}
	tender            *xid.ID
	clearedtender     bool
	competitor        *xid.ID
	clearedcompetitor bool
	done              bool
	oldValue          func(context.Context) (*TenderCompetitor, error)
	predicates        []predicate.TenderCompetitor
}

var _ ent.Mutation = (*TenderCompetitorMutation)(nil)

// tendercompetitorOption allows management of the mutation configuration using functional options.
type tendercompetitorOption func(*TenderCompetitorMutation)

// newTenderCompetitorMutation creates new mutation for the TenderCompetitor entity.
func newTenderCompetitorMutation(c config, op Op, opts ...tendercompetitorOption) *TenderCompetitorMutation {
	m := &TenderCompetitorMutation{
		config:        c,
		op:            op,
		typ:           TypeTenderCompetitor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenderCompetitorID sets the ID field of the mutation.
func withTenderCompetitorID(id xid.ID) tendercompetitorOption {
	return func(m *TenderCompetitorMutation) {
		var (
			err   error
			once  sync.Once
			value *TenderCompetitor
		)
		m.oldValue = func(ctx context.Context) (*TenderCompetitor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenderCompetitor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenderCompetitor sets the old TenderCompetitor of the mutation.
func withTenderCompetitor(node *TenderCompetitor) tendercompetitorOption {
	return func(m *TenderCompetitorMutation) {
		m.oldValue = func(context.Context) (*TenderCompetitor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenderCompetitorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenderCompetitorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenderCompetitor entities.
func (m *TenderCompetitorMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenderCompetitorMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenderCompetitorMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenderCompetitor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenderCompetitorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenderCompetitorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenderCompetitorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenderCompetitorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenderCompetitorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenderCompetitorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTenderID sets the "tender_id" field.
func (m *TenderCompetitorMutation) SetTenderID(x xid.ID) {
	m.tender = &x
}

// TenderID returns the value of the "tender_id" field in the mutation.
func (m *TenderCompetitorMutation) TenderID() (r xid.ID, exists bool) {
	v := m.tender
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderID returns the old "tender_id" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldTenderID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderID: %w", err)
	}
	return oldValue.TenderID, nil
}

// ResetTenderID resets all changes to the "tender_id" field.
func (m *TenderCompetitorMutation) ResetTenderID() {
	m.tender = nil
}

// SetCompetitorID sets the "competitor_id" field.
func (m *TenderCompetitorMutation) SetCompetitorID(x xid.ID) {
	m.competitor = &x
}

// CompetitorID returns the value of the "competitor_id" field in the mutation.
func (m *TenderCompetitorMutation) CompetitorID() (r xid.ID, exists bool) {
	v := m.competitor
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitorID returns the old "competitor_id" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldCompetitorID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitorID: %w", err)
	}
	return oldValue.CompetitorID, nil
}

// ResetCompetitorID resets all changes to the "competitor_id" field.
func (m *TenderCompetitorMutation) ResetCompetitorID() {
	m.competitor = nil
}

// SetAmount sets the "amount" field.
func (m *TenderCompetitorMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TenderCompetitorMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TenderCompetitorMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TenderCompetitorMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TenderCompetitorMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetResult sets the "result" field.
func (m *TenderCompetitorMutation) SetResult(b bool) {
	m.result = &b
}

// Result returns the value of the "result" field in the mutation.
func (m *TenderCompetitorMutation) Result() (r bool, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the TenderCompetitor entity.
// If the TenderCompetitor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderCompetitorMutation) OldResult(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *TenderCompetitorMutation) ResetResult() {
	m.result = nil
}

// ClearTender clears the "tender" edge to the Tender entity.
func (m *TenderCompetitorMutation) ClearTender() {
	m.clearedtender = true
	m.clearedFields[tendercompetitor.FieldTenderID] = struct{}{}
}

// TenderCleared reports if the "tender" edge to the Tender entity was cleared.
func (m *TenderCompetitorMutation) TenderCleared() bool {
	return m.clearedtender
}

// TenderIDs returns the "tender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenderID instead. It exists only for internal usage by the builders.
func (m *TenderCompetitorMutation) TenderIDs() (ids []xid.ID) {
	if id := m.tender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTender resets all changes to the "tender" edge.
func (m *TenderCompetitorMutation) ResetTender() {
	m.tender = nil
	m.clearedtender = false
}

// ClearCompetitor clears the "competitor" edge to the Competitor entity.
func (m *TenderCompetitorMutation) ClearCompetitor() {
	m.clearedcompetitor = true
	m.clearedFields[tendercompetitor.FieldCompetitorID] = struct{}{}
}

// CompetitorCleared reports if the "competitor" edge to the Competitor entity was cleared.
func (m *TenderCompetitorMutation) CompetitorCleared() bool {
	return m.clearedcompetitor
}

// CompetitorIDs returns the "competitor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitorID instead. It exists only for internal usage by the builders.
func (m *TenderCompetitorMutation) CompetitorIDs() (ids []xid.ID) {
	if id := m.competitor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetitor resets all changes to the "competitor" edge.
func (m *TenderCompetitorMutation) ResetCompetitor() {
	m.competitor = nil
	m.clearedcompetitor = false
}

// Where appends a list predicates to the TenderCompetitorMutation builder.
func (m *TenderCompetitorMutation) Where(ps ...predicate.TenderCompetitor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenderCompetitorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenderCompetitorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenderCompetitor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenderCompetitorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenderCompetitorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenderCompetitor).
func (m *TenderCompetitorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenderCompetitorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, tendercompetitor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tendercompetitor.FieldUpdatedAt)
	}
	if m.tender != nil {
		fields = append(fields, tendercompetitor.FieldTenderID)
	}
	if m.competitor != nil {
		fields = append(fields, tendercompetitor.FieldCompetitorID)
	}
	if m.amount != nil {
		fields = append(fields, tendercompetitor.FieldAmount)
	}
	if m.result != nil {
		fields = append(fields, tendercompetitor.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenderCompetitorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tendercompetitor.FieldCreatedAt:
		return m.CreatedAt()
	case tendercompetitor.FieldUpdatedAt:
		return m.UpdatedAt()
	case tendercompetitor.FieldTenderID:
		return m.TenderID()
	case tendercompetitor.FieldCompetitorID:
		return m.CompetitorID()
	case tendercompetitor.FieldAmount:
		return m.Amount()
	case tendercompetitor.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenderCompetitorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tendercompetitor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tendercompetitor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tendercompetitor.FieldTenderID:
		return m.OldTenderID(ctx)
	case tendercompetitor.FieldCompetitorID:
		return m.OldCompetitorID(ctx)
	case tendercompetitor.FieldAmount:
		return m.OldAmount(ctx)
	case tendercompetitor.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown TenderCompetitor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderCompetitorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tendercompetitor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tendercompetitor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tendercompetitor.FieldTenderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderID(v)
		return nil
	case tendercompetitor.FieldCompetitorID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitorID(v)
		return nil
	case tendercompetitor.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case tendercompetitor.FieldResult:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown TenderCompetitor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenderCompetitorMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, tendercompetitor.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenderCompetitorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tendercompetitor.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderCompetitorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tendercompetitor.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TenderCompetitor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenderCompetitorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenderCompetitorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenderCompetitorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TenderCompetitor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenderCompetitorMutation) ResetField(name string) error {
	switch name {
	case tendercompetitor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tendercompetitor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tendercompetitor.FieldTenderID:
		m.ResetTenderID()
		return nil
	case tendercompetitor.FieldCompetitorID:
		m.ResetCompetitorID()
		return nil
	case tendercompetitor.FieldAmount:
		m.ResetAmount()
		return nil
	case tendercompetitor.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown TenderCompetitor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenderCompetitorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tender != nil {
		edges = append(edges, tendercompetitor.EdgeTender)
	}
	if m.competitor != nil {
		edges = append(edges, tendercompetitor.EdgeCompetitor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenderCompetitorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tendercompetitor.EdgeTender:
		if id := m.tender; id != nil {
			return []ent.Value{*id}
		}
	case tendercompetitor.EdgeCompetitor:
		if id := m.competitor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenderCompetitorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenderCompetitorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenderCompetitorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtender {
		edges = append(edges, tendercompetitor.EdgeTender)
	}
	if m.clearedcompetitor {
		edges = append(edges, tendercompetitor.EdgeCompetitor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenderCompetitorMutation) EdgeCleared(name string) bool {
	switch name {
	case tendercompetitor.EdgeTender:
		return m.clearedtender
	case tendercompetitor.EdgeCompetitor:
		return m.clearedcompetitor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenderCompetitorMutation) ClearEdge(name string) error {
	switch name {
	case tendercompetitor.EdgeTender:
		m.ClearTender()
		return nil
	case tendercompetitor.EdgeCompetitor:
		m.ClearCompetitor()
		return nil
	}
	return fmt.Errorf("unknown TenderCompetitor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenderCompetitorMutation) ResetEdge(name string) error {
	switch name {
	case tendercompetitor.EdgeTender:
		m.ResetTender()
		return nil
	case tendercompetitor.EdgeCompetitor:
		m.ResetCompetitor()
		return nil
	}
	return fmt.Errorf("unknown TenderCompetitor edge %s", name)
}

// TenderProfileMutation represents an operation that mutates the TenderProfile nodes in the graph.
type TenderProfileMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *xid.ID
	created_at                              *time.Time
	updated_at                              *time.Time
	status                                  *int
	addstatus                               *int
	approval_status                         *int
	addapproval_status                      *int
	approval_msg_id                         *string
	name                                    *string
	estimated_amount                        *float64
	addestimated_amount                     *float64
	tender_date                             *time.Time
	classify                                *int
	addclassify                             *int
	discovery_date                          *time.Time
	address                                 *string
	full_address                            *string
	contractor                              *string
	level_involved                          *int
	addlevel_involved                       *int
	size_and_value_rating                   *int
	addsize_and_value_rating                *int
	size_and_value_rating_overview          *string
	credit_and_payment_rating               *int
	addcredit_and_payment_rating            *int
	credit_and_payment_rating_overview      *string
	time_limit_rating                       *int
	addtime_limit_rating                    *int
	time_limit_rating_overview              *string
	customer_relationship_rating            *int
	addcustomer_relationship_rating         *int
	customer_relationship_rating_overview   *string
	competitive_partnership_rating          *int
	addcompetitive_partnership_rating       *int
	competitive_partnership_rating_overview *string
	prepare_to_bid                          *bool
	project_code                            *string
	project_type                            *string
	project_definition                      *string
	estimated_project_start_date            *time.Time
	estimated_project_end_date              *time.Time
	attachments                             *[]string
	appendattachments                       []string
	geo_coordinate                          *[]float64
	appendgeo_coordinate                    []float64
	geo_bounds                              *[][]float64
	appendgeo_bounds                        [][]float64
	remark                                  *string
	images                                  *[]string
	appendimages                            []string
	tender_situations                       *string
	owner_situations                        *string
	bidding_instructions                    *string
	competitor_situations                   *string
	cost_engineer                           *string
	tender_form                             *string
	contract_form                           *string
	management_company                      *string
	tendering_agency                        *string
	bidding_date                            *time.Time
	facade_consultant                       *string
	design_unit                             *string
	consulting_firm                         *string
	key_project                             *bool
	current_progress                        *string
	tender_win_company                      *string
	tender_code                             *string
	architect                               *string
	developer                               *string
	tender_closing_date                     *time.Time
	construction_area                       *string
	tender_win_date                         *time.Time
	tender_win_amount                       *float64
	addtender_win_amount                    *float64
	last_tender_amount                      *float64
	addlast_tender_amount                   *float64
	clearedFields                           map[string]struct{}
	tender                                  *xid.ID
	clearedtender                           bool
	customer                                *xid.ID
	clearedcustomer                         bool
	finder                                  *xid.ID
	clearedfinder                           bool
	created_by                              *xid.ID
	clearedcreated_by                       bool
	province                                *xid.ID
	clearedprovince                         bool
	city                                    *xid.ID
	clearedcity                             bool
	district                                *xid.ID
	cleareddistrict                         bool
	approver                                *xid.ID
	clearedapprover                         bool
	done                                    bool
	oldValue                                func(context.Context) (*TenderProfile, error)
	predicates                              []predicate.TenderProfile
}

var _ ent.Mutation = (*TenderProfileMutation)(nil)

// tenderprofileOption allows management of the mutation configuration using functional options.
type tenderprofileOption func(*TenderProfileMutation)

// newTenderProfileMutation creates new mutation for the TenderProfile entity.
func newTenderProfileMutation(c config, op Op, opts ...tenderprofileOption) *TenderProfileMutation {
	m := &TenderProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeTenderProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenderProfileID sets the ID field of the mutation.
func withTenderProfileID(id xid.ID) tenderprofileOption {
	return func(m *TenderProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *TenderProfile
		)
		m.oldValue = func(ctx context.Context) (*TenderProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenderProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenderProfile sets the old TenderProfile of the mutation.
func withTenderProfile(node *TenderProfile) tenderprofileOption {
	return func(m *TenderProfileMutation) {
		m.oldValue = func(context.Context) (*TenderProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenderProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenderProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenderProfile entities.
func (m *TenderProfileMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenderProfileMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenderProfileMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenderProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenderProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenderProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenderProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenderProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenderProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenderProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TenderProfileMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TenderProfileMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TenderProfileMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TenderProfileMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TenderProfileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetApprovalStatus sets the "approval_status" field.
func (m *TenderProfileMutation) SetApprovalStatus(i int) {
	m.approval_status = &i
	m.addapproval_status = nil
}

// ApprovalStatus returns the value of the "approval_status" field in the mutation.
func (m *TenderProfileMutation) ApprovalStatus() (r int, exists bool) {
	v := m.approval_status
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalStatus returns the old "approval_status" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldApprovalStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalStatus: %w", err)
	}
	return oldValue.ApprovalStatus, nil
}

// AddApprovalStatus adds i to the "approval_status" field.
func (m *TenderProfileMutation) AddApprovalStatus(i int) {
	if m.addapproval_status != nil {
		*m.addapproval_status += i
	} else {
		m.addapproval_status = &i
	}
}

// AddedApprovalStatus returns the value that was added to the "approval_status" field in this mutation.
func (m *TenderProfileMutation) AddedApprovalStatus() (r int, exists bool) {
	v := m.addapproval_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetApprovalStatus resets all changes to the "approval_status" field.
func (m *TenderProfileMutation) ResetApprovalStatus() {
	m.approval_status = nil
	m.addapproval_status = nil
}

// SetApprovalMsgID sets the "approval_msg_id" field.
func (m *TenderProfileMutation) SetApprovalMsgID(s string) {
	m.approval_msg_id = &s
}

// ApprovalMsgID returns the value of the "approval_msg_id" field in the mutation.
func (m *TenderProfileMutation) ApprovalMsgID() (r string, exists bool) {
	v := m.approval_msg_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalMsgID returns the old "approval_msg_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldApprovalMsgID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalMsgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalMsgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalMsgID: %w", err)
	}
	return oldValue.ApprovalMsgID, nil
}

// ClearApprovalMsgID clears the value of the "approval_msg_id" field.
func (m *TenderProfileMutation) ClearApprovalMsgID() {
	m.approval_msg_id = nil
	m.clearedFields[tenderprofile.FieldApprovalMsgID] = struct{}{}
}

// ApprovalMsgIDCleared returns if the "approval_msg_id" field was cleared in this mutation.
func (m *TenderProfileMutation) ApprovalMsgIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldApprovalMsgID]
	return ok
}

// ResetApprovalMsgID resets all changes to the "approval_msg_id" field.
func (m *TenderProfileMutation) ResetApprovalMsgID() {
	m.approval_msg_id = nil
	delete(m.clearedFields, tenderprofile.FieldApprovalMsgID)
}

// SetName sets the "name" field.
func (m *TenderProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenderProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TenderProfileMutation) ClearName() {
	m.name = nil
	m.clearedFields[tenderprofile.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TenderProfileMutation) NameCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TenderProfileMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, tenderprofile.FieldName)
}

// SetEstimatedAmount sets the "estimated_amount" field.
func (m *TenderProfileMutation) SetEstimatedAmount(f float64) {
	m.estimated_amount = &f
	m.addestimated_amount = nil
}

// EstimatedAmount returns the value of the "estimated_amount" field in the mutation.
func (m *TenderProfileMutation) EstimatedAmount() (r float64, exists bool) {
	v := m.estimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedAmount returns the old "estimated_amount" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldEstimatedAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedAmount: %w", err)
	}
	return oldValue.EstimatedAmount, nil
}

// AddEstimatedAmount adds f to the "estimated_amount" field.
func (m *TenderProfileMutation) AddEstimatedAmount(f float64) {
	if m.addestimated_amount != nil {
		*m.addestimated_amount += f
	} else {
		m.addestimated_amount = &f
	}
}

// AddedEstimatedAmount returns the value that was added to the "estimated_amount" field in this mutation.
func (m *TenderProfileMutation) AddedEstimatedAmount() (r float64, exists bool) {
	v := m.addestimated_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedAmount clears the value of the "estimated_amount" field.
func (m *TenderProfileMutation) ClearEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	m.clearedFields[tenderprofile.FieldEstimatedAmount] = struct{}{}
}

// EstimatedAmountCleared returns if the "estimated_amount" field was cleared in this mutation.
func (m *TenderProfileMutation) EstimatedAmountCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldEstimatedAmount]
	return ok
}

// ResetEstimatedAmount resets all changes to the "estimated_amount" field.
func (m *TenderProfileMutation) ResetEstimatedAmount() {
	m.estimated_amount = nil
	m.addestimated_amount = nil
	delete(m.clearedFields, tenderprofile.FieldEstimatedAmount)
}

// SetTenderDate sets the "tender_date" field.
func (m *TenderProfileMutation) SetTenderDate(t time.Time) {
	m.tender_date = &t
}

// TenderDate returns the value of the "tender_date" field in the mutation.
func (m *TenderProfileMutation) TenderDate() (r time.Time, exists bool) {
	v := m.tender_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderDate returns the old "tender_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderDate: %w", err)
	}
	return oldValue.TenderDate, nil
}

// ClearTenderDate clears the value of the "tender_date" field.
func (m *TenderProfileMutation) ClearTenderDate() {
	m.tender_date = nil
	m.clearedFields[tenderprofile.FieldTenderDate] = struct{}{}
}

// TenderDateCleared returns if the "tender_date" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderDate]
	return ok
}

// ResetTenderDate resets all changes to the "tender_date" field.
func (m *TenderProfileMutation) ResetTenderDate() {
	m.tender_date = nil
	delete(m.clearedFields, tenderprofile.FieldTenderDate)
}

// SetClassify sets the "classify" field.
func (m *TenderProfileMutation) SetClassify(i int) {
	m.classify = &i
	m.addclassify = nil
}

// Classify returns the value of the "classify" field in the mutation.
func (m *TenderProfileMutation) Classify() (r int, exists bool) {
	v := m.classify
	if v == nil {
		return
	}
	return *v, true
}

// OldClassify returns the old "classify" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldClassify(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassify: %w", err)
	}
	return oldValue.Classify, nil
}

// AddClassify adds i to the "classify" field.
func (m *TenderProfileMutation) AddClassify(i int) {
	if m.addclassify != nil {
		*m.addclassify += i
	} else {
		m.addclassify = &i
	}
}

// AddedClassify returns the value that was added to the "classify" field in this mutation.
func (m *TenderProfileMutation) AddedClassify() (r int, exists bool) {
	v := m.addclassify
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassify clears the value of the "classify" field.
func (m *TenderProfileMutation) ClearClassify() {
	m.classify = nil
	m.addclassify = nil
	m.clearedFields[tenderprofile.FieldClassify] = struct{}{}
}

// ClassifyCleared returns if the "classify" field was cleared in this mutation.
func (m *TenderProfileMutation) ClassifyCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldClassify]
	return ok
}

// ResetClassify resets all changes to the "classify" field.
func (m *TenderProfileMutation) ResetClassify() {
	m.classify = nil
	m.addclassify = nil
	delete(m.clearedFields, tenderprofile.FieldClassify)
}

// SetDiscoveryDate sets the "discovery_date" field.
func (m *TenderProfileMutation) SetDiscoveryDate(t time.Time) {
	m.discovery_date = &t
}

// DiscoveryDate returns the value of the "discovery_date" field in the mutation.
func (m *TenderProfileMutation) DiscoveryDate() (r time.Time, exists bool) {
	v := m.discovery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryDate returns the old "discovery_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldDiscoveryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryDate: %w", err)
	}
	return oldValue.DiscoveryDate, nil
}

// ClearDiscoveryDate clears the value of the "discovery_date" field.
func (m *TenderProfileMutation) ClearDiscoveryDate() {
	m.discovery_date = nil
	m.clearedFields[tenderprofile.FieldDiscoveryDate] = struct{}{}
}

// DiscoveryDateCleared returns if the "discovery_date" field was cleared in this mutation.
func (m *TenderProfileMutation) DiscoveryDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldDiscoveryDate]
	return ok
}

// ResetDiscoveryDate resets all changes to the "discovery_date" field.
func (m *TenderProfileMutation) ResetDiscoveryDate() {
	m.discovery_date = nil
	delete(m.clearedFields, tenderprofile.FieldDiscoveryDate)
}

// SetAddress sets the "address" field.
func (m *TenderProfileMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TenderProfileMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *TenderProfileMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[tenderprofile.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *TenderProfileMutation) AddressCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *TenderProfileMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, tenderprofile.FieldAddress)
}

// SetFullAddress sets the "full_address" field.
func (m *TenderProfileMutation) SetFullAddress(s string) {
	m.full_address = &s
}

// FullAddress returns the value of the "full_address" field in the mutation.
func (m *TenderProfileMutation) FullAddress() (r string, exists bool) {
	v := m.full_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFullAddress returns the old "full_address" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldFullAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullAddress: %w", err)
	}
	return oldValue.FullAddress, nil
}

// ClearFullAddress clears the value of the "full_address" field.
func (m *TenderProfileMutation) ClearFullAddress() {
	m.full_address = nil
	m.clearedFields[tenderprofile.FieldFullAddress] = struct{}{}
}

// FullAddressCleared returns if the "full_address" field was cleared in this mutation.
func (m *TenderProfileMutation) FullAddressCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldFullAddress]
	return ok
}

// ResetFullAddress resets all changes to the "full_address" field.
func (m *TenderProfileMutation) ResetFullAddress() {
	m.full_address = nil
	delete(m.clearedFields, tenderprofile.FieldFullAddress)
}

// SetContractor sets the "contractor" field.
func (m *TenderProfileMutation) SetContractor(s string) {
	m.contractor = &s
}

// Contractor returns the value of the "contractor" field in the mutation.
func (m *TenderProfileMutation) Contractor() (r string, exists bool) {
	v := m.contractor
	if v == nil {
		return
	}
	return *v, true
}

// OldContractor returns the old "contractor" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldContractor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractor: %w", err)
	}
	return oldValue.Contractor, nil
}

// ClearContractor clears the value of the "contractor" field.
func (m *TenderProfileMutation) ClearContractor() {
	m.contractor = nil
	m.clearedFields[tenderprofile.FieldContractor] = struct{}{}
}

// ContractorCleared returns if the "contractor" field was cleared in this mutation.
func (m *TenderProfileMutation) ContractorCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldContractor]
	return ok
}

// ResetContractor resets all changes to the "contractor" field.
func (m *TenderProfileMutation) ResetContractor() {
	m.contractor = nil
	delete(m.clearedFields, tenderprofile.FieldContractor)
}

// SetLevelInvolved sets the "level_involved" field.
func (m *TenderProfileMutation) SetLevelInvolved(i int) {
	m.level_involved = &i
	m.addlevel_involved = nil
}

// LevelInvolved returns the value of the "level_involved" field in the mutation.
func (m *TenderProfileMutation) LevelInvolved() (r int, exists bool) {
	v := m.level_involved
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelInvolved returns the old "level_involved" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldLevelInvolved(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelInvolved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelInvolved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelInvolved: %w", err)
	}
	return oldValue.LevelInvolved, nil
}

// AddLevelInvolved adds i to the "level_involved" field.
func (m *TenderProfileMutation) AddLevelInvolved(i int) {
	if m.addlevel_involved != nil {
		*m.addlevel_involved += i
	} else {
		m.addlevel_involved = &i
	}
}

// AddedLevelInvolved returns the value that was added to the "level_involved" field in this mutation.
func (m *TenderProfileMutation) AddedLevelInvolved() (r int, exists bool) {
	v := m.addlevel_involved
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevelInvolved clears the value of the "level_involved" field.
func (m *TenderProfileMutation) ClearLevelInvolved() {
	m.level_involved = nil
	m.addlevel_involved = nil
	m.clearedFields[tenderprofile.FieldLevelInvolved] = struct{}{}
}

// LevelInvolvedCleared returns if the "level_involved" field was cleared in this mutation.
func (m *TenderProfileMutation) LevelInvolvedCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldLevelInvolved]
	return ok
}

// ResetLevelInvolved resets all changes to the "level_involved" field.
func (m *TenderProfileMutation) ResetLevelInvolved() {
	m.level_involved = nil
	m.addlevel_involved = nil
	delete(m.clearedFields, tenderprofile.FieldLevelInvolved)
}

// SetSizeAndValueRating sets the "size_and_value_rating" field.
func (m *TenderProfileMutation) SetSizeAndValueRating(i int) {
	m.size_and_value_rating = &i
	m.addsize_and_value_rating = nil
}

// SizeAndValueRating returns the value of the "size_and_value_rating" field in the mutation.
func (m *TenderProfileMutation) SizeAndValueRating() (r int, exists bool) {
	v := m.size_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRating returns the old "size_and_value_rating" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldSizeAndValueRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRating: %w", err)
	}
	return oldValue.SizeAndValueRating, nil
}

// AddSizeAndValueRating adds i to the "size_and_value_rating" field.
func (m *TenderProfileMutation) AddSizeAndValueRating(i int) {
	if m.addsize_and_value_rating != nil {
		*m.addsize_and_value_rating += i
	} else {
		m.addsize_and_value_rating = &i
	}
}

// AddedSizeAndValueRating returns the value that was added to the "size_and_value_rating" field in this mutation.
func (m *TenderProfileMutation) AddedSizeAndValueRating() (r int, exists bool) {
	v := m.addsize_and_value_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeAndValueRating clears the value of the "size_and_value_rating" field.
func (m *TenderProfileMutation) ClearSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	m.clearedFields[tenderprofile.FieldSizeAndValueRating] = struct{}{}
}

// SizeAndValueRatingCleared returns if the "size_and_value_rating" field was cleared in this mutation.
func (m *TenderProfileMutation) SizeAndValueRatingCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldSizeAndValueRating]
	return ok
}

// ResetSizeAndValueRating resets all changes to the "size_and_value_rating" field.
func (m *TenderProfileMutation) ResetSizeAndValueRating() {
	m.size_and_value_rating = nil
	m.addsize_and_value_rating = nil
	delete(m.clearedFields, tenderprofile.FieldSizeAndValueRating)
}

// SetSizeAndValueRatingOverview sets the "size_and_value_rating_overview" field.
func (m *TenderProfileMutation) SetSizeAndValueRatingOverview(s string) {
	m.size_and_value_rating_overview = &s
}

// SizeAndValueRatingOverview returns the value of the "size_and_value_rating_overview" field in the mutation.
func (m *TenderProfileMutation) SizeAndValueRatingOverview() (r string, exists bool) {
	v := m.size_and_value_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeAndValueRatingOverview returns the old "size_and_value_rating_overview" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldSizeAndValueRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeAndValueRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeAndValueRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeAndValueRatingOverview: %w", err)
	}
	return oldValue.SizeAndValueRatingOverview, nil
}

// ClearSizeAndValueRatingOverview clears the value of the "size_and_value_rating_overview" field.
func (m *TenderProfileMutation) ClearSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	m.clearedFields[tenderprofile.FieldSizeAndValueRatingOverview] = struct{}{}
}

// SizeAndValueRatingOverviewCleared returns if the "size_and_value_rating_overview" field was cleared in this mutation.
func (m *TenderProfileMutation) SizeAndValueRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldSizeAndValueRatingOverview]
	return ok
}

// ResetSizeAndValueRatingOverview resets all changes to the "size_and_value_rating_overview" field.
func (m *TenderProfileMutation) ResetSizeAndValueRatingOverview() {
	m.size_and_value_rating_overview = nil
	delete(m.clearedFields, tenderprofile.FieldSizeAndValueRatingOverview)
}

// SetCreditAndPaymentRating sets the "credit_and_payment_rating" field.
func (m *TenderProfileMutation) SetCreditAndPaymentRating(i int) {
	m.credit_and_payment_rating = &i
	m.addcredit_and_payment_rating = nil
}

// CreditAndPaymentRating returns the value of the "credit_and_payment_rating" field in the mutation.
func (m *TenderProfileMutation) CreditAndPaymentRating() (r int, exists bool) {
	v := m.credit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRating returns the old "credit_and_payment_rating" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCreditAndPaymentRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRating: %w", err)
	}
	return oldValue.CreditAndPaymentRating, nil
}

// AddCreditAndPaymentRating adds i to the "credit_and_payment_rating" field.
func (m *TenderProfileMutation) AddCreditAndPaymentRating(i int) {
	if m.addcredit_and_payment_rating != nil {
		*m.addcredit_and_payment_rating += i
	} else {
		m.addcredit_and_payment_rating = &i
	}
}

// AddedCreditAndPaymentRating returns the value that was added to the "credit_and_payment_rating" field in this mutation.
func (m *TenderProfileMutation) AddedCreditAndPaymentRating() (r int, exists bool) {
	v := m.addcredit_and_payment_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreditAndPaymentRating clears the value of the "credit_and_payment_rating" field.
func (m *TenderProfileMutation) ClearCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	m.clearedFields[tenderprofile.FieldCreditAndPaymentRating] = struct{}{}
}

// CreditAndPaymentRatingCleared returns if the "credit_and_payment_rating" field was cleared in this mutation.
func (m *TenderProfileMutation) CreditAndPaymentRatingCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCreditAndPaymentRating]
	return ok
}

// ResetCreditAndPaymentRating resets all changes to the "credit_and_payment_rating" field.
func (m *TenderProfileMutation) ResetCreditAndPaymentRating() {
	m.credit_and_payment_rating = nil
	m.addcredit_and_payment_rating = nil
	delete(m.clearedFields, tenderprofile.FieldCreditAndPaymentRating)
}

// SetCreditAndPaymentRatingOverview sets the "credit_and_payment_rating_overview" field.
func (m *TenderProfileMutation) SetCreditAndPaymentRatingOverview(s string) {
	m.credit_and_payment_rating_overview = &s
}

// CreditAndPaymentRatingOverview returns the value of the "credit_and_payment_rating_overview" field in the mutation.
func (m *TenderProfileMutation) CreditAndPaymentRatingOverview() (r string, exists bool) {
	v := m.credit_and_payment_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAndPaymentRatingOverview returns the old "credit_and_payment_rating_overview" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCreditAndPaymentRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAndPaymentRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAndPaymentRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAndPaymentRatingOverview: %w", err)
	}
	return oldValue.CreditAndPaymentRatingOverview, nil
}

// ClearCreditAndPaymentRatingOverview clears the value of the "credit_and_payment_rating_overview" field.
func (m *TenderProfileMutation) ClearCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	m.clearedFields[tenderprofile.FieldCreditAndPaymentRatingOverview] = struct{}{}
}

// CreditAndPaymentRatingOverviewCleared returns if the "credit_and_payment_rating_overview" field was cleared in this mutation.
func (m *TenderProfileMutation) CreditAndPaymentRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCreditAndPaymentRatingOverview]
	return ok
}

// ResetCreditAndPaymentRatingOverview resets all changes to the "credit_and_payment_rating_overview" field.
func (m *TenderProfileMutation) ResetCreditAndPaymentRatingOverview() {
	m.credit_and_payment_rating_overview = nil
	delete(m.clearedFields, tenderprofile.FieldCreditAndPaymentRatingOverview)
}

// SetTimeLimitRating sets the "time_limit_rating" field.
func (m *TenderProfileMutation) SetTimeLimitRating(i int) {
	m.time_limit_rating = &i
	m.addtime_limit_rating = nil
}

// TimeLimitRating returns the value of the "time_limit_rating" field in the mutation.
func (m *TenderProfileMutation) TimeLimitRating() (r int, exists bool) {
	v := m.time_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRating returns the old "time_limit_rating" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTimeLimitRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRating: %w", err)
	}
	return oldValue.TimeLimitRating, nil
}

// AddTimeLimitRating adds i to the "time_limit_rating" field.
func (m *TenderProfileMutation) AddTimeLimitRating(i int) {
	if m.addtime_limit_rating != nil {
		*m.addtime_limit_rating += i
	} else {
		m.addtime_limit_rating = &i
	}
}

// AddedTimeLimitRating returns the value that was added to the "time_limit_rating" field in this mutation.
func (m *TenderProfileMutation) AddedTimeLimitRating() (r int, exists bool) {
	v := m.addtime_limit_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeLimitRating clears the value of the "time_limit_rating" field.
func (m *TenderProfileMutation) ClearTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	m.clearedFields[tenderprofile.FieldTimeLimitRating] = struct{}{}
}

// TimeLimitRatingCleared returns if the "time_limit_rating" field was cleared in this mutation.
func (m *TenderProfileMutation) TimeLimitRatingCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTimeLimitRating]
	return ok
}

// ResetTimeLimitRating resets all changes to the "time_limit_rating" field.
func (m *TenderProfileMutation) ResetTimeLimitRating() {
	m.time_limit_rating = nil
	m.addtime_limit_rating = nil
	delete(m.clearedFields, tenderprofile.FieldTimeLimitRating)
}

// SetTimeLimitRatingOverview sets the "time_limit_rating_overview" field.
func (m *TenderProfileMutation) SetTimeLimitRatingOverview(s string) {
	m.time_limit_rating_overview = &s
}

// TimeLimitRatingOverview returns the value of the "time_limit_rating_overview" field in the mutation.
func (m *TenderProfileMutation) TimeLimitRatingOverview() (r string, exists bool) {
	v := m.time_limit_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeLimitRatingOverview returns the old "time_limit_rating_overview" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTimeLimitRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeLimitRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeLimitRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeLimitRatingOverview: %w", err)
	}
	return oldValue.TimeLimitRatingOverview, nil
}

// ClearTimeLimitRatingOverview clears the value of the "time_limit_rating_overview" field.
func (m *TenderProfileMutation) ClearTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	m.clearedFields[tenderprofile.FieldTimeLimitRatingOverview] = struct{}{}
}

// TimeLimitRatingOverviewCleared returns if the "time_limit_rating_overview" field was cleared in this mutation.
func (m *TenderProfileMutation) TimeLimitRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTimeLimitRatingOverview]
	return ok
}

// ResetTimeLimitRatingOverview resets all changes to the "time_limit_rating_overview" field.
func (m *TenderProfileMutation) ResetTimeLimitRatingOverview() {
	m.time_limit_rating_overview = nil
	delete(m.clearedFields, tenderprofile.FieldTimeLimitRatingOverview)
}

// SetCustomerRelationshipRating sets the "customer_relationship_rating" field.
func (m *TenderProfileMutation) SetCustomerRelationshipRating(i int) {
	m.customer_relationship_rating = &i
	m.addcustomer_relationship_rating = nil
}

// CustomerRelationshipRating returns the value of the "customer_relationship_rating" field in the mutation.
func (m *TenderProfileMutation) CustomerRelationshipRating() (r int, exists bool) {
	v := m.customer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRating returns the old "customer_relationship_rating" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCustomerRelationshipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRating: %w", err)
	}
	return oldValue.CustomerRelationshipRating, nil
}

// AddCustomerRelationshipRating adds i to the "customer_relationship_rating" field.
func (m *TenderProfileMutation) AddCustomerRelationshipRating(i int) {
	if m.addcustomer_relationship_rating != nil {
		*m.addcustomer_relationship_rating += i
	} else {
		m.addcustomer_relationship_rating = &i
	}
}

// AddedCustomerRelationshipRating returns the value that was added to the "customer_relationship_rating" field in this mutation.
func (m *TenderProfileMutation) AddedCustomerRelationshipRating() (r int, exists bool) {
	v := m.addcustomer_relationship_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerRelationshipRating clears the value of the "customer_relationship_rating" field.
func (m *TenderProfileMutation) ClearCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	m.clearedFields[tenderprofile.FieldCustomerRelationshipRating] = struct{}{}
}

// CustomerRelationshipRatingCleared returns if the "customer_relationship_rating" field was cleared in this mutation.
func (m *TenderProfileMutation) CustomerRelationshipRatingCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCustomerRelationshipRating]
	return ok
}

// ResetCustomerRelationshipRating resets all changes to the "customer_relationship_rating" field.
func (m *TenderProfileMutation) ResetCustomerRelationshipRating() {
	m.customer_relationship_rating = nil
	m.addcustomer_relationship_rating = nil
	delete(m.clearedFields, tenderprofile.FieldCustomerRelationshipRating)
}

// SetCustomerRelationshipRatingOverview sets the "customer_relationship_rating_overview" field.
func (m *TenderProfileMutation) SetCustomerRelationshipRatingOverview(s string) {
	m.customer_relationship_rating_overview = &s
}

// CustomerRelationshipRatingOverview returns the value of the "customer_relationship_rating_overview" field in the mutation.
func (m *TenderProfileMutation) CustomerRelationshipRatingOverview() (r string, exists bool) {
	v := m.customer_relationship_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerRelationshipRatingOverview returns the old "customer_relationship_rating_overview" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCustomerRelationshipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerRelationshipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerRelationshipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerRelationshipRatingOverview: %w", err)
	}
	return oldValue.CustomerRelationshipRatingOverview, nil
}

// ClearCustomerRelationshipRatingOverview clears the value of the "customer_relationship_rating_overview" field.
func (m *TenderProfileMutation) ClearCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	m.clearedFields[tenderprofile.FieldCustomerRelationshipRatingOverview] = struct{}{}
}

// CustomerRelationshipRatingOverviewCleared returns if the "customer_relationship_rating_overview" field was cleared in this mutation.
func (m *TenderProfileMutation) CustomerRelationshipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCustomerRelationshipRatingOverview]
	return ok
}

// ResetCustomerRelationshipRatingOverview resets all changes to the "customer_relationship_rating_overview" field.
func (m *TenderProfileMutation) ResetCustomerRelationshipRatingOverview() {
	m.customer_relationship_rating_overview = nil
	delete(m.clearedFields, tenderprofile.FieldCustomerRelationshipRatingOverview)
}

// SetCompetitivePartnershipRating sets the "competitive_partnership_rating" field.
func (m *TenderProfileMutation) SetCompetitivePartnershipRating(i int) {
	m.competitive_partnership_rating = &i
	m.addcompetitive_partnership_rating = nil
}

// CompetitivePartnershipRating returns the value of the "competitive_partnership_rating" field in the mutation.
func (m *TenderProfileMutation) CompetitivePartnershipRating() (r int, exists bool) {
	v := m.competitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRating returns the old "competitive_partnership_rating" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCompetitivePartnershipRating(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRating: %w", err)
	}
	return oldValue.CompetitivePartnershipRating, nil
}

// AddCompetitivePartnershipRating adds i to the "competitive_partnership_rating" field.
func (m *TenderProfileMutation) AddCompetitivePartnershipRating(i int) {
	if m.addcompetitive_partnership_rating != nil {
		*m.addcompetitive_partnership_rating += i
	} else {
		m.addcompetitive_partnership_rating = &i
	}
}

// AddedCompetitivePartnershipRating returns the value that was added to the "competitive_partnership_rating" field in this mutation.
func (m *TenderProfileMutation) AddedCompetitivePartnershipRating() (r int, exists bool) {
	v := m.addcompetitive_partnership_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompetitivePartnershipRating clears the value of the "competitive_partnership_rating" field.
func (m *TenderProfileMutation) ClearCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	m.clearedFields[tenderprofile.FieldCompetitivePartnershipRating] = struct{}{}
}

// CompetitivePartnershipRatingCleared returns if the "competitive_partnership_rating" field was cleared in this mutation.
func (m *TenderProfileMutation) CompetitivePartnershipRatingCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCompetitivePartnershipRating]
	return ok
}

// ResetCompetitivePartnershipRating resets all changes to the "competitive_partnership_rating" field.
func (m *TenderProfileMutation) ResetCompetitivePartnershipRating() {
	m.competitive_partnership_rating = nil
	m.addcompetitive_partnership_rating = nil
	delete(m.clearedFields, tenderprofile.FieldCompetitivePartnershipRating)
}

// SetCompetitivePartnershipRatingOverview sets the "competitive_partnership_rating_overview" field.
func (m *TenderProfileMutation) SetCompetitivePartnershipRatingOverview(s string) {
	m.competitive_partnership_rating_overview = &s
}

// CompetitivePartnershipRatingOverview returns the value of the "competitive_partnership_rating_overview" field in the mutation.
func (m *TenderProfileMutation) CompetitivePartnershipRatingOverview() (r string, exists bool) {
	v := m.competitive_partnership_rating_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitivePartnershipRatingOverview returns the old "competitive_partnership_rating_overview" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCompetitivePartnershipRatingOverview(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitivePartnershipRatingOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitivePartnershipRatingOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitivePartnershipRatingOverview: %w", err)
	}
	return oldValue.CompetitivePartnershipRatingOverview, nil
}

// ClearCompetitivePartnershipRatingOverview clears the value of the "competitive_partnership_rating_overview" field.
func (m *TenderProfileMutation) ClearCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	m.clearedFields[tenderprofile.FieldCompetitivePartnershipRatingOverview] = struct{}{}
}

// CompetitivePartnershipRatingOverviewCleared returns if the "competitive_partnership_rating_overview" field was cleared in this mutation.
func (m *TenderProfileMutation) CompetitivePartnershipRatingOverviewCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCompetitivePartnershipRatingOverview]
	return ok
}

// ResetCompetitivePartnershipRatingOverview resets all changes to the "competitive_partnership_rating_overview" field.
func (m *TenderProfileMutation) ResetCompetitivePartnershipRatingOverview() {
	m.competitive_partnership_rating_overview = nil
	delete(m.clearedFields, tenderprofile.FieldCompetitivePartnershipRatingOverview)
}

// SetPrepareToBid sets the "prepare_to_bid" field.
func (m *TenderProfileMutation) SetPrepareToBid(b bool) {
	m.prepare_to_bid = &b
}

// PrepareToBid returns the value of the "prepare_to_bid" field in the mutation.
func (m *TenderProfileMutation) PrepareToBid() (r bool, exists bool) {
	v := m.prepare_to_bid
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepareToBid returns the old "prepare_to_bid" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldPrepareToBid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepareToBid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepareToBid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepareToBid: %w", err)
	}
	return oldValue.PrepareToBid, nil
}

// ResetPrepareToBid resets all changes to the "prepare_to_bid" field.
func (m *TenderProfileMutation) ResetPrepareToBid() {
	m.prepare_to_bid = nil
}

// SetProjectCode sets the "project_code" field.
func (m *TenderProfileMutation) SetProjectCode(s string) {
	m.project_code = &s
}

// ProjectCode returns the value of the "project_code" field in the mutation.
func (m *TenderProfileMutation) ProjectCode() (r string, exists bool) {
	v := m.project_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectCode returns the old "project_code" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldProjectCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectCode: %w", err)
	}
	return oldValue.ProjectCode, nil
}

// ClearProjectCode clears the value of the "project_code" field.
func (m *TenderProfileMutation) ClearProjectCode() {
	m.project_code = nil
	m.clearedFields[tenderprofile.FieldProjectCode] = struct{}{}
}

// ProjectCodeCleared returns if the "project_code" field was cleared in this mutation.
func (m *TenderProfileMutation) ProjectCodeCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldProjectCode]
	return ok
}

// ResetProjectCode resets all changes to the "project_code" field.
func (m *TenderProfileMutation) ResetProjectCode() {
	m.project_code = nil
	delete(m.clearedFields, tenderprofile.FieldProjectCode)
}

// SetProjectType sets the "project_type" field.
func (m *TenderProfileMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *TenderProfileMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldProjectType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ClearProjectType clears the value of the "project_type" field.
func (m *TenderProfileMutation) ClearProjectType() {
	m.project_type = nil
	m.clearedFields[tenderprofile.FieldProjectType] = struct{}{}
}

// ProjectTypeCleared returns if the "project_type" field was cleared in this mutation.
func (m *TenderProfileMutation) ProjectTypeCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldProjectType]
	return ok
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *TenderProfileMutation) ResetProjectType() {
	m.project_type = nil
	delete(m.clearedFields, tenderprofile.FieldProjectType)
}

// SetProjectDefinition sets the "project_definition" field.
func (m *TenderProfileMutation) SetProjectDefinition(s string) {
	m.project_definition = &s
}

// ProjectDefinition returns the value of the "project_definition" field in the mutation.
func (m *TenderProfileMutation) ProjectDefinition() (r string, exists bool) {
	v := m.project_definition
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectDefinition returns the old "project_definition" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldProjectDefinition(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectDefinition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectDefinition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectDefinition: %w", err)
	}
	return oldValue.ProjectDefinition, nil
}

// ClearProjectDefinition clears the value of the "project_definition" field.
func (m *TenderProfileMutation) ClearProjectDefinition() {
	m.project_definition = nil
	m.clearedFields[tenderprofile.FieldProjectDefinition] = struct{}{}
}

// ProjectDefinitionCleared returns if the "project_definition" field was cleared in this mutation.
func (m *TenderProfileMutation) ProjectDefinitionCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldProjectDefinition]
	return ok
}

// ResetProjectDefinition resets all changes to the "project_definition" field.
func (m *TenderProfileMutation) ResetProjectDefinition() {
	m.project_definition = nil
	delete(m.clearedFields, tenderprofile.FieldProjectDefinition)
}

// SetEstimatedProjectStartDate sets the "estimated_project_start_date" field.
func (m *TenderProfileMutation) SetEstimatedProjectStartDate(t time.Time) {
	m.estimated_project_start_date = &t
}

// EstimatedProjectStartDate returns the value of the "estimated_project_start_date" field in the mutation.
func (m *TenderProfileMutation) EstimatedProjectStartDate() (r time.Time, exists bool) {
	v := m.estimated_project_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectStartDate returns the old "estimated_project_start_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldEstimatedProjectStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectStartDate: %w", err)
	}
	return oldValue.EstimatedProjectStartDate, nil
}

// ClearEstimatedProjectStartDate clears the value of the "estimated_project_start_date" field.
func (m *TenderProfileMutation) ClearEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	m.clearedFields[tenderprofile.FieldEstimatedProjectStartDate] = struct{}{}
}

// EstimatedProjectStartDateCleared returns if the "estimated_project_start_date" field was cleared in this mutation.
func (m *TenderProfileMutation) EstimatedProjectStartDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldEstimatedProjectStartDate]
	return ok
}

// ResetEstimatedProjectStartDate resets all changes to the "estimated_project_start_date" field.
func (m *TenderProfileMutation) ResetEstimatedProjectStartDate() {
	m.estimated_project_start_date = nil
	delete(m.clearedFields, tenderprofile.FieldEstimatedProjectStartDate)
}

// SetEstimatedProjectEndDate sets the "estimated_project_end_date" field.
func (m *TenderProfileMutation) SetEstimatedProjectEndDate(t time.Time) {
	m.estimated_project_end_date = &t
}

// EstimatedProjectEndDate returns the value of the "estimated_project_end_date" field in the mutation.
func (m *TenderProfileMutation) EstimatedProjectEndDate() (r time.Time, exists bool) {
	v := m.estimated_project_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedProjectEndDate returns the old "estimated_project_end_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldEstimatedProjectEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedProjectEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedProjectEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedProjectEndDate: %w", err)
	}
	return oldValue.EstimatedProjectEndDate, nil
}

// ClearEstimatedProjectEndDate clears the value of the "estimated_project_end_date" field.
func (m *TenderProfileMutation) ClearEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	m.clearedFields[tenderprofile.FieldEstimatedProjectEndDate] = struct{}{}
}

// EstimatedProjectEndDateCleared returns if the "estimated_project_end_date" field was cleared in this mutation.
func (m *TenderProfileMutation) EstimatedProjectEndDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldEstimatedProjectEndDate]
	return ok
}

// ResetEstimatedProjectEndDate resets all changes to the "estimated_project_end_date" field.
func (m *TenderProfileMutation) ResetEstimatedProjectEndDate() {
	m.estimated_project_end_date = nil
	delete(m.clearedFields, tenderprofile.FieldEstimatedProjectEndDate)
}

// SetAttachments sets the "attachments" field.
func (m *TenderProfileMutation) SetAttachments(s []string) {
	m.attachments = &s
	m.appendattachments = nil
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *TenderProfileMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// AppendAttachments adds s to the "attachments" field.
func (m *TenderProfileMutation) AppendAttachments(s []string) {
	m.appendattachments = append(m.appendattachments, s...)
}

// AppendedAttachments returns the list of values that were appended to the "attachments" field in this mutation.
func (m *TenderProfileMutation) AppendedAttachments() ([]string, bool) {
	if len(m.appendattachments) == 0 {
		return nil, false
	}
	return m.appendattachments, true
}

// ClearAttachments clears the value of the "attachments" field.
func (m *TenderProfileMutation) ClearAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	m.clearedFields[tenderprofile.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *TenderProfileMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *TenderProfileMutation) ResetAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	delete(m.clearedFields, tenderprofile.FieldAttachments)
}

// SetGeoCoordinate sets the "geo_coordinate" field.
func (m *TenderProfileMutation) SetGeoCoordinate(f []float64) {
	m.geo_coordinate = &f
	m.appendgeo_coordinate = nil
}

// GeoCoordinate returns the value of the "geo_coordinate" field in the mutation.
func (m *TenderProfileMutation) GeoCoordinate() (r []float64, exists bool) {
	v := m.geo_coordinate
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoCoordinate returns the old "geo_coordinate" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldGeoCoordinate(ctx context.Context) (v []float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoCoordinate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoCoordinate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoCoordinate: %w", err)
	}
	return oldValue.GeoCoordinate, nil
}

// AppendGeoCoordinate adds f to the "geo_coordinate" field.
func (m *TenderProfileMutation) AppendGeoCoordinate(f []float64) {
	m.appendgeo_coordinate = append(m.appendgeo_coordinate, f...)
}

// AppendedGeoCoordinate returns the list of values that were appended to the "geo_coordinate" field in this mutation.
func (m *TenderProfileMutation) AppendedGeoCoordinate() ([]float64, bool) {
	if len(m.appendgeo_coordinate) == 0 {
		return nil, false
	}
	return m.appendgeo_coordinate, true
}

// ClearGeoCoordinate clears the value of the "geo_coordinate" field.
func (m *TenderProfileMutation) ClearGeoCoordinate() {
	m.geo_coordinate = nil
	m.appendgeo_coordinate = nil
	m.clearedFields[tenderprofile.FieldGeoCoordinate] = struct{}{}
}

// GeoCoordinateCleared returns if the "geo_coordinate" field was cleared in this mutation.
func (m *TenderProfileMutation) GeoCoordinateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldGeoCoordinate]
	return ok
}

// ResetGeoCoordinate resets all changes to the "geo_coordinate" field.
func (m *TenderProfileMutation) ResetGeoCoordinate() {
	m.geo_coordinate = nil
	m.appendgeo_coordinate = nil
	delete(m.clearedFields, tenderprofile.FieldGeoCoordinate)
}

// SetGeoBounds sets the "geo_bounds" field.
func (m *TenderProfileMutation) SetGeoBounds(f [][]float64) {
	m.geo_bounds = &f
	m.appendgeo_bounds = nil
}

// GeoBounds returns the value of the "geo_bounds" field in the mutation.
func (m *TenderProfileMutation) GeoBounds() (r [][]float64, exists bool) {
	v := m.geo_bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoBounds returns the old "geo_bounds" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldGeoBounds(ctx context.Context) (v [][]float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoBounds: %w", err)
	}
	return oldValue.GeoBounds, nil
}

// AppendGeoBounds adds f to the "geo_bounds" field.
func (m *TenderProfileMutation) AppendGeoBounds(f [][]float64) {
	m.appendgeo_bounds = append(m.appendgeo_bounds, f...)
}

// AppendedGeoBounds returns the list of values that were appended to the "geo_bounds" field in this mutation.
func (m *TenderProfileMutation) AppendedGeoBounds() ([][]float64, bool) {
	if len(m.appendgeo_bounds) == 0 {
		return nil, false
	}
	return m.appendgeo_bounds, true
}

// ClearGeoBounds clears the value of the "geo_bounds" field.
func (m *TenderProfileMutation) ClearGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	m.clearedFields[tenderprofile.FieldGeoBounds] = struct{}{}
}

// GeoBoundsCleared returns if the "geo_bounds" field was cleared in this mutation.
func (m *TenderProfileMutation) GeoBoundsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldGeoBounds]
	return ok
}

// ResetGeoBounds resets all changes to the "geo_bounds" field.
func (m *TenderProfileMutation) ResetGeoBounds() {
	m.geo_bounds = nil
	m.appendgeo_bounds = nil
	delete(m.clearedFields, tenderprofile.FieldGeoBounds)
}

// SetRemark sets the "remark" field.
func (m *TenderProfileMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TenderProfileMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *TenderProfileMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[tenderprofile.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *TenderProfileMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *TenderProfileMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, tenderprofile.FieldRemark)
}

// SetImages sets the "images" field.
func (m *TenderProfileMutation) SetImages(s []string) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *TenderProfileMutation) Images() (r []string, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldImages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *TenderProfileMutation) AppendImages(s []string) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *TenderProfileMutation) AppendedImages() ([]string, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *TenderProfileMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[tenderprofile.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *TenderProfileMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *TenderProfileMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, tenderprofile.FieldImages)
}

// SetTenderSituations sets the "tender_situations" field.
func (m *TenderProfileMutation) SetTenderSituations(s string) {
	m.tender_situations = &s
}

// TenderSituations returns the value of the "tender_situations" field in the mutation.
func (m *TenderProfileMutation) TenderSituations() (r string, exists bool) {
	v := m.tender_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderSituations returns the old "tender_situations" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderSituations: %w", err)
	}
	return oldValue.TenderSituations, nil
}

// ClearTenderSituations clears the value of the "tender_situations" field.
func (m *TenderProfileMutation) ClearTenderSituations() {
	m.tender_situations = nil
	m.clearedFields[tenderprofile.FieldTenderSituations] = struct{}{}
}

// TenderSituationsCleared returns if the "tender_situations" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderSituationsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderSituations]
	return ok
}

// ResetTenderSituations resets all changes to the "tender_situations" field.
func (m *TenderProfileMutation) ResetTenderSituations() {
	m.tender_situations = nil
	delete(m.clearedFields, tenderprofile.FieldTenderSituations)
}

// SetOwnerSituations sets the "owner_situations" field.
func (m *TenderProfileMutation) SetOwnerSituations(s string) {
	m.owner_situations = &s
}

// OwnerSituations returns the value of the "owner_situations" field in the mutation.
func (m *TenderProfileMutation) OwnerSituations() (r string, exists bool) {
	v := m.owner_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSituations returns the old "owner_situations" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldOwnerSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSituations: %w", err)
	}
	return oldValue.OwnerSituations, nil
}

// ClearOwnerSituations clears the value of the "owner_situations" field.
func (m *TenderProfileMutation) ClearOwnerSituations() {
	m.owner_situations = nil
	m.clearedFields[tenderprofile.FieldOwnerSituations] = struct{}{}
}

// OwnerSituationsCleared returns if the "owner_situations" field was cleared in this mutation.
func (m *TenderProfileMutation) OwnerSituationsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldOwnerSituations]
	return ok
}

// ResetOwnerSituations resets all changes to the "owner_situations" field.
func (m *TenderProfileMutation) ResetOwnerSituations() {
	m.owner_situations = nil
	delete(m.clearedFields, tenderprofile.FieldOwnerSituations)
}

// SetBiddingInstructions sets the "bidding_instructions" field.
func (m *TenderProfileMutation) SetBiddingInstructions(s string) {
	m.bidding_instructions = &s
}

// BiddingInstructions returns the value of the "bidding_instructions" field in the mutation.
func (m *TenderProfileMutation) BiddingInstructions() (r string, exists bool) {
	v := m.bidding_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingInstructions returns the old "bidding_instructions" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldBiddingInstructions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingInstructions: %w", err)
	}
	return oldValue.BiddingInstructions, nil
}

// ClearBiddingInstructions clears the value of the "bidding_instructions" field.
func (m *TenderProfileMutation) ClearBiddingInstructions() {
	m.bidding_instructions = nil
	m.clearedFields[tenderprofile.FieldBiddingInstructions] = struct{}{}
}

// BiddingInstructionsCleared returns if the "bidding_instructions" field was cleared in this mutation.
func (m *TenderProfileMutation) BiddingInstructionsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldBiddingInstructions]
	return ok
}

// ResetBiddingInstructions resets all changes to the "bidding_instructions" field.
func (m *TenderProfileMutation) ResetBiddingInstructions() {
	m.bidding_instructions = nil
	delete(m.clearedFields, tenderprofile.FieldBiddingInstructions)
}

// SetCompetitorSituations sets the "competitor_situations" field.
func (m *TenderProfileMutation) SetCompetitorSituations(s string) {
	m.competitor_situations = &s
}

// CompetitorSituations returns the value of the "competitor_situations" field in the mutation.
func (m *TenderProfileMutation) CompetitorSituations() (r string, exists bool) {
	v := m.competitor_situations
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitorSituations returns the old "competitor_situations" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCompetitorSituations(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitorSituations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitorSituations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitorSituations: %w", err)
	}
	return oldValue.CompetitorSituations, nil
}

// ClearCompetitorSituations clears the value of the "competitor_situations" field.
func (m *TenderProfileMutation) ClearCompetitorSituations() {
	m.competitor_situations = nil
	m.clearedFields[tenderprofile.FieldCompetitorSituations] = struct{}{}
}

// CompetitorSituationsCleared returns if the "competitor_situations" field was cleared in this mutation.
func (m *TenderProfileMutation) CompetitorSituationsCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCompetitorSituations]
	return ok
}

// ResetCompetitorSituations resets all changes to the "competitor_situations" field.
func (m *TenderProfileMutation) ResetCompetitorSituations() {
	m.competitor_situations = nil
	delete(m.clearedFields, tenderprofile.FieldCompetitorSituations)
}

// SetCostEngineer sets the "cost_engineer" field.
func (m *TenderProfileMutation) SetCostEngineer(s string) {
	m.cost_engineer = &s
}

// CostEngineer returns the value of the "cost_engineer" field in the mutation.
func (m *TenderProfileMutation) CostEngineer() (r string, exists bool) {
	v := m.cost_engineer
	if v == nil {
		return
	}
	return *v, true
}

// OldCostEngineer returns the old "cost_engineer" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCostEngineer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostEngineer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostEngineer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostEngineer: %w", err)
	}
	return oldValue.CostEngineer, nil
}

// ClearCostEngineer clears the value of the "cost_engineer" field.
func (m *TenderProfileMutation) ClearCostEngineer() {
	m.cost_engineer = nil
	m.clearedFields[tenderprofile.FieldCostEngineer] = struct{}{}
}

// CostEngineerCleared returns if the "cost_engineer" field was cleared in this mutation.
func (m *TenderProfileMutation) CostEngineerCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCostEngineer]
	return ok
}

// ResetCostEngineer resets all changes to the "cost_engineer" field.
func (m *TenderProfileMutation) ResetCostEngineer() {
	m.cost_engineer = nil
	delete(m.clearedFields, tenderprofile.FieldCostEngineer)
}

// SetTenderForm sets the "tender_form" field.
func (m *TenderProfileMutation) SetTenderForm(s string) {
	m.tender_form = &s
}

// TenderForm returns the value of the "tender_form" field in the mutation.
func (m *TenderProfileMutation) TenderForm() (r string, exists bool) {
	v := m.tender_form
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderForm returns the old "tender_form" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderForm: %w", err)
	}
	return oldValue.TenderForm, nil
}

// ClearTenderForm clears the value of the "tender_form" field.
func (m *TenderProfileMutation) ClearTenderForm() {
	m.tender_form = nil
	m.clearedFields[tenderprofile.FieldTenderForm] = struct{}{}
}

// TenderFormCleared returns if the "tender_form" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderFormCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderForm]
	return ok
}

// ResetTenderForm resets all changes to the "tender_form" field.
func (m *TenderProfileMutation) ResetTenderForm() {
	m.tender_form = nil
	delete(m.clearedFields, tenderprofile.FieldTenderForm)
}

// SetContractForm sets the "contract_form" field.
func (m *TenderProfileMutation) SetContractForm(s string) {
	m.contract_form = &s
}

// ContractForm returns the value of the "contract_form" field in the mutation.
func (m *TenderProfileMutation) ContractForm() (r string, exists bool) {
	v := m.contract_form
	if v == nil {
		return
	}
	return *v, true
}

// OldContractForm returns the old "contract_form" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldContractForm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractForm: %w", err)
	}
	return oldValue.ContractForm, nil
}

// ClearContractForm clears the value of the "contract_form" field.
func (m *TenderProfileMutation) ClearContractForm() {
	m.contract_form = nil
	m.clearedFields[tenderprofile.FieldContractForm] = struct{}{}
}

// ContractFormCleared returns if the "contract_form" field was cleared in this mutation.
func (m *TenderProfileMutation) ContractFormCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldContractForm]
	return ok
}

// ResetContractForm resets all changes to the "contract_form" field.
func (m *TenderProfileMutation) ResetContractForm() {
	m.contract_form = nil
	delete(m.clearedFields, tenderprofile.FieldContractForm)
}

// SetManagementCompany sets the "management_company" field.
func (m *TenderProfileMutation) SetManagementCompany(s string) {
	m.management_company = &s
}

// ManagementCompany returns the value of the "management_company" field in the mutation.
func (m *TenderProfileMutation) ManagementCompany() (r string, exists bool) {
	v := m.management_company
	if v == nil {
		return
	}
	return *v, true
}

// OldManagementCompany returns the old "management_company" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldManagementCompany(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagementCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagementCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagementCompany: %w", err)
	}
	return oldValue.ManagementCompany, nil
}

// ClearManagementCompany clears the value of the "management_company" field.
func (m *TenderProfileMutation) ClearManagementCompany() {
	m.management_company = nil
	m.clearedFields[tenderprofile.FieldManagementCompany] = struct{}{}
}

// ManagementCompanyCleared returns if the "management_company" field was cleared in this mutation.
func (m *TenderProfileMutation) ManagementCompanyCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldManagementCompany]
	return ok
}

// ResetManagementCompany resets all changes to the "management_company" field.
func (m *TenderProfileMutation) ResetManagementCompany() {
	m.management_company = nil
	delete(m.clearedFields, tenderprofile.FieldManagementCompany)
}

// SetTenderingAgency sets the "tendering_agency" field.
func (m *TenderProfileMutation) SetTenderingAgency(s string) {
	m.tendering_agency = &s
}

// TenderingAgency returns the value of the "tendering_agency" field in the mutation.
func (m *TenderProfileMutation) TenderingAgency() (r string, exists bool) {
	v := m.tendering_agency
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderingAgency returns the old "tendering_agency" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderingAgency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderingAgency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderingAgency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderingAgency: %w", err)
	}
	return oldValue.TenderingAgency, nil
}

// ClearTenderingAgency clears the value of the "tendering_agency" field.
func (m *TenderProfileMutation) ClearTenderingAgency() {
	m.tendering_agency = nil
	m.clearedFields[tenderprofile.FieldTenderingAgency] = struct{}{}
}

// TenderingAgencyCleared returns if the "tendering_agency" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderingAgencyCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderingAgency]
	return ok
}

// ResetTenderingAgency resets all changes to the "tendering_agency" field.
func (m *TenderProfileMutation) ResetTenderingAgency() {
	m.tendering_agency = nil
	delete(m.clearedFields, tenderprofile.FieldTenderingAgency)
}

// SetBiddingDate sets the "bidding_date" field.
func (m *TenderProfileMutation) SetBiddingDate(t time.Time) {
	m.bidding_date = &t
}

// BiddingDate returns the value of the "bidding_date" field in the mutation.
func (m *TenderProfileMutation) BiddingDate() (r time.Time, exists bool) {
	v := m.bidding_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBiddingDate returns the old "bidding_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldBiddingDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiddingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiddingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiddingDate: %w", err)
	}
	return oldValue.BiddingDate, nil
}

// ClearBiddingDate clears the value of the "bidding_date" field.
func (m *TenderProfileMutation) ClearBiddingDate() {
	m.bidding_date = nil
	m.clearedFields[tenderprofile.FieldBiddingDate] = struct{}{}
}

// BiddingDateCleared returns if the "bidding_date" field was cleared in this mutation.
func (m *TenderProfileMutation) BiddingDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldBiddingDate]
	return ok
}

// ResetBiddingDate resets all changes to the "bidding_date" field.
func (m *TenderProfileMutation) ResetBiddingDate() {
	m.bidding_date = nil
	delete(m.clearedFields, tenderprofile.FieldBiddingDate)
}

// SetFacadeConsultant sets the "facade_consultant" field.
func (m *TenderProfileMutation) SetFacadeConsultant(s string) {
	m.facade_consultant = &s
}

// FacadeConsultant returns the value of the "facade_consultant" field in the mutation.
func (m *TenderProfileMutation) FacadeConsultant() (r string, exists bool) {
	v := m.facade_consultant
	if v == nil {
		return
	}
	return *v, true
}

// OldFacadeConsultant returns the old "facade_consultant" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldFacadeConsultant(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFacadeConsultant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFacadeConsultant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacadeConsultant: %w", err)
	}
	return oldValue.FacadeConsultant, nil
}

// ClearFacadeConsultant clears the value of the "facade_consultant" field.
func (m *TenderProfileMutation) ClearFacadeConsultant() {
	m.facade_consultant = nil
	m.clearedFields[tenderprofile.FieldFacadeConsultant] = struct{}{}
}

// FacadeConsultantCleared returns if the "facade_consultant" field was cleared in this mutation.
func (m *TenderProfileMutation) FacadeConsultantCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldFacadeConsultant]
	return ok
}

// ResetFacadeConsultant resets all changes to the "facade_consultant" field.
func (m *TenderProfileMutation) ResetFacadeConsultant() {
	m.facade_consultant = nil
	delete(m.clearedFields, tenderprofile.FieldFacadeConsultant)
}

// SetDesignUnit sets the "design_unit" field.
func (m *TenderProfileMutation) SetDesignUnit(s string) {
	m.design_unit = &s
}

// DesignUnit returns the value of the "design_unit" field in the mutation.
func (m *TenderProfileMutation) DesignUnit() (r string, exists bool) {
	v := m.design_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldDesignUnit returns the old "design_unit" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldDesignUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesignUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesignUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesignUnit: %w", err)
	}
	return oldValue.DesignUnit, nil
}

// ClearDesignUnit clears the value of the "design_unit" field.
func (m *TenderProfileMutation) ClearDesignUnit() {
	m.design_unit = nil
	m.clearedFields[tenderprofile.FieldDesignUnit] = struct{}{}
}

// DesignUnitCleared returns if the "design_unit" field was cleared in this mutation.
func (m *TenderProfileMutation) DesignUnitCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldDesignUnit]
	return ok
}

// ResetDesignUnit resets all changes to the "design_unit" field.
func (m *TenderProfileMutation) ResetDesignUnit() {
	m.design_unit = nil
	delete(m.clearedFields, tenderprofile.FieldDesignUnit)
}

// SetConsultingFirm sets the "consulting_firm" field.
func (m *TenderProfileMutation) SetConsultingFirm(s string) {
	m.consulting_firm = &s
}

// ConsultingFirm returns the value of the "consulting_firm" field in the mutation.
func (m *TenderProfileMutation) ConsultingFirm() (r string, exists bool) {
	v := m.consulting_firm
	if v == nil {
		return
	}
	return *v, true
}

// OldConsultingFirm returns the old "consulting_firm" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldConsultingFirm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsultingFirm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsultingFirm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsultingFirm: %w", err)
	}
	return oldValue.ConsultingFirm, nil
}

// ClearConsultingFirm clears the value of the "consulting_firm" field.
func (m *TenderProfileMutation) ClearConsultingFirm() {
	m.consulting_firm = nil
	m.clearedFields[tenderprofile.FieldConsultingFirm] = struct{}{}
}

// ConsultingFirmCleared returns if the "consulting_firm" field was cleared in this mutation.
func (m *TenderProfileMutation) ConsultingFirmCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldConsultingFirm]
	return ok
}

// ResetConsultingFirm resets all changes to the "consulting_firm" field.
func (m *TenderProfileMutation) ResetConsultingFirm() {
	m.consulting_firm = nil
	delete(m.clearedFields, tenderprofile.FieldConsultingFirm)
}

// SetKeyProject sets the "key_project" field.
func (m *TenderProfileMutation) SetKeyProject(b bool) {
	m.key_project = &b
}

// KeyProject returns the value of the "key_project" field in the mutation.
func (m *TenderProfileMutation) KeyProject() (r bool, exists bool) {
	v := m.key_project
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyProject returns the old "key_project" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldKeyProject(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyProject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyProject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyProject: %w", err)
	}
	return oldValue.KeyProject, nil
}

// ResetKeyProject resets all changes to the "key_project" field.
func (m *TenderProfileMutation) ResetKeyProject() {
	m.key_project = nil
}

// SetCurrentProgress sets the "current_progress" field.
func (m *TenderProfileMutation) SetCurrentProgress(s string) {
	m.current_progress = &s
}

// CurrentProgress returns the value of the "current_progress" field in the mutation.
func (m *TenderProfileMutation) CurrentProgress() (r string, exists bool) {
	v := m.current_progress
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentProgress returns the old "current_progress" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCurrentProgress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentProgress: %w", err)
	}
	return oldValue.CurrentProgress, nil
}

// ClearCurrentProgress clears the value of the "current_progress" field.
func (m *TenderProfileMutation) ClearCurrentProgress() {
	m.current_progress = nil
	m.clearedFields[tenderprofile.FieldCurrentProgress] = struct{}{}
}

// CurrentProgressCleared returns if the "current_progress" field was cleared in this mutation.
func (m *TenderProfileMutation) CurrentProgressCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCurrentProgress]
	return ok
}

// ResetCurrentProgress resets all changes to the "current_progress" field.
func (m *TenderProfileMutation) ResetCurrentProgress() {
	m.current_progress = nil
	delete(m.clearedFields, tenderprofile.FieldCurrentProgress)
}

// SetTenderWinCompany sets the "tender_win_company" field.
func (m *TenderProfileMutation) SetTenderWinCompany(s string) {
	m.tender_win_company = &s
}

// TenderWinCompany returns the value of the "tender_win_company" field in the mutation.
func (m *TenderProfileMutation) TenderWinCompany() (r string, exists bool) {
	v := m.tender_win_company
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinCompany returns the old "tender_win_company" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderWinCompany(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinCompany: %w", err)
	}
	return oldValue.TenderWinCompany, nil
}

// ClearTenderWinCompany clears the value of the "tender_win_company" field.
func (m *TenderProfileMutation) ClearTenderWinCompany() {
	m.tender_win_company = nil
	m.clearedFields[tenderprofile.FieldTenderWinCompany] = struct{}{}
}

// TenderWinCompanyCleared returns if the "tender_win_company" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderWinCompanyCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderWinCompany]
	return ok
}

// ResetTenderWinCompany resets all changes to the "tender_win_company" field.
func (m *TenderProfileMutation) ResetTenderWinCompany() {
	m.tender_win_company = nil
	delete(m.clearedFields, tenderprofile.FieldTenderWinCompany)
}

// SetTenderCode sets the "tender_code" field.
func (m *TenderProfileMutation) SetTenderCode(s string) {
	m.tender_code = &s
}

// TenderCode returns the value of the "tender_code" field in the mutation.
func (m *TenderProfileMutation) TenderCode() (r string, exists bool) {
	v := m.tender_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderCode returns the old "tender_code" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderCode: %w", err)
	}
	return oldValue.TenderCode, nil
}

// ClearTenderCode clears the value of the "tender_code" field.
func (m *TenderProfileMutation) ClearTenderCode() {
	m.tender_code = nil
	m.clearedFields[tenderprofile.FieldTenderCode] = struct{}{}
}

// TenderCodeCleared returns if the "tender_code" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderCodeCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderCode]
	return ok
}

// ResetTenderCode resets all changes to the "tender_code" field.
func (m *TenderProfileMutation) ResetTenderCode() {
	m.tender_code = nil
	delete(m.clearedFields, tenderprofile.FieldTenderCode)
}

// SetArchitect sets the "architect" field.
func (m *TenderProfileMutation) SetArchitect(s string) {
	m.architect = &s
}

// Architect returns the value of the "architect" field in the mutation.
func (m *TenderProfileMutation) Architect() (r string, exists bool) {
	v := m.architect
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitect returns the old "architect" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldArchitect(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitect: %w", err)
	}
	return oldValue.Architect, nil
}

// ClearArchitect clears the value of the "architect" field.
func (m *TenderProfileMutation) ClearArchitect() {
	m.architect = nil
	m.clearedFields[tenderprofile.FieldArchitect] = struct{}{}
}

// ArchitectCleared returns if the "architect" field was cleared in this mutation.
func (m *TenderProfileMutation) ArchitectCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldArchitect]
	return ok
}

// ResetArchitect resets all changes to the "architect" field.
func (m *TenderProfileMutation) ResetArchitect() {
	m.architect = nil
	delete(m.clearedFields, tenderprofile.FieldArchitect)
}

// SetDeveloper sets the "developer" field.
func (m *TenderProfileMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *TenderProfileMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldDeveloper(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *TenderProfileMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[tenderprofile.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *TenderProfileMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *TenderProfileMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, tenderprofile.FieldDeveloper)
}

// SetTenderClosingDate sets the "tender_closing_date" field.
func (m *TenderProfileMutation) SetTenderClosingDate(t time.Time) {
	m.tender_closing_date = &t
}

// TenderClosingDate returns the value of the "tender_closing_date" field in the mutation.
func (m *TenderProfileMutation) TenderClosingDate() (r time.Time, exists bool) {
	v := m.tender_closing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderClosingDate returns the old "tender_closing_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderClosingDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderClosingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderClosingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderClosingDate: %w", err)
	}
	return oldValue.TenderClosingDate, nil
}

// ClearTenderClosingDate clears the value of the "tender_closing_date" field.
func (m *TenderProfileMutation) ClearTenderClosingDate() {
	m.tender_closing_date = nil
	m.clearedFields[tenderprofile.FieldTenderClosingDate] = struct{}{}
}

// TenderClosingDateCleared returns if the "tender_closing_date" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderClosingDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderClosingDate]
	return ok
}

// ResetTenderClosingDate resets all changes to the "tender_closing_date" field.
func (m *TenderProfileMutation) ResetTenderClosingDate() {
	m.tender_closing_date = nil
	delete(m.clearedFields, tenderprofile.FieldTenderClosingDate)
}

// SetConstructionArea sets the "construction_area" field.
func (m *TenderProfileMutation) SetConstructionArea(s string) {
	m.construction_area = &s
}

// ConstructionArea returns the value of the "construction_area" field in the mutation.
func (m *TenderProfileMutation) ConstructionArea() (r string, exists bool) {
	v := m.construction_area
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionArea returns the old "construction_area" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldConstructionArea(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionArea: %w", err)
	}
	return oldValue.ConstructionArea, nil
}

// ClearConstructionArea clears the value of the "construction_area" field.
func (m *TenderProfileMutation) ClearConstructionArea() {
	m.construction_area = nil
	m.clearedFields[tenderprofile.FieldConstructionArea] = struct{}{}
}

// ConstructionAreaCleared returns if the "construction_area" field was cleared in this mutation.
func (m *TenderProfileMutation) ConstructionAreaCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldConstructionArea]
	return ok
}

// ResetConstructionArea resets all changes to the "construction_area" field.
func (m *TenderProfileMutation) ResetConstructionArea() {
	m.construction_area = nil
	delete(m.clearedFields, tenderprofile.FieldConstructionArea)
}

// SetTenderWinDate sets the "tender_win_date" field.
func (m *TenderProfileMutation) SetTenderWinDate(t time.Time) {
	m.tender_win_date = &t
}

// TenderWinDate returns the value of the "tender_win_date" field in the mutation.
func (m *TenderProfileMutation) TenderWinDate() (r time.Time, exists bool) {
	v := m.tender_win_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinDate returns the old "tender_win_date" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderWinDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinDate: %w", err)
	}
	return oldValue.TenderWinDate, nil
}

// ClearTenderWinDate clears the value of the "tender_win_date" field.
func (m *TenderProfileMutation) ClearTenderWinDate() {
	m.tender_win_date = nil
	m.clearedFields[tenderprofile.FieldTenderWinDate] = struct{}{}
}

// TenderWinDateCleared returns if the "tender_win_date" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderWinDateCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderWinDate]
	return ok
}

// ResetTenderWinDate resets all changes to the "tender_win_date" field.
func (m *TenderProfileMutation) ResetTenderWinDate() {
	m.tender_win_date = nil
	delete(m.clearedFields, tenderprofile.FieldTenderWinDate)
}

// SetTenderWinAmount sets the "tender_win_amount" field.
func (m *TenderProfileMutation) SetTenderWinAmount(f float64) {
	m.tender_win_amount = &f
	m.addtender_win_amount = nil
}

// TenderWinAmount returns the value of the "tender_win_amount" field in the mutation.
func (m *TenderProfileMutation) TenderWinAmount() (r float64, exists bool) {
	v := m.tender_win_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderWinAmount returns the old "tender_win_amount" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderWinAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderWinAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderWinAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderWinAmount: %w", err)
	}
	return oldValue.TenderWinAmount, nil
}

// AddTenderWinAmount adds f to the "tender_win_amount" field.
func (m *TenderProfileMutation) AddTenderWinAmount(f float64) {
	if m.addtender_win_amount != nil {
		*m.addtender_win_amount += f
	} else {
		m.addtender_win_amount = &f
	}
}

// AddedTenderWinAmount returns the value that was added to the "tender_win_amount" field in this mutation.
func (m *TenderProfileMutation) AddedTenderWinAmount() (r float64, exists bool) {
	v := m.addtender_win_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenderWinAmount clears the value of the "tender_win_amount" field.
func (m *TenderProfileMutation) ClearTenderWinAmount() {
	m.tender_win_amount = nil
	m.addtender_win_amount = nil
	m.clearedFields[tenderprofile.FieldTenderWinAmount] = struct{}{}
}

// TenderWinAmountCleared returns if the "tender_win_amount" field was cleared in this mutation.
func (m *TenderProfileMutation) TenderWinAmountCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldTenderWinAmount]
	return ok
}

// ResetTenderWinAmount resets all changes to the "tender_win_amount" field.
func (m *TenderProfileMutation) ResetTenderWinAmount() {
	m.tender_win_amount = nil
	m.addtender_win_amount = nil
	delete(m.clearedFields, tenderprofile.FieldTenderWinAmount)
}

// SetLastTenderAmount sets the "last_tender_amount" field.
func (m *TenderProfileMutation) SetLastTenderAmount(f float64) {
	m.last_tender_amount = &f
	m.addlast_tender_amount = nil
}

// LastTenderAmount returns the value of the "last_tender_amount" field in the mutation.
func (m *TenderProfileMutation) LastTenderAmount() (r float64, exists bool) {
	v := m.last_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTenderAmount returns the old "last_tender_amount" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldLastTenderAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTenderAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTenderAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTenderAmount: %w", err)
	}
	return oldValue.LastTenderAmount, nil
}

// AddLastTenderAmount adds f to the "last_tender_amount" field.
func (m *TenderProfileMutation) AddLastTenderAmount(f float64) {
	if m.addlast_tender_amount != nil {
		*m.addlast_tender_amount += f
	} else {
		m.addlast_tender_amount = &f
	}
}

// AddedLastTenderAmount returns the value that was added to the "last_tender_amount" field in this mutation.
func (m *TenderProfileMutation) AddedLastTenderAmount() (r float64, exists bool) {
	v := m.addlast_tender_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastTenderAmount clears the value of the "last_tender_amount" field.
func (m *TenderProfileMutation) ClearLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	m.clearedFields[tenderprofile.FieldLastTenderAmount] = struct{}{}
}

// LastTenderAmountCleared returns if the "last_tender_amount" field was cleared in this mutation.
func (m *TenderProfileMutation) LastTenderAmountCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldLastTenderAmount]
	return ok
}

// ResetLastTenderAmount resets all changes to the "last_tender_amount" field.
func (m *TenderProfileMutation) ResetLastTenderAmount() {
	m.last_tender_amount = nil
	m.addlast_tender_amount = nil
	delete(m.clearedFields, tenderprofile.FieldLastTenderAmount)
}

// SetTenderID sets the "tender_id" field.
func (m *TenderProfileMutation) SetTenderID(x xid.ID) {
	m.tender = &x
}

// TenderID returns the value of the "tender_id" field in the mutation.
func (m *TenderProfileMutation) TenderID() (r xid.ID, exists bool) {
	v := m.tender
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderID returns the old "tender_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldTenderID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderID: %w", err)
	}
	return oldValue.TenderID, nil
}

// ResetTenderID resets all changes to the "tender_id" field.
func (m *TenderProfileMutation) ResetTenderID() {
	m.tender = nil
}

// SetProvinceID sets the "province_id" field.
func (m *TenderProfileMutation) SetProvinceID(x xid.ID) {
	m.province = &x
}

// ProvinceID returns the value of the "province_id" field in the mutation.
func (m *TenderProfileMutation) ProvinceID() (r xid.ID, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "province_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldProvinceID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// ClearProvinceID clears the value of the "province_id" field.
func (m *TenderProfileMutation) ClearProvinceID() {
	m.province = nil
	m.clearedFields[tenderprofile.FieldProvinceID] = struct{}{}
}

// ProvinceIDCleared returns if the "province_id" field was cleared in this mutation.
func (m *TenderProfileMutation) ProvinceIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldProvinceID]
	return ok
}

// ResetProvinceID resets all changes to the "province_id" field.
func (m *TenderProfileMutation) ResetProvinceID() {
	m.province = nil
	delete(m.clearedFields, tenderprofile.FieldProvinceID)
}

// SetCityID sets the "city_id" field.
func (m *TenderProfileMutation) SetCityID(x xid.ID) {
	m.city = &x
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *TenderProfileMutation) CityID() (r xid.ID, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCityID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *TenderProfileMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[tenderprofile.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *TenderProfileMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *TenderProfileMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, tenderprofile.FieldCityID)
}

// SetDistrictID sets the "district_id" field.
func (m *TenderProfileMutation) SetDistrictID(x xid.ID) {
	m.district = &x
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *TenderProfileMutation) DistrictID() (r xid.ID, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldDistrictID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ClearDistrictID clears the value of the "district_id" field.
func (m *TenderProfileMutation) ClearDistrictID() {
	m.district = nil
	m.clearedFields[tenderprofile.FieldDistrictID] = struct{}{}
}

// DistrictIDCleared returns if the "district_id" field was cleared in this mutation.
func (m *TenderProfileMutation) DistrictIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldDistrictID]
	return ok
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *TenderProfileMutation) ResetDistrictID() {
	m.district = nil
	delete(m.clearedFields, tenderprofile.FieldDistrictID)
}

// SetCustomerID sets the "customer_id" field.
func (m *TenderProfileMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *TenderProfileMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCustomerID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *TenderProfileMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[tenderprofile.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *TenderProfileMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *TenderProfileMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, tenderprofile.FieldCustomerID)
}

// SetFinderID sets the "finder_id" field.
func (m *TenderProfileMutation) SetFinderID(x xid.ID) {
	m.finder = &x
}

// FinderID returns the value of the "finder_id" field in the mutation.
func (m *TenderProfileMutation) FinderID() (r xid.ID, exists bool) {
	v := m.finder
	if v == nil {
		return
	}
	return *v, true
}

// OldFinderID returns the old "finder_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldFinderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinderID: %w", err)
	}
	return oldValue.FinderID, nil
}

// ClearFinderID clears the value of the "finder_id" field.
func (m *TenderProfileMutation) ClearFinderID() {
	m.finder = nil
	m.clearedFields[tenderprofile.FieldFinderID] = struct{}{}
}

// FinderIDCleared returns if the "finder_id" field was cleared in this mutation.
func (m *TenderProfileMutation) FinderIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldFinderID]
	return ok
}

// ResetFinderID resets all changes to the "finder_id" field.
func (m *TenderProfileMutation) ResetFinderID() {
	m.finder = nil
	delete(m.clearedFields, tenderprofile.FieldFinderID)
}

// SetCreatedByID sets the "created_by_id" field.
func (m *TenderProfileMutation) SetCreatedByID(x xid.ID) {
	m.created_by = &x
}

// CreatedByID returns the value of the "created_by_id" field in the mutation.
func (m *TenderProfileMutation) CreatedByID() (r xid.ID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByID returns the old "created_by_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldCreatedByID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByID: %w", err)
	}
	return oldValue.CreatedByID, nil
}

// ClearCreatedByID clears the value of the "created_by_id" field.
func (m *TenderProfileMutation) ClearCreatedByID() {
	m.created_by = nil
	m.clearedFields[tenderprofile.FieldCreatedByID] = struct{}{}
}

// CreatedByIDCleared returns if the "created_by_id" field was cleared in this mutation.
func (m *TenderProfileMutation) CreatedByIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldCreatedByID]
	return ok
}

// ResetCreatedByID resets all changes to the "created_by_id" field.
func (m *TenderProfileMutation) ResetCreatedByID() {
	m.created_by = nil
	delete(m.clearedFields, tenderprofile.FieldCreatedByID)
}

// SetApproverID sets the "approver_id" field.
func (m *TenderProfileMutation) SetApproverID(x xid.ID) {
	m.approver = &x
}

// ApproverID returns the value of the "approver_id" field in the mutation.
func (m *TenderProfileMutation) ApproverID() (r xid.ID, exists bool) {
	v := m.approver
	if v == nil {
		return
	}
	return *v, true
}

// OldApproverID returns the old "approver_id" field's value of the TenderProfile entity.
// If the TenderProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenderProfileMutation) OldApproverID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproverID: %w", err)
	}
	return oldValue.ApproverID, nil
}

// ClearApproverID clears the value of the "approver_id" field.
func (m *TenderProfileMutation) ClearApproverID() {
	m.approver = nil
	m.clearedFields[tenderprofile.FieldApproverID] = struct{}{}
}

// ApproverIDCleared returns if the "approver_id" field was cleared in this mutation.
func (m *TenderProfileMutation) ApproverIDCleared() bool {
	_, ok := m.clearedFields[tenderprofile.FieldApproverID]
	return ok
}

// ResetApproverID resets all changes to the "approver_id" field.
func (m *TenderProfileMutation) ResetApproverID() {
	m.approver = nil
	delete(m.clearedFields, tenderprofile.FieldApproverID)
}

// ClearTender clears the "tender" edge to the Tender entity.
func (m *TenderProfileMutation) ClearTender() {
	m.clearedtender = true
	m.clearedFields[tenderprofile.FieldTenderID] = struct{}{}
}

// TenderCleared reports if the "tender" edge to the Tender entity was cleared.
func (m *TenderProfileMutation) TenderCleared() bool {
	return m.clearedtender
}

// TenderIDs returns the "tender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenderID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) TenderIDs() (ids []xid.ID) {
	if id := m.tender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTender resets all changes to the "tender" edge.
func (m *TenderProfileMutation) ResetTender() {
	m.tender = nil
	m.clearedtender = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *TenderProfileMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[tenderprofile.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *TenderProfileMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *TenderProfileMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearFinder clears the "finder" edge to the User entity.
func (m *TenderProfileMutation) ClearFinder() {
	m.clearedfinder = true
	m.clearedFields[tenderprofile.FieldFinderID] = struct{}{}
}

// FinderCleared reports if the "finder" edge to the User entity was cleared.
func (m *TenderProfileMutation) FinderCleared() bool {
	return m.FinderIDCleared() || m.clearedfinder
}

// FinderIDs returns the "finder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FinderID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) FinderIDs() (ids []xid.ID) {
	if id := m.finder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFinder resets all changes to the "finder" edge.
func (m *TenderProfileMutation) ResetFinder() {
	m.finder = nil
	m.clearedfinder = false
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *TenderProfileMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
	m.clearedFields[tenderprofile.FieldCreatedByID] = struct{}{}
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *TenderProfileMutation) CreatedByCleared() bool {
	return m.CreatedByIDCleared() || m.clearedcreated_by
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) CreatedByIDs() (ids []xid.ID) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *TenderProfileMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// ClearProvince clears the "province" edge to the Province entity.
func (m *TenderProfileMutation) ClearProvince() {
	m.clearedprovince = true
	m.clearedFields[tenderprofile.FieldProvinceID] = struct{}{}
}

// ProvinceCleared reports if the "province" edge to the Province entity was cleared.
func (m *TenderProfileMutation) ProvinceCleared() bool {
	return m.ProvinceIDCleared() || m.clearedprovince
}

// ProvinceIDs returns the "province" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvinceID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) ProvinceIDs() (ids []xid.ID) {
	if id := m.province; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvince resets all changes to the "province" edge.
func (m *TenderProfileMutation) ResetProvince() {
	m.province = nil
	m.clearedprovince = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *TenderProfileMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[tenderprofile.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *TenderProfileMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) CityIDs() (ids []xid.ID) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *TenderProfileMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *TenderProfileMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[tenderprofile.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *TenderProfileMutation) DistrictCleared() bool {
	return m.DistrictIDCleared() || m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) DistrictIDs() (ids []xid.ID) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *TenderProfileMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// ClearApprover clears the "approver" edge to the User entity.
func (m *TenderProfileMutation) ClearApprover() {
	m.clearedapprover = true
	m.clearedFields[tenderprofile.FieldApproverID] = struct{}{}
}

// ApproverCleared reports if the "approver" edge to the User entity was cleared.
func (m *TenderProfileMutation) ApproverCleared() bool {
	return m.ApproverIDCleared() || m.clearedapprover
}

// ApproverIDs returns the "approver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApproverID instead. It exists only for internal usage by the builders.
func (m *TenderProfileMutation) ApproverIDs() (ids []xid.ID) {
	if id := m.approver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApprover resets all changes to the "approver" edge.
func (m *TenderProfileMutation) ResetApprover() {
	m.approver = nil
	m.clearedapprover = false
}

// Where appends a list predicates to the TenderProfileMutation builder.
func (m *TenderProfileMutation) Where(ps ...predicate.TenderProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenderProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenderProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenderProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenderProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenderProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenderProfile).
func (m *TenderProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenderProfileMutation) Fields() []string {
	fields := make([]string, 0, 67)
	if m.created_at != nil {
		fields = append(fields, tenderprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tenderprofile.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tenderprofile.FieldStatus)
	}
	if m.approval_status != nil {
		fields = append(fields, tenderprofile.FieldApprovalStatus)
	}
	if m.approval_msg_id != nil {
		fields = append(fields, tenderprofile.FieldApprovalMsgID)
	}
	if m.name != nil {
		fields = append(fields, tenderprofile.FieldName)
	}
	if m.estimated_amount != nil {
		fields = append(fields, tenderprofile.FieldEstimatedAmount)
	}
	if m.tender_date != nil {
		fields = append(fields, tenderprofile.FieldTenderDate)
	}
	if m.classify != nil {
		fields = append(fields, tenderprofile.FieldClassify)
	}
	if m.discovery_date != nil {
		fields = append(fields, tenderprofile.FieldDiscoveryDate)
	}
	if m.address != nil {
		fields = append(fields, tenderprofile.FieldAddress)
	}
	if m.full_address != nil {
		fields = append(fields, tenderprofile.FieldFullAddress)
	}
	if m.contractor != nil {
		fields = append(fields, tenderprofile.FieldContractor)
	}
	if m.level_involved != nil {
		fields = append(fields, tenderprofile.FieldLevelInvolved)
	}
	if m.size_and_value_rating != nil {
		fields = append(fields, tenderprofile.FieldSizeAndValueRating)
	}
	if m.size_and_value_rating_overview != nil {
		fields = append(fields, tenderprofile.FieldSizeAndValueRatingOverview)
	}
	if m.credit_and_payment_rating != nil {
		fields = append(fields, tenderprofile.FieldCreditAndPaymentRating)
	}
	if m.credit_and_payment_rating_overview != nil {
		fields = append(fields, tenderprofile.FieldCreditAndPaymentRatingOverview)
	}
	if m.time_limit_rating != nil {
		fields = append(fields, tenderprofile.FieldTimeLimitRating)
	}
	if m.time_limit_rating_overview != nil {
		fields = append(fields, tenderprofile.FieldTimeLimitRatingOverview)
	}
	if m.customer_relationship_rating != nil {
		fields = append(fields, tenderprofile.FieldCustomerRelationshipRating)
	}
	if m.customer_relationship_rating_overview != nil {
		fields = append(fields, tenderprofile.FieldCustomerRelationshipRatingOverview)
	}
	if m.competitive_partnership_rating != nil {
		fields = append(fields, tenderprofile.FieldCompetitivePartnershipRating)
	}
	if m.competitive_partnership_rating_overview != nil {
		fields = append(fields, tenderprofile.FieldCompetitivePartnershipRatingOverview)
	}
	if m.prepare_to_bid != nil {
		fields = append(fields, tenderprofile.FieldPrepareToBid)
	}
	if m.project_code != nil {
		fields = append(fields, tenderprofile.FieldProjectCode)
	}
	if m.project_type != nil {
		fields = append(fields, tenderprofile.FieldProjectType)
	}
	if m.project_definition != nil {
		fields = append(fields, tenderprofile.FieldProjectDefinition)
	}
	if m.estimated_project_start_date != nil {
		fields = append(fields, tenderprofile.FieldEstimatedProjectStartDate)
	}
	if m.estimated_project_end_date != nil {
		fields = append(fields, tenderprofile.FieldEstimatedProjectEndDate)
	}
	if m.attachments != nil {
		fields = append(fields, tenderprofile.FieldAttachments)
	}
	if m.geo_coordinate != nil {
		fields = append(fields, tenderprofile.FieldGeoCoordinate)
	}
	if m.geo_bounds != nil {
		fields = append(fields, tenderprofile.FieldGeoBounds)
	}
	if m.remark != nil {
		fields = append(fields, tenderprofile.FieldRemark)
	}
	if m.images != nil {
		fields = append(fields, tenderprofile.FieldImages)
	}
	if m.tender_situations != nil {
		fields = append(fields, tenderprofile.FieldTenderSituations)
	}
	if m.owner_situations != nil {
		fields = append(fields, tenderprofile.FieldOwnerSituations)
	}
	if m.bidding_instructions != nil {
		fields = append(fields, tenderprofile.FieldBiddingInstructions)
	}
	if m.competitor_situations != nil {
		fields = append(fields, tenderprofile.FieldCompetitorSituations)
	}
	if m.cost_engineer != nil {
		fields = append(fields, tenderprofile.FieldCostEngineer)
	}
	if m.tender_form != nil {
		fields = append(fields, tenderprofile.FieldTenderForm)
	}
	if m.contract_form != nil {
		fields = append(fields, tenderprofile.FieldContractForm)
	}
	if m.management_company != nil {
		fields = append(fields, tenderprofile.FieldManagementCompany)
	}
	if m.tendering_agency != nil {
		fields = append(fields, tenderprofile.FieldTenderingAgency)
	}
	if m.bidding_date != nil {
		fields = append(fields, tenderprofile.FieldBiddingDate)
	}
	if m.facade_consultant != nil {
		fields = append(fields, tenderprofile.FieldFacadeConsultant)
	}
	if m.design_unit != nil {
		fields = append(fields, tenderprofile.FieldDesignUnit)
	}
	if m.consulting_firm != nil {
		fields = append(fields, tenderprofile.FieldConsultingFirm)
	}
	if m.key_project != nil {
		fields = append(fields, tenderprofile.FieldKeyProject)
	}
	if m.current_progress != nil {
		fields = append(fields, tenderprofile.FieldCurrentProgress)
	}
	if m.tender_win_company != nil {
		fields = append(fields, tenderprofile.FieldTenderWinCompany)
	}
	if m.tender_code != nil {
		fields = append(fields, tenderprofile.FieldTenderCode)
	}
	if m.architect != nil {
		fields = append(fields, tenderprofile.FieldArchitect)
	}
	if m.developer != nil {
		fields = append(fields, tenderprofile.FieldDeveloper)
	}
	if m.tender_closing_date != nil {
		fields = append(fields, tenderprofile.FieldTenderClosingDate)
	}
	if m.construction_area != nil {
		fields = append(fields, tenderprofile.FieldConstructionArea)
	}
	if m.tender_win_date != nil {
		fields = append(fields, tenderprofile.FieldTenderWinDate)
	}
	if m.tender_win_amount != nil {
		fields = append(fields, tenderprofile.FieldTenderWinAmount)
	}
	if m.last_tender_amount != nil {
		fields = append(fields, tenderprofile.FieldLastTenderAmount)
	}
	if m.tender != nil {
		fields = append(fields, tenderprofile.FieldTenderID)
	}
	if m.province != nil {
		fields = append(fields, tenderprofile.FieldProvinceID)
	}
	if m.city != nil {
		fields = append(fields, tenderprofile.FieldCityID)
	}
	if m.district != nil {
		fields = append(fields, tenderprofile.FieldDistrictID)
	}
	if m.customer != nil {
		fields = append(fields, tenderprofile.FieldCustomerID)
	}
	if m.finder != nil {
		fields = append(fields, tenderprofile.FieldFinderID)
	}
	if m.created_by != nil {
		fields = append(fields, tenderprofile.FieldCreatedByID)
	}
	if m.approver != nil {
		fields = append(fields, tenderprofile.FieldApproverID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenderProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenderprofile.FieldCreatedAt:
		return m.CreatedAt()
	case tenderprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenderprofile.FieldStatus:
		return m.Status()
	case tenderprofile.FieldApprovalStatus:
		return m.ApprovalStatus()
	case tenderprofile.FieldApprovalMsgID:
		return m.ApprovalMsgID()
	case tenderprofile.FieldName:
		return m.Name()
	case tenderprofile.FieldEstimatedAmount:
		return m.EstimatedAmount()
	case tenderprofile.FieldTenderDate:
		return m.TenderDate()
	case tenderprofile.FieldClassify:
		return m.Classify()
	case tenderprofile.FieldDiscoveryDate:
		return m.DiscoveryDate()
	case tenderprofile.FieldAddress:
		return m.Address()
	case tenderprofile.FieldFullAddress:
		return m.FullAddress()
	case tenderprofile.FieldContractor:
		return m.Contractor()
	case tenderprofile.FieldLevelInvolved:
		return m.LevelInvolved()
	case tenderprofile.FieldSizeAndValueRating:
		return m.SizeAndValueRating()
	case tenderprofile.FieldSizeAndValueRatingOverview:
		return m.SizeAndValueRatingOverview()
	case tenderprofile.FieldCreditAndPaymentRating:
		return m.CreditAndPaymentRating()
	case tenderprofile.FieldCreditAndPaymentRatingOverview:
		return m.CreditAndPaymentRatingOverview()
	case tenderprofile.FieldTimeLimitRating:
		return m.TimeLimitRating()
	case tenderprofile.FieldTimeLimitRatingOverview:
		return m.TimeLimitRatingOverview()
	case tenderprofile.FieldCustomerRelationshipRating:
		return m.CustomerRelationshipRating()
	case tenderprofile.FieldCustomerRelationshipRatingOverview:
		return m.CustomerRelationshipRatingOverview()
	case tenderprofile.FieldCompetitivePartnershipRating:
		return m.CompetitivePartnershipRating()
	case tenderprofile.FieldCompetitivePartnershipRatingOverview:
		return m.CompetitivePartnershipRatingOverview()
	case tenderprofile.FieldPrepareToBid:
		return m.PrepareToBid()
	case tenderprofile.FieldProjectCode:
		return m.ProjectCode()
	case tenderprofile.FieldProjectType:
		return m.ProjectType()
	case tenderprofile.FieldProjectDefinition:
		return m.ProjectDefinition()
	case tenderprofile.FieldEstimatedProjectStartDate:
		return m.EstimatedProjectStartDate()
	case tenderprofile.FieldEstimatedProjectEndDate:
		return m.EstimatedProjectEndDate()
	case tenderprofile.FieldAttachments:
		return m.Attachments()
	case tenderprofile.FieldGeoCoordinate:
		return m.GeoCoordinate()
	case tenderprofile.FieldGeoBounds:
		return m.GeoBounds()
	case tenderprofile.FieldRemark:
		return m.Remark()
	case tenderprofile.FieldImages:
		return m.Images()
	case tenderprofile.FieldTenderSituations:
		return m.TenderSituations()
	case tenderprofile.FieldOwnerSituations:
		return m.OwnerSituations()
	case tenderprofile.FieldBiddingInstructions:
		return m.BiddingInstructions()
	case tenderprofile.FieldCompetitorSituations:
		return m.CompetitorSituations()
	case tenderprofile.FieldCostEngineer:
		return m.CostEngineer()
	case tenderprofile.FieldTenderForm:
		return m.TenderForm()
	case tenderprofile.FieldContractForm:
		return m.ContractForm()
	case tenderprofile.FieldManagementCompany:
		return m.ManagementCompany()
	case tenderprofile.FieldTenderingAgency:
		return m.TenderingAgency()
	case tenderprofile.FieldBiddingDate:
		return m.BiddingDate()
	case tenderprofile.FieldFacadeConsultant:
		return m.FacadeConsultant()
	case tenderprofile.FieldDesignUnit:
		return m.DesignUnit()
	case tenderprofile.FieldConsultingFirm:
		return m.ConsultingFirm()
	case tenderprofile.FieldKeyProject:
		return m.KeyProject()
	case tenderprofile.FieldCurrentProgress:
		return m.CurrentProgress()
	case tenderprofile.FieldTenderWinCompany:
		return m.TenderWinCompany()
	case tenderprofile.FieldTenderCode:
		return m.TenderCode()
	case tenderprofile.FieldArchitect:
		return m.Architect()
	case tenderprofile.FieldDeveloper:
		return m.Developer()
	case tenderprofile.FieldTenderClosingDate:
		return m.TenderClosingDate()
	case tenderprofile.FieldConstructionArea:
		return m.ConstructionArea()
	case tenderprofile.FieldTenderWinDate:
		return m.TenderWinDate()
	case tenderprofile.FieldTenderWinAmount:
		return m.TenderWinAmount()
	case tenderprofile.FieldLastTenderAmount:
		return m.LastTenderAmount()
	case tenderprofile.FieldTenderID:
		return m.TenderID()
	case tenderprofile.FieldProvinceID:
		return m.ProvinceID()
	case tenderprofile.FieldCityID:
		return m.CityID()
	case tenderprofile.FieldDistrictID:
		return m.DistrictID()
	case tenderprofile.FieldCustomerID:
		return m.CustomerID()
	case tenderprofile.FieldFinderID:
		return m.FinderID()
	case tenderprofile.FieldCreatedByID:
		return m.CreatedByID()
	case tenderprofile.FieldApproverID:
		return m.ApproverID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenderProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenderprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenderprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenderprofile.FieldStatus:
		return m.OldStatus(ctx)
	case tenderprofile.FieldApprovalStatus:
		return m.OldApprovalStatus(ctx)
	case tenderprofile.FieldApprovalMsgID:
		return m.OldApprovalMsgID(ctx)
	case tenderprofile.FieldName:
		return m.OldName(ctx)
	case tenderprofile.FieldEstimatedAmount:
		return m.OldEstimatedAmount(ctx)
	case tenderprofile.FieldTenderDate:
		return m.OldTenderDate(ctx)
	case tenderprofile.FieldClassify:
		return m.OldClassify(ctx)
	case tenderprofile.FieldDiscoveryDate:
		return m.OldDiscoveryDate(ctx)
	case tenderprofile.FieldAddress:
		return m.OldAddress(ctx)
	case tenderprofile.FieldFullAddress:
		return m.OldFullAddress(ctx)
	case tenderprofile.FieldContractor:
		return m.OldContractor(ctx)
	case tenderprofile.FieldLevelInvolved:
		return m.OldLevelInvolved(ctx)
	case tenderprofile.FieldSizeAndValueRating:
		return m.OldSizeAndValueRating(ctx)
	case tenderprofile.FieldSizeAndValueRatingOverview:
		return m.OldSizeAndValueRatingOverview(ctx)
	case tenderprofile.FieldCreditAndPaymentRating:
		return m.OldCreditAndPaymentRating(ctx)
	case tenderprofile.FieldCreditAndPaymentRatingOverview:
		return m.OldCreditAndPaymentRatingOverview(ctx)
	case tenderprofile.FieldTimeLimitRating:
		return m.OldTimeLimitRating(ctx)
	case tenderprofile.FieldTimeLimitRatingOverview:
		return m.OldTimeLimitRatingOverview(ctx)
	case tenderprofile.FieldCustomerRelationshipRating:
		return m.OldCustomerRelationshipRating(ctx)
	case tenderprofile.FieldCustomerRelationshipRatingOverview:
		return m.OldCustomerRelationshipRatingOverview(ctx)
	case tenderprofile.FieldCompetitivePartnershipRating:
		return m.OldCompetitivePartnershipRating(ctx)
	case tenderprofile.FieldCompetitivePartnershipRatingOverview:
		return m.OldCompetitivePartnershipRatingOverview(ctx)
	case tenderprofile.FieldPrepareToBid:
		return m.OldPrepareToBid(ctx)
	case tenderprofile.FieldProjectCode:
		return m.OldProjectCode(ctx)
	case tenderprofile.FieldProjectType:
		return m.OldProjectType(ctx)
	case tenderprofile.FieldProjectDefinition:
		return m.OldProjectDefinition(ctx)
	case tenderprofile.FieldEstimatedProjectStartDate:
		return m.OldEstimatedProjectStartDate(ctx)
	case tenderprofile.FieldEstimatedProjectEndDate:
		return m.OldEstimatedProjectEndDate(ctx)
	case tenderprofile.FieldAttachments:
		return m.OldAttachments(ctx)
	case tenderprofile.FieldGeoCoordinate:
		return m.OldGeoCoordinate(ctx)
	case tenderprofile.FieldGeoBounds:
		return m.OldGeoBounds(ctx)
	case tenderprofile.FieldRemark:
		return m.OldRemark(ctx)
	case tenderprofile.FieldImages:
		return m.OldImages(ctx)
	case tenderprofile.FieldTenderSituations:
		return m.OldTenderSituations(ctx)
	case tenderprofile.FieldOwnerSituations:
		return m.OldOwnerSituations(ctx)
	case tenderprofile.FieldBiddingInstructions:
		return m.OldBiddingInstructions(ctx)
	case tenderprofile.FieldCompetitorSituations:
		return m.OldCompetitorSituations(ctx)
	case tenderprofile.FieldCostEngineer:
		return m.OldCostEngineer(ctx)
	case tenderprofile.FieldTenderForm:
		return m.OldTenderForm(ctx)
	case tenderprofile.FieldContractForm:
		return m.OldContractForm(ctx)
	case tenderprofile.FieldManagementCompany:
		return m.OldManagementCompany(ctx)
	case tenderprofile.FieldTenderingAgency:
		return m.OldTenderingAgency(ctx)
	case tenderprofile.FieldBiddingDate:
		return m.OldBiddingDate(ctx)
	case tenderprofile.FieldFacadeConsultant:
		return m.OldFacadeConsultant(ctx)
	case tenderprofile.FieldDesignUnit:
		return m.OldDesignUnit(ctx)
	case tenderprofile.FieldConsultingFirm:
		return m.OldConsultingFirm(ctx)
	case tenderprofile.FieldKeyProject:
		return m.OldKeyProject(ctx)
	case tenderprofile.FieldCurrentProgress:
		return m.OldCurrentProgress(ctx)
	case tenderprofile.FieldTenderWinCompany:
		return m.OldTenderWinCompany(ctx)
	case tenderprofile.FieldTenderCode:
		return m.OldTenderCode(ctx)
	case tenderprofile.FieldArchitect:
		return m.OldArchitect(ctx)
	case tenderprofile.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case tenderprofile.FieldTenderClosingDate:
		return m.OldTenderClosingDate(ctx)
	case tenderprofile.FieldConstructionArea:
		return m.OldConstructionArea(ctx)
	case tenderprofile.FieldTenderWinDate:
		return m.OldTenderWinDate(ctx)
	case tenderprofile.FieldTenderWinAmount:
		return m.OldTenderWinAmount(ctx)
	case tenderprofile.FieldLastTenderAmount:
		return m.OldLastTenderAmount(ctx)
	case tenderprofile.FieldTenderID:
		return m.OldTenderID(ctx)
	case tenderprofile.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case tenderprofile.FieldCityID:
		return m.OldCityID(ctx)
	case tenderprofile.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case tenderprofile.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case tenderprofile.FieldFinderID:
		return m.OldFinderID(ctx)
	case tenderprofile.FieldCreatedByID:
		return m.OldCreatedByID(ctx)
	case tenderprofile.FieldApproverID:
		return m.OldApproverID(ctx)
	}
	return nil, fmt.Errorf("unknown TenderProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenderprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenderprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenderprofile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tenderprofile.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalStatus(v)
		return nil
	case tenderprofile.FieldApprovalMsgID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalMsgID(v)
		return nil
	case tenderprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenderprofile.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedAmount(v)
		return nil
	case tenderprofile.FieldTenderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderDate(v)
		return nil
	case tenderprofile.FieldClassify:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassify(v)
		return nil
	case tenderprofile.FieldDiscoveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryDate(v)
		return nil
	case tenderprofile.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tenderprofile.FieldFullAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullAddress(v)
		return nil
	case tenderprofile.FieldContractor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractor(v)
		return nil
	case tenderprofile.FieldLevelInvolved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelInvolved(v)
		return nil
	case tenderprofile.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRating(v)
		return nil
	case tenderprofile.FieldSizeAndValueRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeAndValueRatingOverview(v)
		return nil
	case tenderprofile.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRating(v)
		return nil
	case tenderprofile.FieldCreditAndPaymentRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAndPaymentRatingOverview(v)
		return nil
	case tenderprofile.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRating(v)
		return nil
	case tenderprofile.FieldTimeLimitRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeLimitRatingOverview(v)
		return nil
	case tenderprofile.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRating(v)
		return nil
	case tenderprofile.FieldCustomerRelationshipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerRelationshipRatingOverview(v)
		return nil
	case tenderprofile.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRating(v)
		return nil
	case tenderprofile.FieldCompetitivePartnershipRatingOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitivePartnershipRatingOverview(v)
		return nil
	case tenderprofile.FieldPrepareToBid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepareToBid(v)
		return nil
	case tenderprofile.FieldProjectCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectCode(v)
		return nil
	case tenderprofile.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case tenderprofile.FieldProjectDefinition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectDefinition(v)
		return nil
	case tenderprofile.FieldEstimatedProjectStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectStartDate(v)
		return nil
	case tenderprofile.FieldEstimatedProjectEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedProjectEndDate(v)
		return nil
	case tenderprofile.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case tenderprofile.FieldGeoCoordinate:
		v, ok := value.([]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoCoordinate(v)
		return nil
	case tenderprofile.FieldGeoBounds:
		v, ok := value.([][]float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoBounds(v)
		return nil
	case tenderprofile.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case tenderprofile.FieldImages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case tenderprofile.FieldTenderSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderSituations(v)
		return nil
	case tenderprofile.FieldOwnerSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSituations(v)
		return nil
	case tenderprofile.FieldBiddingInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingInstructions(v)
		return nil
	case tenderprofile.FieldCompetitorSituations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitorSituations(v)
		return nil
	case tenderprofile.FieldCostEngineer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostEngineer(v)
		return nil
	case tenderprofile.FieldTenderForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderForm(v)
		return nil
	case tenderprofile.FieldContractForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractForm(v)
		return nil
	case tenderprofile.FieldManagementCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagementCompany(v)
		return nil
	case tenderprofile.FieldTenderingAgency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderingAgency(v)
		return nil
	case tenderprofile.FieldBiddingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiddingDate(v)
		return nil
	case tenderprofile.FieldFacadeConsultant:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacadeConsultant(v)
		return nil
	case tenderprofile.FieldDesignUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesignUnit(v)
		return nil
	case tenderprofile.FieldConsultingFirm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsultingFirm(v)
		return nil
	case tenderprofile.FieldKeyProject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyProject(v)
		return nil
	case tenderprofile.FieldCurrentProgress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentProgress(v)
		return nil
	case tenderprofile.FieldTenderWinCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinCompany(v)
		return nil
	case tenderprofile.FieldTenderCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderCode(v)
		return nil
	case tenderprofile.FieldArchitect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitect(v)
		return nil
	case tenderprofile.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case tenderprofile.FieldTenderClosingDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderClosingDate(v)
		return nil
	case tenderprofile.FieldConstructionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionArea(v)
		return nil
	case tenderprofile.FieldTenderWinDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinDate(v)
		return nil
	case tenderprofile.FieldTenderWinAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderWinAmount(v)
		return nil
	case tenderprofile.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTenderAmount(v)
		return nil
	case tenderprofile.FieldTenderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderID(v)
		return nil
	case tenderprofile.FieldProvinceID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case tenderprofile.FieldCityID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case tenderprofile.FieldDistrictID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case tenderprofile.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case tenderprofile.FieldFinderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinderID(v)
		return nil
	case tenderprofile.FieldCreatedByID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByID(v)
		return nil
	case tenderprofile.FieldApproverID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproverID(v)
		return nil
	}
	return fmt.Errorf("unknown TenderProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenderProfileMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, tenderprofile.FieldStatus)
	}
	if m.addapproval_status != nil {
		fields = append(fields, tenderprofile.FieldApprovalStatus)
	}
	if m.addestimated_amount != nil {
		fields = append(fields, tenderprofile.FieldEstimatedAmount)
	}
	if m.addclassify != nil {
		fields = append(fields, tenderprofile.FieldClassify)
	}
	if m.addlevel_involved != nil {
		fields = append(fields, tenderprofile.FieldLevelInvolved)
	}
	if m.addsize_and_value_rating != nil {
		fields = append(fields, tenderprofile.FieldSizeAndValueRating)
	}
	if m.addcredit_and_payment_rating != nil {
		fields = append(fields, tenderprofile.FieldCreditAndPaymentRating)
	}
	if m.addtime_limit_rating != nil {
		fields = append(fields, tenderprofile.FieldTimeLimitRating)
	}
	if m.addcustomer_relationship_rating != nil {
		fields = append(fields, tenderprofile.FieldCustomerRelationshipRating)
	}
	if m.addcompetitive_partnership_rating != nil {
		fields = append(fields, tenderprofile.FieldCompetitivePartnershipRating)
	}
	if m.addtender_win_amount != nil {
		fields = append(fields, tenderprofile.FieldTenderWinAmount)
	}
	if m.addlast_tender_amount != nil {
		fields = append(fields, tenderprofile.FieldLastTenderAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenderProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenderprofile.FieldStatus:
		return m.AddedStatus()
	case tenderprofile.FieldApprovalStatus:
		return m.AddedApprovalStatus()
	case tenderprofile.FieldEstimatedAmount:
		return m.AddedEstimatedAmount()
	case tenderprofile.FieldClassify:
		return m.AddedClassify()
	case tenderprofile.FieldLevelInvolved:
		return m.AddedLevelInvolved()
	case tenderprofile.FieldSizeAndValueRating:
		return m.AddedSizeAndValueRating()
	case tenderprofile.FieldCreditAndPaymentRating:
		return m.AddedCreditAndPaymentRating()
	case tenderprofile.FieldTimeLimitRating:
		return m.AddedTimeLimitRating()
	case tenderprofile.FieldCustomerRelationshipRating:
		return m.AddedCustomerRelationshipRating()
	case tenderprofile.FieldCompetitivePartnershipRating:
		return m.AddedCompetitivePartnershipRating()
	case tenderprofile.FieldTenderWinAmount:
		return m.AddedTenderWinAmount()
	case tenderprofile.FieldLastTenderAmount:
		return m.AddedLastTenderAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenderProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenderprofile.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case tenderprofile.FieldApprovalStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApprovalStatus(v)
		return nil
	case tenderprofile.FieldEstimatedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedAmount(v)
		return nil
	case tenderprofile.FieldClassify:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassify(v)
		return nil
	case tenderprofile.FieldLevelInvolved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevelInvolved(v)
		return nil
	case tenderprofile.FieldSizeAndValueRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeAndValueRating(v)
		return nil
	case tenderprofile.FieldCreditAndPaymentRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAndPaymentRating(v)
		return nil
	case tenderprofile.FieldTimeLimitRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeLimitRating(v)
		return nil
	case tenderprofile.FieldCustomerRelationshipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerRelationshipRating(v)
		return nil
	case tenderprofile.FieldCompetitivePartnershipRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompetitivePartnershipRating(v)
		return nil
	case tenderprofile.FieldTenderWinAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenderWinAmount(v)
		return nil
	case tenderprofile.FieldLastTenderAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastTenderAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TenderProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenderProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenderprofile.FieldApprovalMsgID) {
		fields = append(fields, tenderprofile.FieldApprovalMsgID)
	}
	if m.FieldCleared(tenderprofile.FieldName) {
		fields = append(fields, tenderprofile.FieldName)
	}
	if m.FieldCleared(tenderprofile.FieldEstimatedAmount) {
		fields = append(fields, tenderprofile.FieldEstimatedAmount)
	}
	if m.FieldCleared(tenderprofile.FieldTenderDate) {
		fields = append(fields, tenderprofile.FieldTenderDate)
	}
	if m.FieldCleared(tenderprofile.FieldClassify) {
		fields = append(fields, tenderprofile.FieldClassify)
	}
	if m.FieldCleared(tenderprofile.FieldDiscoveryDate) {
		fields = append(fields, tenderprofile.FieldDiscoveryDate)
	}
	if m.FieldCleared(tenderprofile.FieldAddress) {
		fields = append(fields, tenderprofile.FieldAddress)
	}
	if m.FieldCleared(tenderprofile.FieldFullAddress) {
		fields = append(fields, tenderprofile.FieldFullAddress)
	}
	if m.FieldCleared(tenderprofile.FieldContractor) {
		fields = append(fields, tenderprofile.FieldContractor)
	}
	if m.FieldCleared(tenderprofile.FieldLevelInvolved) {
		fields = append(fields, tenderprofile.FieldLevelInvolved)
	}
	if m.FieldCleared(tenderprofile.FieldSizeAndValueRating) {
		fields = append(fields, tenderprofile.FieldSizeAndValueRating)
	}
	if m.FieldCleared(tenderprofile.FieldSizeAndValueRatingOverview) {
		fields = append(fields, tenderprofile.FieldSizeAndValueRatingOverview)
	}
	if m.FieldCleared(tenderprofile.FieldCreditAndPaymentRating) {
		fields = append(fields, tenderprofile.FieldCreditAndPaymentRating)
	}
	if m.FieldCleared(tenderprofile.FieldCreditAndPaymentRatingOverview) {
		fields = append(fields, tenderprofile.FieldCreditAndPaymentRatingOverview)
	}
	if m.FieldCleared(tenderprofile.FieldTimeLimitRating) {
		fields = append(fields, tenderprofile.FieldTimeLimitRating)
	}
	if m.FieldCleared(tenderprofile.FieldTimeLimitRatingOverview) {
		fields = append(fields, tenderprofile.FieldTimeLimitRatingOverview)
	}
	if m.FieldCleared(tenderprofile.FieldCustomerRelationshipRating) {
		fields = append(fields, tenderprofile.FieldCustomerRelationshipRating)
	}
	if m.FieldCleared(tenderprofile.FieldCustomerRelationshipRatingOverview) {
		fields = append(fields, tenderprofile.FieldCustomerRelationshipRatingOverview)
	}
	if m.FieldCleared(tenderprofile.FieldCompetitivePartnershipRating) {
		fields = append(fields, tenderprofile.FieldCompetitivePartnershipRating)
	}
	if m.FieldCleared(tenderprofile.FieldCompetitivePartnershipRatingOverview) {
		fields = append(fields, tenderprofile.FieldCompetitivePartnershipRatingOverview)
	}
	if m.FieldCleared(tenderprofile.FieldProjectCode) {
		fields = append(fields, tenderprofile.FieldProjectCode)
	}
	if m.FieldCleared(tenderprofile.FieldProjectType) {
		fields = append(fields, tenderprofile.FieldProjectType)
	}
	if m.FieldCleared(tenderprofile.FieldProjectDefinition) {
		fields = append(fields, tenderprofile.FieldProjectDefinition)
	}
	if m.FieldCleared(tenderprofile.FieldEstimatedProjectStartDate) {
		fields = append(fields, tenderprofile.FieldEstimatedProjectStartDate)
	}
	if m.FieldCleared(tenderprofile.FieldEstimatedProjectEndDate) {
		fields = append(fields, tenderprofile.FieldEstimatedProjectEndDate)
	}
	if m.FieldCleared(tenderprofile.FieldAttachments) {
		fields = append(fields, tenderprofile.FieldAttachments)
	}
	if m.FieldCleared(tenderprofile.FieldGeoCoordinate) {
		fields = append(fields, tenderprofile.FieldGeoCoordinate)
	}
	if m.FieldCleared(tenderprofile.FieldGeoBounds) {
		fields = append(fields, tenderprofile.FieldGeoBounds)
	}
	if m.FieldCleared(tenderprofile.FieldRemark) {
		fields = append(fields, tenderprofile.FieldRemark)
	}
	if m.FieldCleared(tenderprofile.FieldImages) {
		fields = append(fields, tenderprofile.FieldImages)
	}
	if m.FieldCleared(tenderprofile.FieldTenderSituations) {
		fields = append(fields, tenderprofile.FieldTenderSituations)
	}
	if m.FieldCleared(tenderprofile.FieldOwnerSituations) {
		fields = append(fields, tenderprofile.FieldOwnerSituations)
	}
	if m.FieldCleared(tenderprofile.FieldBiddingInstructions) {
		fields = append(fields, tenderprofile.FieldBiddingInstructions)
	}
	if m.FieldCleared(tenderprofile.FieldCompetitorSituations) {
		fields = append(fields, tenderprofile.FieldCompetitorSituations)
	}
	if m.FieldCleared(tenderprofile.FieldCostEngineer) {
		fields = append(fields, tenderprofile.FieldCostEngineer)
	}
	if m.FieldCleared(tenderprofile.FieldTenderForm) {
		fields = append(fields, tenderprofile.FieldTenderForm)
	}
	if m.FieldCleared(tenderprofile.FieldContractForm) {
		fields = append(fields, tenderprofile.FieldContractForm)
	}
	if m.FieldCleared(tenderprofile.FieldManagementCompany) {
		fields = append(fields, tenderprofile.FieldManagementCompany)
	}
	if m.FieldCleared(tenderprofile.FieldTenderingAgency) {
		fields = append(fields, tenderprofile.FieldTenderingAgency)
	}
	if m.FieldCleared(tenderprofile.FieldBiddingDate) {
		fields = append(fields, tenderprofile.FieldBiddingDate)
	}
	if m.FieldCleared(tenderprofile.FieldFacadeConsultant) {
		fields = append(fields, tenderprofile.FieldFacadeConsultant)
	}
	if m.FieldCleared(tenderprofile.FieldDesignUnit) {
		fields = append(fields, tenderprofile.FieldDesignUnit)
	}
	if m.FieldCleared(tenderprofile.FieldConsultingFirm) {
		fields = append(fields, tenderprofile.FieldConsultingFirm)
	}
	if m.FieldCleared(tenderprofile.FieldCurrentProgress) {
		fields = append(fields, tenderprofile.FieldCurrentProgress)
	}
	if m.FieldCleared(tenderprofile.FieldTenderWinCompany) {
		fields = append(fields, tenderprofile.FieldTenderWinCompany)
	}
	if m.FieldCleared(tenderprofile.FieldTenderCode) {
		fields = append(fields, tenderprofile.FieldTenderCode)
	}
	if m.FieldCleared(tenderprofile.FieldArchitect) {
		fields = append(fields, tenderprofile.FieldArchitect)
	}
	if m.FieldCleared(tenderprofile.FieldDeveloper) {
		fields = append(fields, tenderprofile.FieldDeveloper)
	}
	if m.FieldCleared(tenderprofile.FieldTenderClosingDate) {
		fields = append(fields, tenderprofile.FieldTenderClosingDate)
	}
	if m.FieldCleared(tenderprofile.FieldConstructionArea) {
		fields = append(fields, tenderprofile.FieldConstructionArea)
	}
	if m.FieldCleared(tenderprofile.FieldTenderWinDate) {
		fields = append(fields, tenderprofile.FieldTenderWinDate)
	}
	if m.FieldCleared(tenderprofile.FieldTenderWinAmount) {
		fields = append(fields, tenderprofile.FieldTenderWinAmount)
	}
	if m.FieldCleared(tenderprofile.FieldLastTenderAmount) {
		fields = append(fields, tenderprofile.FieldLastTenderAmount)
	}
	if m.FieldCleared(tenderprofile.FieldProvinceID) {
		fields = append(fields, tenderprofile.FieldProvinceID)
	}
	if m.FieldCleared(tenderprofile.FieldCityID) {
		fields = append(fields, tenderprofile.FieldCityID)
	}
	if m.FieldCleared(tenderprofile.FieldDistrictID) {
		fields = append(fields, tenderprofile.FieldDistrictID)
	}
	if m.FieldCleared(tenderprofile.FieldCustomerID) {
		fields = append(fields, tenderprofile.FieldCustomerID)
	}
	if m.FieldCleared(tenderprofile.FieldFinderID) {
		fields = append(fields, tenderprofile.FieldFinderID)
	}
	if m.FieldCleared(tenderprofile.FieldCreatedByID) {
		fields = append(fields, tenderprofile.FieldCreatedByID)
	}
	if m.FieldCleared(tenderprofile.FieldApproverID) {
		fields = append(fields, tenderprofile.FieldApproverID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenderProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenderProfileMutation) ClearField(name string) error {
	switch name {
	case tenderprofile.FieldApprovalMsgID:
		m.ClearApprovalMsgID()
		return nil
	case tenderprofile.FieldName:
		m.ClearName()
		return nil
	case tenderprofile.FieldEstimatedAmount:
		m.ClearEstimatedAmount()
		return nil
	case tenderprofile.FieldTenderDate:
		m.ClearTenderDate()
		return nil
	case tenderprofile.FieldClassify:
		m.ClearClassify()
		return nil
	case tenderprofile.FieldDiscoveryDate:
		m.ClearDiscoveryDate()
		return nil
	case tenderprofile.FieldAddress:
		m.ClearAddress()
		return nil
	case tenderprofile.FieldFullAddress:
		m.ClearFullAddress()
		return nil
	case tenderprofile.FieldContractor:
		m.ClearContractor()
		return nil
	case tenderprofile.FieldLevelInvolved:
		m.ClearLevelInvolved()
		return nil
	case tenderprofile.FieldSizeAndValueRating:
		m.ClearSizeAndValueRating()
		return nil
	case tenderprofile.FieldSizeAndValueRatingOverview:
		m.ClearSizeAndValueRatingOverview()
		return nil
	case tenderprofile.FieldCreditAndPaymentRating:
		m.ClearCreditAndPaymentRating()
		return nil
	case tenderprofile.FieldCreditAndPaymentRatingOverview:
		m.ClearCreditAndPaymentRatingOverview()
		return nil
	case tenderprofile.FieldTimeLimitRating:
		m.ClearTimeLimitRating()
		return nil
	case tenderprofile.FieldTimeLimitRatingOverview:
		m.ClearTimeLimitRatingOverview()
		return nil
	case tenderprofile.FieldCustomerRelationshipRating:
		m.ClearCustomerRelationshipRating()
		return nil
	case tenderprofile.FieldCustomerRelationshipRatingOverview:
		m.ClearCustomerRelationshipRatingOverview()
		return nil
	case tenderprofile.FieldCompetitivePartnershipRating:
		m.ClearCompetitivePartnershipRating()
		return nil
	case tenderprofile.FieldCompetitivePartnershipRatingOverview:
		m.ClearCompetitivePartnershipRatingOverview()
		return nil
	case tenderprofile.FieldProjectCode:
		m.ClearProjectCode()
		return nil
	case tenderprofile.FieldProjectType:
		m.ClearProjectType()
		return nil
	case tenderprofile.FieldProjectDefinition:
		m.ClearProjectDefinition()
		return nil
	case tenderprofile.FieldEstimatedProjectStartDate:
		m.ClearEstimatedProjectStartDate()
		return nil
	case tenderprofile.FieldEstimatedProjectEndDate:
		m.ClearEstimatedProjectEndDate()
		return nil
	case tenderprofile.FieldAttachments:
		m.ClearAttachments()
		return nil
	case tenderprofile.FieldGeoCoordinate:
		m.ClearGeoCoordinate()
		return nil
	case tenderprofile.FieldGeoBounds:
		m.ClearGeoBounds()
		return nil
	case tenderprofile.FieldRemark:
		m.ClearRemark()
		return nil
	case tenderprofile.FieldImages:
		m.ClearImages()
		return nil
	case tenderprofile.FieldTenderSituations:
		m.ClearTenderSituations()
		return nil
	case tenderprofile.FieldOwnerSituations:
		m.ClearOwnerSituations()
		return nil
	case tenderprofile.FieldBiddingInstructions:
		m.ClearBiddingInstructions()
		return nil
	case tenderprofile.FieldCompetitorSituations:
		m.ClearCompetitorSituations()
		return nil
	case tenderprofile.FieldCostEngineer:
		m.ClearCostEngineer()
		return nil
	case tenderprofile.FieldTenderForm:
		m.ClearTenderForm()
		return nil
	case tenderprofile.FieldContractForm:
		m.ClearContractForm()
		return nil
	case tenderprofile.FieldManagementCompany:
		m.ClearManagementCompany()
		return nil
	case tenderprofile.FieldTenderingAgency:
		m.ClearTenderingAgency()
		return nil
	case tenderprofile.FieldBiddingDate:
		m.ClearBiddingDate()
		return nil
	case tenderprofile.FieldFacadeConsultant:
		m.ClearFacadeConsultant()
		return nil
	case tenderprofile.FieldDesignUnit:
		m.ClearDesignUnit()
		return nil
	case tenderprofile.FieldConsultingFirm:
		m.ClearConsultingFirm()
		return nil
	case tenderprofile.FieldCurrentProgress:
		m.ClearCurrentProgress()
		return nil
	case tenderprofile.FieldTenderWinCompany:
		m.ClearTenderWinCompany()
		return nil
	case tenderprofile.FieldTenderCode:
		m.ClearTenderCode()
		return nil
	case tenderprofile.FieldArchitect:
		m.ClearArchitect()
		return nil
	case tenderprofile.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case tenderprofile.FieldTenderClosingDate:
		m.ClearTenderClosingDate()
		return nil
	case tenderprofile.FieldConstructionArea:
		m.ClearConstructionArea()
		return nil
	case tenderprofile.FieldTenderWinDate:
		m.ClearTenderWinDate()
		return nil
	case tenderprofile.FieldTenderWinAmount:
		m.ClearTenderWinAmount()
		return nil
	case tenderprofile.FieldLastTenderAmount:
		m.ClearLastTenderAmount()
		return nil
	case tenderprofile.FieldProvinceID:
		m.ClearProvinceID()
		return nil
	case tenderprofile.FieldCityID:
		m.ClearCityID()
		return nil
	case tenderprofile.FieldDistrictID:
		m.ClearDistrictID()
		return nil
	case tenderprofile.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case tenderprofile.FieldFinderID:
		m.ClearFinderID()
		return nil
	case tenderprofile.FieldCreatedByID:
		m.ClearCreatedByID()
		return nil
	case tenderprofile.FieldApproverID:
		m.ClearApproverID()
		return nil
	}
	return fmt.Errorf("unknown TenderProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenderProfileMutation) ResetField(name string) error {
	switch name {
	case tenderprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenderprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenderprofile.FieldStatus:
		m.ResetStatus()
		return nil
	case tenderprofile.FieldApprovalStatus:
		m.ResetApprovalStatus()
		return nil
	case tenderprofile.FieldApprovalMsgID:
		m.ResetApprovalMsgID()
		return nil
	case tenderprofile.FieldName:
		m.ResetName()
		return nil
	case tenderprofile.FieldEstimatedAmount:
		m.ResetEstimatedAmount()
		return nil
	case tenderprofile.FieldTenderDate:
		m.ResetTenderDate()
		return nil
	case tenderprofile.FieldClassify:
		m.ResetClassify()
		return nil
	case tenderprofile.FieldDiscoveryDate:
		m.ResetDiscoveryDate()
		return nil
	case tenderprofile.FieldAddress:
		m.ResetAddress()
		return nil
	case tenderprofile.FieldFullAddress:
		m.ResetFullAddress()
		return nil
	case tenderprofile.FieldContractor:
		m.ResetContractor()
		return nil
	case tenderprofile.FieldLevelInvolved:
		m.ResetLevelInvolved()
		return nil
	case tenderprofile.FieldSizeAndValueRating:
		m.ResetSizeAndValueRating()
		return nil
	case tenderprofile.FieldSizeAndValueRatingOverview:
		m.ResetSizeAndValueRatingOverview()
		return nil
	case tenderprofile.FieldCreditAndPaymentRating:
		m.ResetCreditAndPaymentRating()
		return nil
	case tenderprofile.FieldCreditAndPaymentRatingOverview:
		m.ResetCreditAndPaymentRatingOverview()
		return nil
	case tenderprofile.FieldTimeLimitRating:
		m.ResetTimeLimitRating()
		return nil
	case tenderprofile.FieldTimeLimitRatingOverview:
		m.ResetTimeLimitRatingOverview()
		return nil
	case tenderprofile.FieldCustomerRelationshipRating:
		m.ResetCustomerRelationshipRating()
		return nil
	case tenderprofile.FieldCustomerRelationshipRatingOverview:
		m.ResetCustomerRelationshipRatingOverview()
		return nil
	case tenderprofile.FieldCompetitivePartnershipRating:
		m.ResetCompetitivePartnershipRating()
		return nil
	case tenderprofile.FieldCompetitivePartnershipRatingOverview:
		m.ResetCompetitivePartnershipRatingOverview()
		return nil
	case tenderprofile.FieldPrepareToBid:
		m.ResetPrepareToBid()
		return nil
	case tenderprofile.FieldProjectCode:
		m.ResetProjectCode()
		return nil
	case tenderprofile.FieldProjectType:
		m.ResetProjectType()
		return nil
	case tenderprofile.FieldProjectDefinition:
		m.ResetProjectDefinition()
		return nil
	case tenderprofile.FieldEstimatedProjectStartDate:
		m.ResetEstimatedProjectStartDate()
		return nil
	case tenderprofile.FieldEstimatedProjectEndDate:
		m.ResetEstimatedProjectEndDate()
		return nil
	case tenderprofile.FieldAttachments:
		m.ResetAttachments()
		return nil
	case tenderprofile.FieldGeoCoordinate:
		m.ResetGeoCoordinate()
		return nil
	case tenderprofile.FieldGeoBounds:
		m.ResetGeoBounds()
		return nil
	case tenderprofile.FieldRemark:
		m.ResetRemark()
		return nil
	case tenderprofile.FieldImages:
		m.ResetImages()
		return nil
	case tenderprofile.FieldTenderSituations:
		m.ResetTenderSituations()
		return nil
	case tenderprofile.FieldOwnerSituations:
		m.ResetOwnerSituations()
		return nil
	case tenderprofile.FieldBiddingInstructions:
		m.ResetBiddingInstructions()
		return nil
	case tenderprofile.FieldCompetitorSituations:
		m.ResetCompetitorSituations()
		return nil
	case tenderprofile.FieldCostEngineer:
		m.ResetCostEngineer()
		return nil
	case tenderprofile.FieldTenderForm:
		m.ResetTenderForm()
		return nil
	case tenderprofile.FieldContractForm:
		m.ResetContractForm()
		return nil
	case tenderprofile.FieldManagementCompany:
		m.ResetManagementCompany()
		return nil
	case tenderprofile.FieldTenderingAgency:
		m.ResetTenderingAgency()
		return nil
	case tenderprofile.FieldBiddingDate:
		m.ResetBiddingDate()
		return nil
	case tenderprofile.FieldFacadeConsultant:
		m.ResetFacadeConsultant()
		return nil
	case tenderprofile.FieldDesignUnit:
		m.ResetDesignUnit()
		return nil
	case tenderprofile.FieldConsultingFirm:
		m.ResetConsultingFirm()
		return nil
	case tenderprofile.FieldKeyProject:
		m.ResetKeyProject()
		return nil
	case tenderprofile.FieldCurrentProgress:
		m.ResetCurrentProgress()
		return nil
	case tenderprofile.FieldTenderWinCompany:
		m.ResetTenderWinCompany()
		return nil
	case tenderprofile.FieldTenderCode:
		m.ResetTenderCode()
		return nil
	case tenderprofile.FieldArchitect:
		m.ResetArchitect()
		return nil
	case tenderprofile.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case tenderprofile.FieldTenderClosingDate:
		m.ResetTenderClosingDate()
		return nil
	case tenderprofile.FieldConstructionArea:
		m.ResetConstructionArea()
		return nil
	case tenderprofile.FieldTenderWinDate:
		m.ResetTenderWinDate()
		return nil
	case tenderprofile.FieldTenderWinAmount:
		m.ResetTenderWinAmount()
		return nil
	case tenderprofile.FieldLastTenderAmount:
		m.ResetLastTenderAmount()
		return nil
	case tenderprofile.FieldTenderID:
		m.ResetTenderID()
		return nil
	case tenderprofile.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case tenderprofile.FieldCityID:
		m.ResetCityID()
		return nil
	case tenderprofile.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case tenderprofile.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case tenderprofile.FieldFinderID:
		m.ResetFinderID()
		return nil
	case tenderprofile.FieldCreatedByID:
		m.ResetCreatedByID()
		return nil
	case tenderprofile.FieldApproverID:
		m.ResetApproverID()
		return nil
	}
	return fmt.Errorf("unknown TenderProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenderProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tender != nil {
		edges = append(edges, tenderprofile.EdgeTender)
	}
	if m.customer != nil {
		edges = append(edges, tenderprofile.EdgeCustomer)
	}
	if m.finder != nil {
		edges = append(edges, tenderprofile.EdgeFinder)
	}
	if m.created_by != nil {
		edges = append(edges, tenderprofile.EdgeCreatedBy)
	}
	if m.province != nil {
		edges = append(edges, tenderprofile.EdgeProvince)
	}
	if m.city != nil {
		edges = append(edges, tenderprofile.EdgeCity)
	}
	if m.district != nil {
		edges = append(edges, tenderprofile.EdgeDistrict)
	}
	if m.approver != nil {
		edges = append(edges, tenderprofile.EdgeApprover)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenderProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenderprofile.EdgeTender:
		if id := m.tender; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeFinder:
		if id := m.finder; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeProvince:
		if id := m.province; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case tenderprofile.EdgeApprover:
		if id := m.approver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenderProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenderProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenderProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtender {
		edges = append(edges, tenderprofile.EdgeTender)
	}
	if m.clearedcustomer {
		edges = append(edges, tenderprofile.EdgeCustomer)
	}
	if m.clearedfinder {
		edges = append(edges, tenderprofile.EdgeFinder)
	}
	if m.clearedcreated_by {
		edges = append(edges, tenderprofile.EdgeCreatedBy)
	}
	if m.clearedprovince {
		edges = append(edges, tenderprofile.EdgeProvince)
	}
	if m.clearedcity {
		edges = append(edges, tenderprofile.EdgeCity)
	}
	if m.cleareddistrict {
		edges = append(edges, tenderprofile.EdgeDistrict)
	}
	if m.clearedapprover {
		edges = append(edges, tenderprofile.EdgeApprover)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenderProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case tenderprofile.EdgeTender:
		return m.clearedtender
	case tenderprofile.EdgeCustomer:
		return m.clearedcustomer
	case tenderprofile.EdgeFinder:
		return m.clearedfinder
	case tenderprofile.EdgeCreatedBy:
		return m.clearedcreated_by
	case tenderprofile.EdgeProvince:
		return m.clearedprovince
	case tenderprofile.EdgeCity:
		return m.clearedcity
	case tenderprofile.EdgeDistrict:
		return m.cleareddistrict
	case tenderprofile.EdgeApprover:
		return m.clearedapprover
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenderProfileMutation) ClearEdge(name string) error {
	switch name {
	case tenderprofile.EdgeTender:
		m.ClearTender()
		return nil
	case tenderprofile.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case tenderprofile.EdgeFinder:
		m.ClearFinder()
		return nil
	case tenderprofile.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenderprofile.EdgeProvince:
		m.ClearProvince()
		return nil
	case tenderprofile.EdgeCity:
		m.ClearCity()
		return nil
	case tenderprofile.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case tenderprofile.EdgeApprover:
		m.ClearApprover()
		return nil
	}
	return fmt.Errorf("unknown TenderProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenderProfileMutation) ResetEdge(name string) error {
	switch name {
	case tenderprofile.EdgeTender:
		m.ResetTender()
		return nil
	case tenderprofile.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case tenderprofile.EdgeFinder:
		m.ResetFinder()
		return nil
	case tenderprofile.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenderprofile.EdgeProvince:
		m.ResetProvince()
		return nil
	case tenderprofile.EdgeCity:
		m.ResetCity()
		return nil
	case tenderprofile.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case tenderprofile.EdgeApprover:
		m.ResetApprover()
		return nil
	}
	return fmt.Errorf("unknown TenderProfile edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *xid.ID
	created_at           *time.Time
	updated_at           *time.Time
	open_id              *string
	name                 *string
	email                *string
	username             *string
	avatar_url           *string
	disabled             *bool
	is_admin             *bool
	is_ceo               *bool
	is_super_admin       *bool
	has_map_access       *bool
	has_edit_access      *bool
	clearedFields        map[string]struct{}
	areas                map[xid.ID]struct{}
	removedareas         map[xid.ID]struct{}
	clearedareas         bool
	customers            map[xid.ID]struct{}
	removedcustomers     map[xid.ID]struct{}
	clearedcustomers     bool
	leader               *xid.ID
	clearedleader        bool
	team_members         map[xid.ID]struct{}
	removedteam_members  map[xid.ID]struct{}
	clearedteam_members  bool
	tenders              map[xid.ID]struct{}
	removedtenders       map[xid.ID]struct{}
	clearedtenders       bool
	visit_records        map[xid.ID]struct{}
	removedvisit_records map[xid.ID]struct{}
	clearedvisit_records bool
	projects             map[xid.ID]struct{}
	removedprojects      map[xid.ID]struct{}
	clearedprojects      bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id xid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOpenID sets the "open_id" field.
func (m *UserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *UserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *UserMutation) ResetOpenID() {
	m.open_id = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetIsCeo sets the "is_ceo" field.
func (m *UserMutation) SetIsCeo(b bool) {
	m.is_ceo = &b
}

// IsCeo returns the value of the "is_ceo" field in the mutation.
func (m *UserMutation) IsCeo() (r bool, exists bool) {
	v := m.is_ceo
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCeo returns the old "is_ceo" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsCeo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCeo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCeo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCeo: %w", err)
	}
	return oldValue.IsCeo, nil
}

// ResetIsCeo resets all changes to the "is_ceo" field.
func (m *UserMutation) ResetIsCeo() {
	m.is_ceo = nil
}

// SetIsSuperAdmin sets the "is_super_admin" field.
func (m *UserMutation) SetIsSuperAdmin(b bool) {
	m.is_super_admin = &b
}

// IsSuperAdmin returns the value of the "is_super_admin" field in the mutation.
func (m *UserMutation) IsSuperAdmin() (r bool, exists bool) {
	v := m.is_super_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperAdmin returns the old "is_super_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperAdmin: %w", err)
	}
	return oldValue.IsSuperAdmin, nil
}

// ResetIsSuperAdmin resets all changes to the "is_super_admin" field.
func (m *UserMutation) ResetIsSuperAdmin() {
	m.is_super_admin = nil
}

// SetHasMapAccess sets the "has_map_access" field.
func (m *UserMutation) SetHasMapAccess(b bool) {
	m.has_map_access = &b
}

// HasMapAccess returns the value of the "has_map_access" field in the mutation.
func (m *UserMutation) HasMapAccess() (r bool, exists bool) {
	v := m.has_map_access
	if v == nil {
		return
	}
	return *v, true
}

// OldHasMapAccess returns the old "has_map_access" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHasMapAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasMapAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasMapAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasMapAccess: %w", err)
	}
	return oldValue.HasMapAccess, nil
}

// ResetHasMapAccess resets all changes to the "has_map_access" field.
func (m *UserMutation) ResetHasMapAccess() {
	m.has_map_access = nil
}

// SetHasEditAccess sets the "has_edit_access" field.
func (m *UserMutation) SetHasEditAccess(b bool) {
	m.has_edit_access = &b
}

// HasEditAccess returns the value of the "has_edit_access" field in the mutation.
func (m *UserMutation) HasEditAccess() (r bool, exists bool) {
	v := m.has_edit_access
	if v == nil {
		return
	}
	return *v, true
}

// OldHasEditAccess returns the old "has_edit_access" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHasEditAccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasEditAccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasEditAccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasEditAccess: %w", err)
	}
	return oldValue.HasEditAccess, nil
}

// ResetHasEditAccess resets all changes to the "has_edit_access" field.
func (m *UserMutation) ResetHasEditAccess() {
	m.has_edit_access = nil
}

// SetLeaderID sets the "leader_id" field.
func (m *UserMutation) SetLeaderID(x xid.ID) {
	m.leader = &x
}

// LeaderID returns the value of the "leader_id" field in the mutation.
func (m *UserMutation) LeaderID() (r xid.ID, exists bool) {
	v := m.leader
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderID returns the old "leader_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLeaderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderID: %w", err)
	}
	return oldValue.LeaderID, nil
}

// ClearLeaderID clears the value of the "leader_id" field.
func (m *UserMutation) ClearLeaderID() {
	m.leader = nil
	m.clearedFields[user.FieldLeaderID] = struct{}{}
}

// LeaderIDCleared returns if the "leader_id" field was cleared in this mutation.
func (m *UserMutation) LeaderIDCleared() bool {
	_, ok := m.clearedFields[user.FieldLeaderID]
	return ok
}

// ResetLeaderID resets all changes to the "leader_id" field.
func (m *UserMutation) ResetLeaderID() {
	m.leader = nil
	delete(m.clearedFields, user.FieldLeaderID)
}

// AddAreaIDs adds the "areas" edge to the Area entity by ids.
func (m *UserMutation) AddAreaIDs(ids ...xid.ID) {
	if m.areas == nil {
		m.areas = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.areas[ids[i]] = struct{}{}
	}
}

// ClearAreas clears the "areas" edge to the Area entity.
func (m *UserMutation) ClearAreas() {
	m.clearedareas = true
}

// AreasCleared reports if the "areas" edge to the Area entity was cleared.
func (m *UserMutation) AreasCleared() bool {
	return m.clearedareas
}

// RemoveAreaIDs removes the "areas" edge to the Area entity by IDs.
func (m *UserMutation) RemoveAreaIDs(ids ...xid.ID) {
	if m.removedareas == nil {
		m.removedareas = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.areas, ids[i])
		m.removedareas[ids[i]] = struct{}{}
	}
}

// RemovedAreas returns the removed IDs of the "areas" edge to the Area entity.
func (m *UserMutation) RemovedAreasIDs() (ids []xid.ID) {
	for id := range m.removedareas {
		ids = append(ids, id)
	}
	return
}

// AreasIDs returns the "areas" edge IDs in the mutation.
func (m *UserMutation) AreasIDs() (ids []xid.ID) {
	for id := range m.areas {
		ids = append(ids, id)
	}
	return
}

// ResetAreas resets all changes to the "areas" edge.
func (m *UserMutation) ResetAreas() {
	m.areas = nil
	m.clearedareas = false
	m.removedareas = nil
}

// AddCustomerIDs adds the "customers" edge to the Customer entity by ids.
func (m *UserMutation) AddCustomerIDs(ids ...xid.ID) {
	if m.customers == nil {
		m.customers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "customers" edge to the Customer entity.
func (m *UserMutation) ClearCustomers() {
	m.clearedcustomers = true
}

// CustomersCleared reports if the "customers" edge to the Customer entity was cleared.
func (m *UserMutation) CustomersCleared() bool {
	return m.clearedcustomers
}

// RemoveCustomerIDs removes the "customers" edge to the Customer entity by IDs.
func (m *UserMutation) RemoveCustomerIDs(ids ...xid.ID) {
	if m.removedcustomers == nil {
		m.removedcustomers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.customers, ids[i])
		m.removedcustomers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "customers" edge to the Customer entity.
func (m *UserMutation) RemovedCustomersIDs() (ids []xid.ID) {
	for id := range m.removedcustomers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "customers" edge IDs in the mutation.
func (m *UserMutation) CustomersIDs() (ids []xid.ID) {
	for id := range m.customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "customers" edge.
func (m *UserMutation) ResetCustomers() {
	m.customers = nil
	m.clearedcustomers = false
	m.removedcustomers = nil
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *UserMutation) ClearLeader() {
	m.clearedleader = true
	m.clearedFields[user.FieldLeaderID] = struct{}{}
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *UserMutation) LeaderCleared() bool {
	return m.LeaderIDCleared() || m.clearedleader
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LeaderIDs() (ids []xid.ID) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *UserMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddTeamMemberIDs adds the "team_members" edge to the User entity by ids.
func (m *UserMutation) AddTeamMemberIDs(ids ...xid.ID) {
	if m.team_members == nil {
		m.team_members = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.team_members[ids[i]] = struct{}{}
	}
}

// ClearTeamMembers clears the "team_members" edge to the User entity.
func (m *UserMutation) ClearTeamMembers() {
	m.clearedteam_members = true
}

// TeamMembersCleared reports if the "team_members" edge to the User entity was cleared.
func (m *UserMutation) TeamMembersCleared() bool {
	return m.clearedteam_members
}

// RemoveTeamMemberIDs removes the "team_members" edge to the User entity by IDs.
func (m *UserMutation) RemoveTeamMemberIDs(ids ...xid.ID) {
	if m.removedteam_members == nil {
		m.removedteam_members = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.team_members, ids[i])
		m.removedteam_members[ids[i]] = struct{}{}
	}
}

// RemovedTeamMembers returns the removed IDs of the "team_members" edge to the User entity.
func (m *UserMutation) RemovedTeamMembersIDs() (ids []xid.ID) {
	for id := range m.removedteam_members {
		ids = append(ids, id)
	}
	return
}

// TeamMembersIDs returns the "team_members" edge IDs in the mutation.
func (m *UserMutation) TeamMembersIDs() (ids []xid.ID) {
	for id := range m.team_members {
		ids = append(ids, id)
	}
	return
}

// ResetTeamMembers resets all changes to the "team_members" edge.
func (m *UserMutation) ResetTeamMembers() {
	m.team_members = nil
	m.clearedteam_members = false
	m.removedteam_members = nil
}

// AddTenderIDs adds the "tenders" edge to the Tender entity by ids.
func (m *UserMutation) AddTenderIDs(ids ...xid.ID) {
	if m.tenders == nil {
		m.tenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.tenders[ids[i]] = struct{}{}
	}
}

// ClearTenders clears the "tenders" edge to the Tender entity.
func (m *UserMutation) ClearTenders() {
	m.clearedtenders = true
}

// TendersCleared reports if the "tenders" edge to the Tender entity was cleared.
func (m *UserMutation) TendersCleared() bool {
	return m.clearedtenders
}

// RemoveTenderIDs removes the "tenders" edge to the Tender entity by IDs.
func (m *UserMutation) RemoveTenderIDs(ids ...xid.ID) {
	if m.removedtenders == nil {
		m.removedtenders = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenders, ids[i])
		m.removedtenders[ids[i]] = struct{}{}
	}
}

// RemovedTenders returns the removed IDs of the "tenders" edge to the Tender entity.
func (m *UserMutation) RemovedTendersIDs() (ids []xid.ID) {
	for id := range m.removedtenders {
		ids = append(ids, id)
	}
	return
}

// TendersIDs returns the "tenders" edge IDs in the mutation.
func (m *UserMutation) TendersIDs() (ids []xid.ID) {
	for id := range m.tenders {
		ids = append(ids, id)
	}
	return
}

// ResetTenders resets all changes to the "tenders" edge.
func (m *UserMutation) ResetTenders() {
	m.tenders = nil
	m.clearedtenders = false
	m.removedtenders = nil
}

// AddVisitRecordIDs adds the "visit_records" edge to the VisitRecord entity by ids.
func (m *UserMutation) AddVisitRecordIDs(ids ...xid.ID) {
	if m.visit_records == nil {
		m.visit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.visit_records[ids[i]] = struct{}{}
	}
}

// ClearVisitRecords clears the "visit_records" edge to the VisitRecord entity.
func (m *UserMutation) ClearVisitRecords() {
	m.clearedvisit_records = true
}

// VisitRecordsCleared reports if the "visit_records" edge to the VisitRecord entity was cleared.
func (m *UserMutation) VisitRecordsCleared() bool {
	return m.clearedvisit_records
}

// RemoveVisitRecordIDs removes the "visit_records" edge to the VisitRecord entity by IDs.
func (m *UserMutation) RemoveVisitRecordIDs(ids ...xid.ID) {
	if m.removedvisit_records == nil {
		m.removedvisit_records = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.visit_records, ids[i])
		m.removedvisit_records[ids[i]] = struct{}{}
	}
}

// RemovedVisitRecords returns the removed IDs of the "visit_records" edge to the VisitRecord entity.
func (m *UserMutation) RemovedVisitRecordsIDs() (ids []xid.ID) {
	for id := range m.removedvisit_records {
		ids = append(ids, id)
	}
	return
}

// VisitRecordsIDs returns the "visit_records" edge IDs in the mutation.
func (m *UserMutation) VisitRecordsIDs() (ids []xid.ID) {
	for id := range m.visit_records {
		ids = append(ids, id)
	}
	return
}

// ResetVisitRecords resets all changes to the "visit_records" edge.
func (m *UserMutation) ResetVisitRecords() {
	m.visit_records = nil
	m.clearedvisit_records = false
	m.removedvisit_records = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...xid.ID) {
	if m.projects == nil {
		m.projects = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...xid.ID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []xid.ID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []xid.ID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.open_id != nil {
		fields = append(fields, user.FieldOpenID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.is_ceo != nil {
		fields = append(fields, user.FieldIsCeo)
	}
	if m.is_super_admin != nil {
		fields = append(fields, user.FieldIsSuperAdmin)
	}
	if m.has_map_access != nil {
		fields = append(fields, user.FieldHasMapAccess)
	}
	if m.has_edit_access != nil {
		fields = append(fields, user.FieldHasEditAccess)
	}
	if m.leader != nil {
		fields = append(fields, user.FieldLeaderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldOpenID:
		return m.OpenID()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldUsername:
		return m.Username()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldDisabled:
		return m.Disabled()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldIsCeo:
		return m.IsCeo()
	case user.FieldIsSuperAdmin:
		return m.IsSuperAdmin()
	case user.FieldHasMapAccess:
		return m.HasMapAccess()
	case user.FieldHasEditAccess:
		return m.HasEditAccess()
	case user.FieldLeaderID:
		return m.LeaderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldOpenID:
		return m.OldOpenID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldIsCeo:
		return m.OldIsCeo(ctx)
	case user.FieldIsSuperAdmin:
		return m.OldIsSuperAdmin(ctx)
	case user.FieldHasMapAccess:
		return m.OldHasMapAccess(ctx)
	case user.FieldHasEditAccess:
		return m.OldHasEditAccess(ctx)
	case user.FieldLeaderID:
		return m.OldLeaderID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldIsCeo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCeo(v)
		return nil
	case user.FieldIsSuperAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperAdmin(v)
		return nil
	case user.FieldHasMapAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasMapAccess(v)
		return nil
	case user.FieldHasEditAccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasEditAccess(v)
		return nil
	case user.FieldLeaderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldLeaderID) {
		fields = append(fields, user.FieldLeaderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldLeaderID:
		m.ClearLeaderID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldOpenID:
		m.ResetOpenID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldIsCeo:
		m.ResetIsCeo()
		return nil
	case user.FieldIsSuperAdmin:
		m.ResetIsSuperAdmin()
		return nil
	case user.FieldHasMapAccess:
		m.ResetHasMapAccess()
		return nil
	case user.FieldHasEditAccess:
		m.ResetHasEditAccess()
		return nil
	case user.FieldLeaderID:
		m.ResetLeaderID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.areas != nil {
		edges = append(edges, user.EdgeAreas)
	}
	if m.customers != nil {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.leader != nil {
		edges = append(edges, user.EdgeLeader)
	}
	if m.team_members != nil {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.tenders != nil {
		edges = append(edges, user.EdgeTenders)
	}
	if m.visit_records != nil {
		edges = append(edges, user.EdgeVisitRecords)
	}
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.areas))
		for id := range m.areas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.customers))
		for id := range m.customers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeTeamMembers:
		ids := make([]ent.Value, 0, len(m.team_members))
		for id := range m.team_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.tenders))
		for id := range m.tenders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.visit_records))
		for id := range m.visit_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedareas != nil {
		edges = append(edges, user.EdgeAreas)
	}
	if m.removedcustomers != nil {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.removedteam_members != nil {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.removedtenders != nil {
		edges = append(edges, user.EdgeTenders)
	}
	if m.removedvisit_records != nil {
		edges = append(edges, user.EdgeVisitRecords)
	}
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAreas:
		ids := make([]ent.Value, 0, len(m.removedareas))
		for id := range m.removedareas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removedcustomers))
		for id := range m.removedcustomers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamMembers:
		ids := make([]ent.Value, 0, len(m.removedteam_members))
		for id := range m.removedteam_members {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTenders:
		ids := make([]ent.Value, 0, len(m.removedtenders))
		for id := range m.removedtenders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVisitRecords:
		ids := make([]ent.Value, 0, len(m.removedvisit_records))
		for id := range m.removedvisit_records {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedareas {
		edges = append(edges, user.EdgeAreas)
	}
	if m.clearedcustomers {
		edges = append(edges, user.EdgeCustomers)
	}
	if m.clearedleader {
		edges = append(edges, user.EdgeLeader)
	}
	if m.clearedteam_members {
		edges = append(edges, user.EdgeTeamMembers)
	}
	if m.clearedtenders {
		edges = append(edges, user.EdgeTenders)
	}
	if m.clearedvisit_records {
		edges = append(edges, user.EdgeVisitRecords)
	}
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAreas:
		return m.clearedareas
	case user.EdgeCustomers:
		return m.clearedcustomers
	case user.EdgeLeader:
		return m.clearedleader
	case user.EdgeTeamMembers:
		return m.clearedteam_members
	case user.EdgeTenders:
		return m.clearedtenders
	case user.EdgeVisitRecords:
		return m.clearedvisit_records
	case user.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAreas:
		m.ResetAreas()
		return nil
	case user.EdgeCustomers:
		m.ResetCustomers()
		return nil
	case user.EdgeLeader:
		m.ResetLeader()
		return nil
	case user.EdgeTeamMembers:
		m.ResetTeamMembers()
		return nil
	case user.EdgeTenders:
		m.ResetTenders()
		return nil
	case user.EdgeVisitRecords:
		m.ResetVisitRecords()
		return nil
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VisitRecordMutation represents an operation that mutates the VisitRecord nodes in the graph.
type VisitRecordMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	created_at         *time.Time
	updated_at         *time.Time
	visit_type         *int
	addvisit_type      *int
	comm_people        *string
	comm_content       *string
	next_step          *string
	date               *time.Time
	clearedFields      map[string]struct{}
	tender             *xid.ID
	clearedtender      bool
	customer           *xid.ID
	clearedcustomer    bool
	followUpBys        map[xid.ID]struct{}
	removedfollowUpBys map[xid.ID]struct{}
	clearedfollowUpBys bool
	done               bool
	oldValue           func(context.Context) (*VisitRecord, error)
	predicates         []predicate.VisitRecord
}

var _ ent.Mutation = (*VisitRecordMutation)(nil)

// visitrecordOption allows management of the mutation configuration using functional options.
type visitrecordOption func(*VisitRecordMutation)

// newVisitRecordMutation creates new mutation for the VisitRecord entity.
func newVisitRecordMutation(c config, op Op, opts ...visitrecordOption) *VisitRecordMutation {
	m := &VisitRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeVisitRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVisitRecordID sets the ID field of the mutation.
func withVisitRecordID(id xid.ID) visitrecordOption {
	return func(m *VisitRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *VisitRecord
		)
		m.oldValue = func(ctx context.Context) (*VisitRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VisitRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVisitRecord sets the old VisitRecord of the mutation.
func withVisitRecord(node *VisitRecord) visitrecordOption {
	return func(m *VisitRecordMutation) {
		m.oldValue = func(context.Context) (*VisitRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VisitRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VisitRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VisitRecord entities.
func (m *VisitRecordMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VisitRecordMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VisitRecordMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VisitRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VisitRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VisitRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VisitRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VisitRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VisitRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VisitRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVisitType sets the "visit_type" field.
func (m *VisitRecordMutation) SetVisitType(i int) {
	m.visit_type = &i
	m.addvisit_type = nil
}

// VisitType returns the value of the "visit_type" field in the mutation.
func (m *VisitRecordMutation) VisitType() (r int, exists bool) {
	v := m.visit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitType returns the old "visit_type" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldVisitType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisitType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisitType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitType: %w", err)
	}
	return oldValue.VisitType, nil
}

// AddVisitType adds i to the "visit_type" field.
func (m *VisitRecordMutation) AddVisitType(i int) {
	if m.addvisit_type != nil {
		*m.addvisit_type += i
	} else {
		m.addvisit_type = &i
	}
}

// AddedVisitType returns the value that was added to the "visit_type" field in this mutation.
func (m *VisitRecordMutation) AddedVisitType() (r int, exists bool) {
	v := m.addvisit_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetVisitType resets all changes to the "visit_type" field.
func (m *VisitRecordMutation) ResetVisitType() {
	m.visit_type = nil
	m.addvisit_type = nil
}

// SetCommPeople sets the "comm_people" field.
func (m *VisitRecordMutation) SetCommPeople(s string) {
	m.comm_people = &s
}

// CommPeople returns the value of the "comm_people" field in the mutation.
func (m *VisitRecordMutation) CommPeople() (r string, exists bool) {
	v := m.comm_people
	if v == nil {
		return
	}
	return *v, true
}

// OldCommPeople returns the old "comm_people" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCommPeople(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommPeople is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommPeople requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommPeople: %w", err)
	}
	return oldValue.CommPeople, nil
}

// ResetCommPeople resets all changes to the "comm_people" field.
func (m *VisitRecordMutation) ResetCommPeople() {
	m.comm_people = nil
}

// SetCommContent sets the "comm_content" field.
func (m *VisitRecordMutation) SetCommContent(s string) {
	m.comm_content = &s
}

// CommContent returns the value of the "comm_content" field in the mutation.
func (m *VisitRecordMutation) CommContent() (r string, exists bool) {
	v := m.comm_content
	if v == nil {
		return
	}
	return *v, true
}

// OldCommContent returns the old "comm_content" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCommContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommContent: %w", err)
	}
	return oldValue.CommContent, nil
}

// ResetCommContent resets all changes to the "comm_content" field.
func (m *VisitRecordMutation) ResetCommContent() {
	m.comm_content = nil
}

// SetNextStep sets the "next_step" field.
func (m *VisitRecordMutation) SetNextStep(s string) {
	m.next_step = &s
}

// NextStep returns the value of the "next_step" field in the mutation.
func (m *VisitRecordMutation) NextStep() (r string, exists bool) {
	v := m.next_step
	if v == nil {
		return
	}
	return *v, true
}

// OldNextStep returns the old "next_step" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldNextStep(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextStep: %w", err)
	}
	return oldValue.NextStep, nil
}

// ClearNextStep clears the value of the "next_step" field.
func (m *VisitRecordMutation) ClearNextStep() {
	m.next_step = nil
	m.clearedFields[visitrecord.FieldNextStep] = struct{}{}
}

// NextStepCleared returns if the "next_step" field was cleared in this mutation.
func (m *VisitRecordMutation) NextStepCleared() bool {
	_, ok := m.clearedFields[visitrecord.FieldNextStep]
	return ok
}

// ResetNextStep resets all changes to the "next_step" field.
func (m *VisitRecordMutation) ResetNextStep() {
	m.next_step = nil
	delete(m.clearedFields, visitrecord.FieldNextStep)
}

// SetDate sets the "date" field.
func (m *VisitRecordMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *VisitRecordMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *VisitRecordMutation) ResetDate() {
	m.date = nil
}

// SetTenderID sets the "tender_id" field.
func (m *VisitRecordMutation) SetTenderID(x xid.ID) {
	m.tender = &x
}

// TenderID returns the value of the "tender_id" field in the mutation.
func (m *VisitRecordMutation) TenderID() (r xid.ID, exists bool) {
	v := m.tender
	if v == nil {
		return
	}
	return *v, true
}

// OldTenderID returns the old "tender_id" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldTenderID(ctx context.Context) (v *xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenderID: %w", err)
	}
	return oldValue.TenderID, nil
}

// ClearTenderID clears the value of the "tender_id" field.
func (m *VisitRecordMutation) ClearTenderID() {
	m.tender = nil
	m.clearedFields[visitrecord.FieldTenderID] = struct{}{}
}

// TenderIDCleared returns if the "tender_id" field was cleared in this mutation.
func (m *VisitRecordMutation) TenderIDCleared() bool {
	_, ok := m.clearedFields[visitrecord.FieldTenderID]
	return ok
}

// ResetTenderID resets all changes to the "tender_id" field.
func (m *VisitRecordMutation) ResetTenderID() {
	m.tender = nil
	delete(m.clearedFields, visitrecord.FieldTenderID)
}

// SetCustomerID sets the "customer_id" field.
func (m *VisitRecordMutation) SetCustomerID(x xid.ID) {
	m.customer = &x
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *VisitRecordMutation) CustomerID() (r xid.ID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the VisitRecord entity.
// If the VisitRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VisitRecordMutation) OldCustomerID(ctx context.Context) (v xid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *VisitRecordMutation) ResetCustomerID() {
	m.customer = nil
}

// ClearTender clears the "tender" edge to the Tender entity.
func (m *VisitRecordMutation) ClearTender() {
	m.clearedtender = true
	m.clearedFields[visitrecord.FieldTenderID] = struct{}{}
}

// TenderCleared reports if the "tender" edge to the Tender entity was cleared.
func (m *VisitRecordMutation) TenderCleared() bool {
	return m.TenderIDCleared() || m.clearedtender
}

// TenderIDs returns the "tender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenderID instead. It exists only for internal usage by the builders.
func (m *VisitRecordMutation) TenderIDs() (ids []xid.ID) {
	if id := m.tender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTender resets all changes to the "tender" edge.
func (m *VisitRecordMutation) ResetTender() {
	m.tender = nil
	m.clearedtender = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *VisitRecordMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[visitrecord.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *VisitRecordMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *VisitRecordMutation) CustomerIDs() (ids []xid.ID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *VisitRecordMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddFollowUpByIDs adds the "followUpBys" edge to the User entity by ids.
func (m *VisitRecordMutation) AddFollowUpByIDs(ids ...xid.ID) {
	if m.followUpBys == nil {
		m.followUpBys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m.followUpBys[ids[i]] = struct{}{}
	}
}

// ClearFollowUpBys clears the "followUpBys" edge to the User entity.
func (m *VisitRecordMutation) ClearFollowUpBys() {
	m.clearedfollowUpBys = true
}

// FollowUpBysCleared reports if the "followUpBys" edge to the User entity was cleared.
func (m *VisitRecordMutation) FollowUpBysCleared() bool {
	return m.clearedfollowUpBys
}

// RemoveFollowUpByIDs removes the "followUpBys" edge to the User entity by IDs.
func (m *VisitRecordMutation) RemoveFollowUpByIDs(ids ...xid.ID) {
	if m.removedfollowUpBys == nil {
		m.removedfollowUpBys = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m.followUpBys, ids[i])
		m.removedfollowUpBys[ids[i]] = struct{}{}
	}
}

// RemovedFollowUpBys returns the removed IDs of the "followUpBys" edge to the User entity.
func (m *VisitRecordMutation) RemovedFollowUpBysIDs() (ids []xid.ID) {
	for id := range m.removedfollowUpBys {
		ids = append(ids, id)
	}
	return
}

// FollowUpBysIDs returns the "followUpBys" edge IDs in the mutation.
func (m *VisitRecordMutation) FollowUpBysIDs() (ids []xid.ID) {
	for id := range m.followUpBys {
		ids = append(ids, id)
	}
	return
}

// ResetFollowUpBys resets all changes to the "followUpBys" edge.
func (m *VisitRecordMutation) ResetFollowUpBys() {
	m.followUpBys = nil
	m.clearedfollowUpBys = false
	m.removedfollowUpBys = nil
}

// Where appends a list predicates to the VisitRecordMutation builder.
func (m *VisitRecordMutation) Where(ps ...predicate.VisitRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VisitRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VisitRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VisitRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VisitRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VisitRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VisitRecord).
func (m *VisitRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VisitRecordMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, visitrecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, visitrecord.FieldUpdatedAt)
	}
	if m.visit_type != nil {
		fields = append(fields, visitrecord.FieldVisitType)
	}
	if m.comm_people != nil {
		fields = append(fields, visitrecord.FieldCommPeople)
	}
	if m.comm_content != nil {
		fields = append(fields, visitrecord.FieldCommContent)
	}
	if m.next_step != nil {
		fields = append(fields, visitrecord.FieldNextStep)
	}
	if m.date != nil {
		fields = append(fields, visitrecord.FieldDate)
	}
	if m.tender != nil {
		fields = append(fields, visitrecord.FieldTenderID)
	}
	if m.customer != nil {
		fields = append(fields, visitrecord.FieldCustomerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VisitRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case visitrecord.FieldCreatedAt:
		return m.CreatedAt()
	case visitrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case visitrecord.FieldVisitType:
		return m.VisitType()
	case visitrecord.FieldCommPeople:
		return m.CommPeople()
	case visitrecord.FieldCommContent:
		return m.CommContent()
	case visitrecord.FieldNextStep:
		return m.NextStep()
	case visitrecord.FieldDate:
		return m.Date()
	case visitrecord.FieldTenderID:
		return m.TenderID()
	case visitrecord.FieldCustomerID:
		return m.CustomerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VisitRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case visitrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case visitrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case visitrecord.FieldVisitType:
		return m.OldVisitType(ctx)
	case visitrecord.FieldCommPeople:
		return m.OldCommPeople(ctx)
	case visitrecord.FieldCommContent:
		return m.OldCommContent(ctx)
	case visitrecord.FieldNextStep:
		return m.OldNextStep(ctx)
	case visitrecord.FieldDate:
		return m.OldDate(ctx)
	case visitrecord.FieldTenderID:
		return m.OldTenderID(ctx)
	case visitrecord.FieldCustomerID:
		return m.OldCustomerID(ctx)
	}
	return nil, fmt.Errorf("unknown VisitRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case visitrecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case visitrecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case visitrecord.FieldVisitType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitType(v)
		return nil
	case visitrecord.FieldCommPeople:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommPeople(v)
		return nil
	case visitrecord.FieldCommContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommContent(v)
		return nil
	case visitrecord.FieldNextStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextStep(v)
		return nil
	case visitrecord.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case visitrecord.FieldTenderID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenderID(v)
		return nil
	case visitrecord.FieldCustomerID:
		v, ok := value.(xid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	}
	return fmt.Errorf("unknown VisitRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VisitRecordMutation) AddedFields() []string {
	var fields []string
	if m.addvisit_type != nil {
		fields = append(fields, visitrecord.FieldVisitType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VisitRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case visitrecord.FieldVisitType:
		return m.AddedVisitType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VisitRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case visitrecord.FieldVisitType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisitType(v)
		return nil
	}
	return fmt.Errorf("unknown VisitRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VisitRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(visitrecord.FieldNextStep) {
		fields = append(fields, visitrecord.FieldNextStep)
	}
	if m.FieldCleared(visitrecord.FieldTenderID) {
		fields = append(fields, visitrecord.FieldTenderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VisitRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VisitRecordMutation) ClearField(name string) error {
	switch name {
	case visitrecord.FieldNextStep:
		m.ClearNextStep()
		return nil
	case visitrecord.FieldTenderID:
		m.ClearTenderID()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VisitRecordMutation) ResetField(name string) error {
	switch name {
	case visitrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case visitrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case visitrecord.FieldVisitType:
		m.ResetVisitType()
		return nil
	case visitrecord.FieldCommPeople:
		m.ResetCommPeople()
		return nil
	case visitrecord.FieldCommContent:
		m.ResetCommContent()
		return nil
	case visitrecord.FieldNextStep:
		m.ResetNextStep()
		return nil
	case visitrecord.FieldDate:
		m.ResetDate()
		return nil
	case visitrecord.FieldTenderID:
		m.ResetTenderID()
		return nil
	case visitrecord.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VisitRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tender != nil {
		edges = append(edges, visitrecord.EdgeTender)
	}
	if m.customer != nil {
		edges = append(edges, visitrecord.EdgeCustomer)
	}
	if m.followUpBys != nil {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VisitRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case visitrecord.EdgeTender:
		if id := m.tender; id != nil {
			return []ent.Value{*id}
		}
	case visitrecord.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case visitrecord.EdgeFollowUpBys:
		ids := make([]ent.Value, 0, len(m.followUpBys))
		for id := range m.followUpBys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VisitRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfollowUpBys != nil {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VisitRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case visitrecord.EdgeFollowUpBys:
		ids := make([]ent.Value, 0, len(m.removedfollowUpBys))
		for id := range m.removedfollowUpBys {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VisitRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtender {
		edges = append(edges, visitrecord.EdgeTender)
	}
	if m.clearedcustomer {
		edges = append(edges, visitrecord.EdgeCustomer)
	}
	if m.clearedfollowUpBys {
		edges = append(edges, visitrecord.EdgeFollowUpBys)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VisitRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case visitrecord.EdgeTender:
		return m.clearedtender
	case visitrecord.EdgeCustomer:
		return m.clearedcustomer
	case visitrecord.EdgeFollowUpBys:
		return m.clearedfollowUpBys
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VisitRecordMutation) ClearEdge(name string) error {
	switch name {
	case visitrecord.EdgeTender:
		m.ClearTender()
		return nil
	case visitrecord.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VisitRecordMutation) ResetEdge(name string) error {
	switch name {
	case visitrecord.EdgeTender:
		m.ResetTender()
		return nil
	case visitrecord.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case visitrecord.EdgeFollowUpBys:
		m.ResetFollowUpBys()
		return nil
	}
	return fmt.Errorf("unknown VisitRecord edge %s", name)
}
